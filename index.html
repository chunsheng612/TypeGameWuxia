<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>打字修仙傳：五鍵飛升</title>
    <style>
        @font-face {
            font-family: "WuxiaTitle";
            src: url("fonts/font_wuxia_title.woff2.ttf") format("truetype");
        }

        :root {
            --ink: #070b10;
            --jade: #52d7ab;
            --amber: #f3c66a;
            --blood: #ff6464;
            --frost: #7ed8ff;
            --glass: rgba(9, 17, 27, 0.56);
            --glass-strong: rgba(6, 12, 22, 0.78);
            --stage-glow: rgba(144, 247, 196, 0.36);
            --stage-spark: rgba(166, 244, 203, 0.9);
            --stage-shadow: rgba(65, 163, 134, 0.45);
            --stage-heat: rgba(255, 214, 152, 0.16);
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--ink);
            color: #f7f2e7;
            font-family: "Noto Serif TC", "PingFang TC", serif;
        }

        body.access-contrast #app {
            filter: contrast(1.18) saturate(1.1) brightness(1.03);
        }

        body.reduce-motion *,
        body.reduce-motion *::before,
        body.reduce-motion *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
            scroll-behavior: auto !important;
        }

        button {
            font: inherit;
            color: inherit;
        }

        #app {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-size: 14px;
            background:
                linear-gradient(180deg, rgba(5, 9, 15, 0.85), rgba(5, 9, 15, 0.85)),
                url("assets/backgrounds/main_game_pixel_background.jpg") center / cover;
        }

        #bg-layer {
            position: absolute;
            inset: 0;
            background-image: url("assets/title_background_inkwash.jpg");
            background-size: cover;
            background-position: center;
            transition: background-image 0.85s ease, transform 1.2s ease;
            transform: scale(1.05);
            animation: bg-breathe 13s ease-in-out infinite;
            filter: saturate(1.06);
        }

        #bg-vignette {
            position: absolute;
            inset: 0;
            background:
                radial-gradient(circle at 20% 10%, rgba(255, 226, 168, 0.16), transparent 44%),
                radial-gradient(circle at 85% 18%, rgba(84, 211, 170, 0.2), transparent 38%),
                linear-gradient(to bottom, rgba(5, 10, 18, 0.24), rgba(3, 7, 12, 0.86));
            pointer-events: none;
        }

        #bg-aurora {
            position: absolute;
            inset: 0;
            pointer-events: none;
            background:
                radial-gradient(circle at 16% 26%, var(--stage-glow), transparent 43%),
                radial-gradient(circle at 82% 22%, rgba(255, 255, 255, 0.07), transparent 34%),
                radial-gradient(circle at 58% 85%, var(--stage-heat), transparent 36%);
            mix-blend-mode: screen;
            animation: aurora-shift 12s ease-in-out infinite alternate;
        }

        .glass {
            background: var(--glass);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 14px 36px rgba(0, 0, 0, 0.44);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        #top-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 112px;
            border-radius: 16px;
            padding: 8px 11px;
            display: grid;
            grid-template-columns: minmax(240px, 26%) minmax(260px, 38%) minmax(240px, 1fr) auto;
            gap: 10px;
            z-index: 40;
            animation: slide-in 0.6s ease;
        }

        #btn-pause {
            position: static;
            z-index: 46;
            min-width: 92px;
            padding: 7px 10px;
            font-size: 14px;
            white-space: nowrap;
            justify-self: end;
            align-self: start;
        }

        #hero-card {
            display: grid;
            grid-template-columns: 70px 1fr;
            gap: 8px;
            align-items: center;
            padding: 3px;
            border-radius: 12px;
            background: rgba(12, 19, 29, 0.45);
        }

        #hero-card .portrait {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            border: 2px solid rgba(255, 218, 118, 0.65);
            object-fit: cover;
            background: rgba(0, 0, 0, 0.35);
        }

        #hero-card .title {
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            letter-spacing: 1px;
            font-size: 15px;
            color: var(--amber);
        }

        #hero-card .subtitle {
            margin-top: 2px;
            font-size: 12px;
            color: rgba(244, 239, 225, 0.8);
        }

        #companion-row {
            display: none;
        }

        #bar-stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: center;
        }

        .bar-item {
            display: grid;
            grid-template-columns: 22px 1fr 62px;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .bar-item img {
            width: 18px;
            height: 18px;
            filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.8));
        }

        .bar-shell {
            height: 14px;
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: rgba(0, 0, 0, 0.45);
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.16s ease;
            width: 100%;
        }

        #hp-fill {
            background: linear-gradient(90deg, #c51d3a, #ff7688);
        }

        #enemy-fill {
            background: linear-gradient(90deg, #5d2fbd, #d463ff);
        }

        #qi-fill {
            background: linear-gradient(90deg, #0095ff, #83f8ff);
        }

        #timer-fill {
            background: linear-gradient(90deg, #ef9634, #ffe7a9);
        }

        #metric-card {
            border-radius: 12px;
            background: rgba(10, 18, 28, 0.48);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 7px 10px;
            gap: 6px;
        }

        .metrics-row {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
        }

        .metric-cell {
            background: rgba(0, 0, 0, 0.34);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            min-height: 30px;
            display: grid;
            place-content: center;
            text-align: center;
            line-height: 1.2;
            font-size: 10px;
            color: rgba(242, 238, 227, 0.92);
        }

        .metric-val {
            color: var(--amber);
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.3px;
        }

        #arena {
            position: absolute;
            left: 12px;
            right: 12px;
            top: 130px;
            bottom: clamp(186px, 25vh, 286px);
            border-radius: 18px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: linear-gradient(180deg, rgba(7, 12, 21, 0.22), rgba(3, 8, 14, 0.84));
            z-index: 20;
        }

        #arena-light {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            background:
                radial-gradient(circle at 50% -12%, var(--stage-glow), transparent 58%),
                radial-gradient(circle at 18% 70%, rgba(255, 255, 255, 0.05), transparent 34%),
                radial-gradient(circle at 84% 80%, rgba(255, 255, 255, 0.05), transparent 32%);
            mix-blend-mode: screen;
            transition: background 0.4s ease;
        }

        #arena-ambient {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 2;
            overflow: hidden;
        }

        .ambient-spark {
            position: absolute;
            left: var(--x);
            top: 102%;
            width: var(--size);
            height: var(--size);
            border-radius: 50%;
            background: var(--stage-spark);
            box-shadow: 0 0 14px var(--stage-shadow);
            opacity: 0.2;
            animation: spark-drift var(--dur) linear infinite;
            animation-delay: var(--delay);
        }

        #feedback-flash {
            position: absolute;
            inset: -20% -5%;
            pointer-events: none;
            z-index: 14;
            opacity: 0;
            background:
                radial-gradient(circle at 50% 58%, rgba(255, 240, 169, 0.34), transparent 50%),
                radial-gradient(circle at 50% 58%, rgba(117, 237, 194, 0.25), transparent 42%);
            transition: opacity 0.16s ease;
        }

        #feedback-flash.on {
            opacity: 1;
        }

        #arena.shake-light {
            animation: arena-shake-light 0.22s ease;
        }

        #arena.shake-heavy {
            animation: arena-shake-heavy 0.34s ease;
        }

        #arena::before {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 118px,
                rgba(255, 255, 255, 0.04) 118px,
                rgba(255, 255, 255, 0.04) 120px
            );
            opacity: 0.3;
        }

        #arena[data-stage="2"]::before {
            opacity: 0.42;
            background: repeating-linear-gradient(
                -30deg,
                rgba(255, 255, 255, 0.03),
                rgba(255, 255, 255, 0.03) 24px,
                transparent 24px,
                transparent 52px
            );
        }

        #arena[data-stage="3"]::before {
            opacity: 0.45;
            background: radial-gradient(circle at 40% 40%, rgba(126, 216, 255, 0.08), transparent 28%),
                        radial-gradient(circle at 75% 68%, rgba(255, 98, 98, 0.08), transparent 24%);
        }

        #arena[data-stage="5"]::before {
            opacity: 0.55;
            background: repeating-linear-gradient(
                -20deg,
                rgba(255, 120, 60, 0.11),
                rgba(255, 120, 60, 0.11) 18px,
                rgba(25, 5, 5, 0.08) 18px,
                rgba(25, 5, 5, 0.08) 40px
            );
        }

        #hit-line {
            position: absolute;
            left: 0;
            right: 0;
            bottom: clamp(56px, 8vh, 90px);
            border-top: 2px dashed rgba(255, 222, 146, 0.6);
            opacity: 0.7;
            pointer-events: none;
            transition: opacity 0.12s ease, filter 0.12s ease, border-color 0.12s ease;
        }

        #hit-line.impact {
            opacity: 1;
            border-top-color: rgba(255, 245, 176, 0.96);
            filter: drop-shadow(0 0 8px rgba(255, 216, 125, 0.7));
        }

        #projectile-layer,
        #effect-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 6;
        }

        #monster-rail {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 6px;
            padding: 5px;
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.42), rgba(0, 0, 0, 0.28));
            border: 1px solid rgba(255, 255, 255, 0.16);
            z-index: 7;
            backdrop-filter: blur(5px);
        }

        #monster-rail img {
            width: 32px;
            height: 32px;
            object-fit: contain;
            border-radius: 7px;
            background: rgba(0, 0, 0, 0.42);
            border: 1px solid rgba(255, 255, 255, 0.14);
            opacity: 0.46;
            transform: scale(0.92);
            transition: opacity 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
        }

        #monster-rail img.active {
            opacity: 1;
            transform: scale(1.06);
            border-color: rgba(255, 221, 134, 0.72);
            box-shadow: 0 0 12px rgba(255, 194, 108, 0.34);
        }

        #hero-wrap,
        #enemy-wrap {
            position: absolute;
            bottom: clamp(52px, 7.2vh, 84px);
            width: 192px;
            height: 192px;
            display: grid;
            place-items: end center;
            pointer-events: none;
            z-index: 5;
        }

        #hero-wrap {
            left: 22px;
            z-index: 7;
            --tp-dx: 160px;
            --tp-dy: -6px;
            --tp-scale: 1.08;
        }

        #enemy-wrap {
            right: 42px;
            filter: drop-shadow(0 0 14px rgba(0, 0, 0, 0.5));
            z-index: 6;
            animation: enemy-hover 2.4s ease-in-out infinite;
        }

        #hero-sprite {
            width: 166px;
            height: 166px;
            object-fit: contain;
            image-rendering: pixelated;
            transition: transform 0.2s ease;
        }

        #enemy-sprite {
            width: 166px;
            height: 166px;
            object-fit: contain;
            image-rendering: pixelated;
            transform: scale(1.5);
            transform-origin: bottom center;
            transition: transform 0.2s ease;
        }

        #hero-wrap.jump #hero-sprite {
            transform: translateY(-18px) scale(1.03);
        }

        #hero-wrap.leap {
            animation: hero-leap 0.6s cubic-bezier(0.22, 0.9, 0.28, 1.05);
        }

        #hero-wrap.dash {
            animation: hero-dash 0.34s cubic-bezier(0.18, 0.86, 0.31, 1.06);
        }

        #hero-wrap.guard #hero-sprite {
            filter: drop-shadow(0 0 14px rgba(117, 221, 255, 0.8));
            transform: scale(1.07);
        }

        #hero-wrap.charged #hero-sprite {
            filter: drop-shadow(0 0 14px rgba(108, 248, 208, 0.72));
            animation: hero-charged-breathe 1.15s ease-in-out infinite;
        }

        #hero-wrap.ending-sheath {
            animation: hero-sheath 0.62s cubic-bezier(0.22, 0.9, 0.28, 1.04);
        }

        #hero-wrap.ending-turn {
            transform: scaleX(-1);
            transform-origin: center bottom;
            transition: transform 0.42s ease;
        }

        #hero-wrap.ending-breath #hero-sprite {
            animation: hero-breathe 2.2s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(180, 231, 255, 0.42));
        }

        #hero-wrap.hit #hero-sprite {
            transform: translateX(-8px) rotate(-3deg);
        }

        #enemy-wrap.hit #enemy-sprite {
            transform: translateX(10px) scale(1.58);
        }

        #enemy-wrap.cast #enemy-sprite {
            filter: drop-shadow(0 0 20px rgba(154, 122, 255, 0.8));
            animation: enemy-cast 0.32s ease;
        }

        #enemy-wrap.idle-hover #enemy-sprite {
            animation: enemy-idle-hover 1.2s ease-in-out;
        }

        #enemy-wrap.flicker #enemy-sprite {
            animation: enemy-flicker 0.24s ease-in-out;
        }

        #enemy-wrap.phase-blink #enemy-sprite {
            animation: enemy-phase-blink 0.34s ease-in-out;
        }

        #enemy-wrap.ending-vanish #enemy-sprite {
            animation: enemy-vanish 1.75s ease forwards;
        }

        #victory-skip-tip {
            position: absolute;
            left: 50%;
            bottom: clamp(212px, 28vh, 330px);
            transform: translateX(-50%);
            z-index: 96;
            font-size: 13px;
            color: rgba(238, 245, 255, 0.92);
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(5, 14, 24, 0.72);
            border: 1px solid rgba(255, 255, 255, 0.22);
            display: none;
            pointer-events: none;
        }

        #victory-skip-tip.show {
            display: block;
            animation: fade-in 0.22s ease;
        }

        #arena.fx-good {
            animation: arena-flash-good 0.28s ease;
        }

        #arena.fx-bad {
            animation: arena-flash-bad 0.28s ease;
        }

        #top-hud.fx-score {
            animation: hud-score-flash 0.34s ease;
        }

        #boss-distance-wrap {
            position: absolute;
            right: 16px;
            top: 52px;
            width: 204px;
            border-radius: 10px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.56);
            border: 1px solid rgba(255, 255, 255, 0.18);
            z-index: 9;
            display: none;
        }

        #boss-distance-wrap.active {
            display: block;
        }

        #boss-distance-shell {
            height: 12px;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.56);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 4px;
        }

        #boss-distance-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #51f0cc, #fff19f);
            transition: width 0.12s ease;
        }

        #prompt-board {
            position: absolute;
            left: 50%;
            top: 14px;
            transform: translateX(-50%);
            min-width: min(500px, 80%);
            padding: 8px 12px;
            border-radius: 14px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 14px 34px rgba(0, 0, 0, 0.32), inset 0 0 30px rgba(105, 221, 255, 0.05);
        }

        #prompt-board.compact {
            top: 10px;
            min-width: min(430px, 68%);
            padding: 7px 10px;
        }

        #prompt-board.compact #prompt-stage {
            display: none;
        }

        #coach-strip {
            position: absolute;
            left: 18px;
            bottom: 108px;
            transform: none;
            min-width: min(360px, 48vw);
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: linear-gradient(135deg, rgba(6, 13, 24, 0.8), rgba(7, 17, 29, 0.66));
            font-size: 11px;
            text-align: left;
            color: rgba(223, 244, 255, 0.96);
            z-index: 12;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.22s ease;
        }

        #coach-strip.show {
            opacity: 1;
        }

        #ime-panel {
            position: absolute;
            left: 50%;
            bottom: 108px;
            transform: translateX(-50%);
            width: min(440px, 62vw);
            padding: 8px 10px;
            border-radius: 12px;
            z-index: 13;
            display: none;
            text-align: left;
            background: linear-gradient(135deg, rgba(8, 14, 26, 0.82), rgba(8, 18, 30, 0.72));
        }

        #ime-panel.show {
            display: block;
            animation: rise-in 0.2s ease;
        }

        #ime-title {
            font-size: 11px;
            color: rgba(255, 229, 168, 0.95);
            letter-spacing: 0.6px;
        }

        #ime-hint {
            margin-top: 3px;
            font-size: 11px;
            color: rgba(216, 236, 255, 0.88);
            line-height: 1.4;
            min-height: 16px;
        }

        #ime-input {
            margin-top: 6px;
            width: 100%;
            height: 34px;
            border-radius: 10px;
            border: 1px solid rgba(132, 245, 220, 0.48);
            background: rgba(5, 12, 20, 0.78);
            color: #f3fbff;
            padding: 0 10px;
            font-size: 14px;
            outline: none;
            box-shadow: inset 0 0 0 1px rgba(132, 245, 220, 0.08);
        }

        #ime-input:focus {
            border-color: rgba(132, 245, 220, 0.88);
            box-shadow: 0 0 0 2px rgba(132, 245, 220, 0.14), inset 0 0 0 1px rgba(132, 245, 220, 0.08);
        }

        .phonetic-hint {
            display: inline-block;
            margin-top: 4px;
            font-size: 13px;
            letter-spacing: 1px;
            color: rgba(176, 240, 255, 0.95);
            text-shadow: 0 0 8px rgba(99, 201, 255, 0.18);
        }

        #boss-qte-panel,
        #counter-window-panel {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            z-index: 18;
            pointer-events: none;
            display: none;
            border-radius: 14px;
            padding: 10px 12px;
            text-align: center;
            min-width: min(380px, 86vw);
        }

        #boss-qte-panel.show,
        #counter-window-panel.show {
            display: block;
            animation: rise-in 0.18s ease;
        }

        #boss-qte-panel {
            top: 142px;
            background: rgba(12, 18, 32, 0.82);
            border: 1px solid rgba(255, 164, 164, 0.65);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.42), 0 0 18px rgba(255, 116, 116, 0.24);
        }

        #boss-qte-panel.danger {
            border-color: rgba(255, 106, 106, 0.98);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.46), 0 0 26px rgba(255, 84, 84, 0.52);
            animation: qte-danger-pulse 0.34s ease-in-out infinite;
        }

        #counter-window-panel {
            top: 238px;
            background: rgba(8, 22, 30, 0.82);
            border: 1px solid rgba(132, 245, 220, 0.65);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.36), 0 0 16px rgba(103, 240, 211, 0.22);
        }

        #stage2-qte-panel {
            position: absolute;
            right: 14px;
            top: 116px;
            z-index: 14;
            display: none;
            min-width: min(240px, 42vw);
            padding: 8px 10px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(166, 229, 255, 0.42);
            background: rgba(8, 16, 28, 0.74);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.34), 0 0 15px rgba(122, 214, 255, 0.16);
            pointer-events: none;
        }

        #stage2-qte-panel.show {
            display: block;
            animation: rise-in 0.16s ease;
        }

        #stage2-qte-panel.danger {
            border-color: rgba(255, 155, 128, 0.8);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.38), 0 0 18px rgba(255, 130, 120, 0.34);
        }

        #stage2-qte-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #89dfff, #f7ffad);
            transition: width 0.06s linear;
        }

        .qte-title {
            font-size: 12px;
            color: rgba(255, 226, 174, 0.95);
            letter-spacing: 1px;
        }

        .qte-keyline {
            margin-top: 3px;
            display: flex;
            justify-content: center;
            align-items: baseline;
            gap: 7px;
            color: rgba(242, 248, 255, 0.96);
            font-size: 14px;
        }

        #stage2-qte-key {
            display: inline-block;
            min-width: 78px;
            text-align: center;
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: 22px;
            color: #fff3d0;
            text-shadow: 0 0 12px rgba(255, 228, 170, 0.28);
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        #boss-qte-key {
            display: inline-grid;
            place-items: center;
            min-width: 62px;
            height: 62px;
            border-radius: 12px;
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: 40px;
            color: #fff6dc;
            border: 2px solid rgba(255, 232, 176, 0.9);
            background: linear-gradient(180deg, rgba(255, 196, 129, 0.28), rgba(255, 118, 118, 0.2));
            text-shadow: 0 0 12px rgba(255, 196, 142, 0.58);
        }

        #boss-qte-countdown {
            margin-top: 5px;
            font-size: 20px;
            color: #ffdca7;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .qte-bar-shell {
            margin-top: 6px;
            height: 10px;
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: rgba(0, 0, 0, 0.5);
        }

        #boss-qte-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff8b8b, #ffd39f);
            transition: width 0.06s linear;
        }

        #counter-window-time {
            margin-top: 2px;
            font-size: 24px;
            color: #bffff0;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        #counter-window-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #66f8d8, #f4ff9f);
            transition: width 0.06s linear;
        }

        #prompt-stage {
            font-size: 12px;
            color: rgba(255, 226, 162, 0.92);
            letter-spacing: 0.8px;
        }

        #prompt-main {
            margin-top: 2px;
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: clamp(24px, 3.2vw, 44px);
            letter-spacing: 2.5px;
            color: #fff8e6;
            text-shadow: 0 0 16px rgba(255, 219, 143, 0.32);
            min-height: 46px;
            line-height: 1.12;
        }

        #prompt-sub {
            display: none;
        }

        .guide-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(5, 12, 22, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            color: rgba(235, 244, 255, 0.94);
        }

        .guide-chip img {
            width: 13px;
            height: 13px;
            filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.75));
        }

        .guide-chip.active {
            border-color: rgba(255, 218, 130, 0.9);
            box-shadow: 0 0 12px rgba(255, 194, 101, 0.28);
            color: #fff5d4;
        }

        #word-progress {
            margin-top: 4px;
            font-size: clamp(16px, 1.8vw, 22px);
            letter-spacing: 2px;
            min-height: 26px;
        }

        #prompt-board.compact #prompt-main {
            font-size: clamp(19px, 2.7vw, 34px);
            min-height: 34px;
        }

        #prompt-board.compact #word-progress {
            display: none;
        }

        #word-progress .done {
            color: var(--jade);
        }

        #word-progress .current {
            color: var(--amber);
            text-decoration: underline;
            text-underline-offset: 3px;
        }

        #combo-float {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: 40px;
            color: #ffe5a0;
            opacity: 0;
            text-shadow: 0 0 16px rgba(255, 148, 84, 0.54);
            pointer-events: none;
            z-index: 15;
        }

        #combo-float.show {
            animation: combo-rise 0.9s ease;
        }

        #stage-clear-fx {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            opacity: 0;
            pointer-events: none;
            z-index: 16;
        }

        #stage-clear-fx.play {
            animation: fx-burst 1.2s ease;
        }

        .rune-orb,
        .shadow-bolt {
            position: absolute;
            min-width: 44px;
            height: 62px;
            display: grid;
            place-items: center;
            border-radius: 10px;
            font-weight: 700;
            font-size: 26px;
            text-transform: uppercase;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.34);
        }

        .rune-orb {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background:
                radial-gradient(circle at 30% 30%, rgba(214, 255, 224, 0.95), rgba(109, 238, 173, 0.85) 35%, rgba(23, 122, 91, 0.82) 70%);
            color: #f5fff1;
            border-color: rgba(178, 255, 221, 0.72);
            box-shadow:
                0 0 22px rgba(98, 255, 176, 0.44),
                0 0 36px rgba(40, 137, 94, 0.32);
            animation: rune-pulse 1.1s ease-in-out infinite;
        }

        .shadow-bolt {
            width: 56px;
            height: 46px;
            border-radius: 999px 12px 12px 999px;
            background:
                linear-gradient(90deg, rgba(125, 92, 255, 0.95), rgba(42, 19, 104, 0.94) 60%, rgba(13, 8, 32, 0.95));
            color: #d7e8ff;
            border-color: rgba(174, 146, 255, 0.72);
            letter-spacing: 1px;
            box-shadow:
                0 0 16px rgba(131, 109, 255, 0.46),
                0 0 30px rgba(57, 37, 138, 0.28);
        }

        .slash-wave,
        .jump-burst,
        .dash-streak,
        .guard-ring,
        .enemy-spark,
        .charge-aura,
        .charge-glyph,
        .teleport-blink,
        .teleport-rift,
        .impact-burst,
        .impact-ring {
            position: absolute;
            pointer-events: none;
            z-index: 12;
        }

        .slash-wave {
            width: 180px;
            height: 26px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(124, 255, 218, 0), rgba(124, 255, 218, 0.88), rgba(255, 248, 198, 0.95), rgba(124, 255, 218, 0));
            filter: drop-shadow(0 0 14px rgba(124, 255, 218, 0.6));
            transform: translateX(-50%) rotate(-14deg);
            animation: slash-fly 0.52s ease forwards;
        }

        .jump-burst {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(173, 231, 255, 0.86);
            box-shadow: 0 0 24px rgba(134, 227, 255, 0.5);
            transform: translate(-50%, -50%) scale(0.45);
            animation: ring-pop 0.45s ease forwards;
        }

        .dash-streak {
            width: 140px;
            height: 20px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(180, 236, 255, 0.9), rgba(116, 178, 255, 0));
            filter: blur(1px);
            transform: translate(-50%, -50%);
            animation: streak-fade 0.36s ease forwards;
        }

        .guard-ring {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 3px solid rgba(145, 244, 255, 0.92);
            background: radial-gradient(circle, rgba(145, 244, 255, 0.18), rgba(145, 244, 255, 0));
            transform: translate(-50%, -50%) scale(0.42);
            animation: ring-pop 0.5s ease forwards;
        }

        .enemy-spark {
            width: 170px;
            height: 170px;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(255, 229, 162, 0.55), rgba(255, 153, 120, 0.24), rgba(255, 102, 81, 0));
            transform: translate(-50%, -50%) scale(0.2);
            animation: enemy-bloom 0.42s ease forwards;
        }

        .charge-aura {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(140, 255, 214, 0.86);
            background: radial-gradient(circle, rgba(140, 255, 214, 0.22), rgba(140, 255, 214, 0));
            transform: translate(-50%, -50%) scale(0.35);
            animation: aura-pulse 0.56s ease forwards;
        }

        .charge-glyph {
            width: 84px;
            height: 84px;
            border-radius: 50%;
            border: 1px dashed rgba(255, 236, 174, 0.9);
            transform: translate(-50%, -50%) rotate(0deg) scale(0.7);
            animation: glyph-spin 0.62s ease forwards;
        }

        .teleport-blink {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(207, 255, 246, 0.48), rgba(102, 232, 255, 0.2), rgba(102, 232, 255, 0));
            transform: translate(-50%, -50%) scale(0.28);
            animation: teleport-blink 0.34s ease forwards;
        }

        .teleport-rift {
            width: 34px;
            height: 138px;
            border-radius: 999px;
            background: linear-gradient(180deg, rgba(179, 255, 247, 0), rgba(179, 255, 247, 0.95), rgba(255, 236, 172, 0.92), rgba(179, 255, 247, 0));
            filter: blur(0.4px) drop-shadow(0 0 10px rgba(134, 241, 255, 0.5));
            transform: translate(-50%, -50%) scaleY(0.32);
            animation: teleport-rift 0.32s ease forwards;
        }

        .impact-burst {
            width: 128px;
            height: 128px;
            border-radius: 50%;
            background:
                conic-gradient(from 0deg, rgba(255, 250, 201, 0), rgba(255, 250, 201, 0.95), rgba(132, 255, 231, 0.75), rgba(255, 250, 201, 0)),
                radial-gradient(circle, rgba(255, 235, 180, 0.35), rgba(255, 235, 180, 0));
            mix-blend-mode: screen;
            transform: translate(-50%, -50%) scale(0.18);
            animation: impact-burst 0.34s ease forwards;
        }

        .impact-ring {
            width: 144px;
            height: 144px;
            border-radius: 50%;
            border: 2px solid rgba(255, 236, 171, 0.9);
            background: radial-gradient(circle, rgba(255, 239, 182, 0.2), rgba(255, 239, 182, 0));
            transform: translate(-50%, -50%) scale(0.28);
            animation: impact-ring 0.42s ease forwards;
        }

        #hero-wrap.teleport-strike {
            animation: hero-teleport-strike 0.34s cubic-bezier(0.18, 0.88, 0.26, 1.05);
            z-index: 11;
        }

        #hero-wrap.teleport-strike #hero-sprite {
            filter: drop-shadow(0 0 12px rgba(190, 255, 244, 0.76)) drop-shadow(0 0 20px rgba(255, 223, 138, 0.34));
        }

        .float-msg {
            position: absolute;
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: 22px;
            color: #fff;
            pointer-events: none;
            animation: float-up 0.9s ease forwards;
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.7);
        }

        #bottom-hud {
            position: absolute;
            left: 10px;
            right: 10px;
            bottom: 9px;
            min-height: 106px;
            border-radius: 15px;
            z-index: 35;
            padding: 8px 9px;
            display: grid;
            grid-template-columns: minmax(260px, 1fr) minmax(220px, 0.65fr);
            gap: 8px;
        }

        #objective-panel,
        #help-panel {
            border-radius: 12px;
            background: rgba(7, 13, 23, 0.62);
            border: 1px solid rgba(255, 255, 255, 0.18);
            padding: 8px 10px;
            overflow: hidden;
        }

        #objective-panel {
            background:
                linear-gradient(180deg, rgba(8, 14, 24, 0.76), rgba(6, 11, 18, 0.62)),
                url("assets/backgrounds/inventory_background_pixel.jpg") center / cover;
        }

        .panel-title {
            font-size: 12px;
            color: rgba(255, 231, 163, 0.9);
            letter-spacing: 1px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .panel-title img {
            width: 14px;
            height: 14px;
        }

        #objective-main {
            font-size: 15px;
            min-height: 40px;
            line-height: 1.4;
        }

        #objective-guide {
            margin-top: 4px;
            min-height: 34px;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        #objective-guide .guide-chip {
            padding: 4px 8px;
            font-size: 12px;
            background: rgba(8, 18, 30, 0.78);
        }

        #objective-guide .guide-chip.active {
            border-color: rgba(255, 218, 130, 0.92);
            box-shadow: 0 0 10px rgba(255, 196, 101, 0.3);
        }

        #objective-progress {
            margin-top: 4px;
            color: rgba(211, 247, 255, 0.95);
            font-size: 13px;
        }

        #stage-track {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 5px;
        }

        .stage-node {
            border-radius: 8px;
            padding: 4px;
            text-align: center;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(0, 0, 0, 0.35);
            opacity: 0.45;
        }

        .stage-node img {
            width: 100%;
            height: 34px;
            border-radius: 6px;
            object-fit: cover;
            margin-bottom: 3px;
        }

        .stage-node.active {
            opacity: 1;
            border-color: rgba(255, 219, 129, 0.82);
            box-shadow: 0 0 12px rgba(255, 195, 109, 0.3);
        }

        .stage-node.done {
            opacity: 0.9;
            border-color: rgba(82, 215, 171, 0.72);
        }

        #help-panel {
            background:
                linear-gradient(135deg, rgba(8, 14, 24, 0.8), rgba(10, 20, 30, 0.72)),
                url("assets/backgrounds/shop_background_pixel.jpg") center / cover;
        }

        #help-text {
            font-size: 14px;
            line-height: 1.65;
            color: rgba(236, 244, 255, 0.94);
        }

        #learning-panel {
            margin-top: 8px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background:
                linear-gradient(135deg, rgba(8, 16, 28, 0.76), rgba(7, 18, 28, 0.62)),
                radial-gradient(circle at 86% 18%, rgba(110, 248, 219, 0.08), rgba(110, 248, 219, 0));
            padding: 7px 8px;
        }

        #learning-title {
            font-size: 12px;
            color: rgba(255, 230, 164, 0.96);
            letter-spacing: 0.8px;
            margin-bottom: 4px;
        }

        .learning-row {
            font-size: 12px;
            line-height: 1.5;
            color: rgba(231, 246, 255, 0.92);
        }

        #dialogue-panel {
            position: absolute;
            left: 50%;
            bottom: 162px;
            transform: translateX(-50%);
            width: min(860px, calc(100vw - 28px));
            border-radius: 18px;
            padding: 14px 16px;
            z-index: 90;
            display: none;
        }

        #dialogue-panel.show {
            display: block;
            animation: rise-in 0.3s ease;
        }

        #dialogue-speaker {
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: 20px;
            color: var(--amber);
            letter-spacing: 1px;
        }

        #dialogue-text {
            margin-top: 6px;
            font-size: 19px;
            line-height: 1.5;
            min-height: 72px;
            color: rgba(247, 243, 233, 0.97);
        }

        #dialogue-tip {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            color: rgba(212, 223, 239, 0.8);
        }

        .wood-btn {
            border: 1px solid rgba(255, 242, 192, 0.62);
            border-radius: 10px;
            background:
                linear-gradient(135deg, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.2)),
                url("assets/ui/button_wood_texture.png") center / cover;
            color: #fff4d0;
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            letter-spacing: 1px;
            padding: 8px 16px;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
        }

        .wood-btn:hover {
            transform: translateY(-1px);
            filter: brightness(1.08);
        }

        .screen {
            position: absolute;
            inset: 0;
            z-index: 100;
            display: none;
            place-items: center;
            text-align: center;
            padding: 20px;
        }

        .screen.show {
            display: grid;
            animation: fade-in 0.45s ease;
        }

        .screen-card {
            width: min(900px, 94vw);
            border-radius: 18px;
            padding: 18px;
            background: rgba(5, 10, 18, 0.78);
            border: 1px solid rgba(255, 255, 255, 0.24);
            box-shadow: 0 18px 44px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
        }

        #loading-screen {
            z-index: 130;
            background:
                linear-gradient(180deg, rgba(5, 10, 16, 0.72), rgba(4, 8, 13, 0.9)),
                url("assets/title_background_inkwash.jpg") center / cover;
        }

        #loading-card {
            width: min(720px, 92vw);
            padding: 18px 18px 16px;
            background:
                linear-gradient(180deg, rgba(7, 14, 24, 0.84), rgba(6, 10, 18, 0.78)),
                radial-gradient(circle at 14% 10%, rgba(255, 221, 145, 0.12), rgba(255, 221, 145, 0));
            border: 1px solid rgba(255, 245, 214, 0.22);
            box-shadow: 0 18px 44px rgba(0, 0, 0, 0.46), 0 0 24px rgba(92, 202, 180, 0.08);
        }

        #loading-title {
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: clamp(24px, 3.2vw, 40px);
            color: #ffe7ac;
            letter-spacing: 2px;
            text-shadow: 0 0 14px rgba(255, 196, 111, 0.28);
        }

        #loading-sub {
            margin-top: 6px;
            font-size: 14px;
            line-height: 1.55;
            color: rgba(232, 241, 255, 0.9);
        }

        #loading-bar-shell {
            margin-top: 14px;
            height: 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.22);
            background: rgba(4, 8, 14, 0.72);
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.35);
        }

        #loading-bar-fill {
            width: 0%;
            height: 100%;
            background:
                linear-gradient(90deg, rgba(109, 240, 213, 0.92), rgba(255, 220, 144, 0.96));
            box-shadow: 0 0 14px rgba(101, 245, 218, 0.32);
            transition: width 0.16s ease;
        }

        #loading-meta {
            margin-top: 8px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            align-items: center;
            font-size: 13px;
            color: rgba(224, 237, 255, 0.9);
        }

        #loading-count {
            color: rgba(207, 246, 255, 0.9);
        }

        #loading-percent {
            color: #ffe6a4;
            font-weight: 700;
        }

        #loading-hint {
            margin-top: 8px;
            min-height: 22px;
            font-size: 12px;
            color: rgba(201, 219, 239, 0.82);
            letter-spacing: 0.3px;
        }

        #title-screen {
            background:
                linear-gradient(180deg, rgba(6, 10, 16, 0.42), rgba(4, 8, 13, 0.78)),
                url("assets/title_background_inkwash.jpg") center / cover;
        }

        #title-screen .logo {
            width: min(680px, 86vw);
            max-height: 180px;
            object-fit: contain;
            margin-bottom: 10px;
        }

        #title-name {
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: clamp(36px, 5vw, 64px);
            letter-spacing: 2px;
            color: #ffe8ab;
            text-shadow: 0 0 16px rgba(255, 189, 110, 0.35);
            margin-bottom: 8px;
        }

        #title-sub {
            font-size: clamp(15px, 1.8vw, 21px);
            color: rgba(242, 239, 227, 0.9);
            margin-bottom: 16px;
            line-height: 1.55;
        }

        #title-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #title-controls .wood-btn {
            min-width: 180px;
            font-size: 18px;
            padding: 10px 16px;
        }

        #title-options {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #title-options .wood-btn {
            min-width: 138px;
            font-size: 14px;
            padding: 7px 12px;
        }

        #btn-title-settings {
            min-width: 112px;
            font-size: 13px;
            padding: 6px 10px;
            opacity: 0.9;
        }

        #title-settings-toggle {
            margin-top: 6px;
        }

        #title-more {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.28s ease, opacity 0.22s ease, margin-top 0.22s ease;
            margin-top: 0;
        }

        #title-more.show {
            max-height: 240px;
            opacity: 1;
            margin-top: 10px;
        }

        #control-hints {
            margin-top: 16px;
            font-size: 13px;
            color: rgba(205, 218, 238, 0.86);
            line-height: 1.6;
        }

        #cloud-settings {
            width: min(620px, 100%);
            margin: 10px auto 0;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(8, 14, 22, 0.56);
            padding: 8px;
            text-align: left;
        }

        #cloud-settings-title {
            font-size: 12px;
            color: rgba(255, 228, 163, 0.92);
            margin-bottom: 6px;
            letter-spacing: 1px;
        }

        .cloud-setting-row {
            display: grid;
            grid-template-columns: 86px minmax(0, 1fr);
            align-items: center;
            gap: 8px;
            margin-top: 6px;
        }

        .cloud-setting-row label {
            font-size: 12px;
            color: rgba(219, 232, 249, 0.9);
        }

        .cloud-setting-row input {
            width: 100%;
            min-width: 0;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(5, 10, 16, 0.76);
            color: #eef7ff;
            padding: 7px 8px;
            font-size: 13px;
            outline: none;
        }

        .cloud-setting-row input:focus {
            border-color: rgba(128, 252, 221, 0.74);
            box-shadow: 0 0 0 2px rgba(114, 242, 218, 0.12);
        }

        #cloud-settings-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        #cloud-settings-actions .wood-btn {
            min-width: 124px;
            font-size: 13px;
            padding: 6px 10px;
        }

        #cloud-settings-status {
            margin-top: 6px;
            min-height: 18px;
            font-size: 12px;
            color: rgba(198, 218, 239, 0.84);
            line-height: 1.4;
        }

        #title-leaderboard {
            margin-top: 14px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background:
                linear-gradient(180deg, rgba(7, 13, 22, 0.72), rgba(6, 11, 18, 0.6)),
                radial-gradient(circle at 8% 12%, rgba(255, 225, 153, 0.08), rgba(255, 225, 153, 0));
            padding: 10px;
            text-align: left;
        }

        #title-leaderboard-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }

        #title-leaderboard-title {
            font-size: 13px;
            color: rgba(255, 230, 168, 0.94);
            letter-spacing: 1px;
        }

        #title-leaderboard-status {
            font-size: 11px;
            color: rgba(206, 222, 241, 0.82);
        }

        #title-leaderboard-grid {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }

        .lb-stage-card {
            border-radius: 9px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(7, 13, 22, 0.56);
            padding: 7px 8px;
            min-height: 134px;
        }

        .lb-stage-name {
            font-size: 11px;
            color: rgba(233, 241, 253, 0.9);
            min-height: 30px;
            line-height: 1.35;
        }

        .lb-stage-score {
            margin-top: 3px;
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: 18px;
            color: #ffe4a3;
            letter-spacing: 1px;
        }

        .lb-stage-player {
            margin-top: 2px;
            font-size: 11px;
            color: rgba(188, 241, 226, 0.86);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .lb-top3-list {
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .lb-top3-row {
            display: grid;
            grid-template-columns: 18px minmax(0, 1fr) auto;
            gap: 4px;
            align-items: center;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background: rgba(255, 255, 255, 0.03);
            padding: 2px 4px;
            font-size: 10px;
            color: rgba(227, 238, 252, 0.9);
        }

        .lb-top3-rank {
            text-align: center;
            color: rgba(255, 223, 156, 0.94);
        }

        .lb-top3-name {
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lb-top3-score {
            color: rgba(255, 239, 199, 0.96);
            font-variant-numeric: tabular-nums;
        }

        .lb-you-rank {
            margin-top: 5px;
            padding-top: 4px;
            border-top: 1px dashed rgba(255, 255, 255, 0.08);
            font-size: 10px;
            color: rgba(174, 245, 212, 0.9);
            line-height: 1.35;
        }

        #stage-select-screen {
            background:
                linear-gradient(180deg, rgba(7, 11, 16, 0.5), rgba(6, 9, 14, 0.82)),
                url("assets/backgrounds/world_map_pixel.jpg") center / cover;
        }

        #stage-select-card {
            width: min(1120px, 97vw);
            text-align: left;
            background:
                linear-gradient(180deg, rgba(8, 14, 24, 0.82), rgba(7, 11, 18, 0.78)),
                radial-gradient(circle at 10% 8%, rgba(255, 226, 160, 0.14), rgba(255, 226, 160, 0));
            border: 1px solid rgba(255, 255, 255, 0.24);
        }

        #stage-select-title {
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: clamp(32px, 4.3vw, 52px);
            color: #ffe6ab;
            text-align: center;
            letter-spacing: 2px;
            text-shadow: 0 0 18px rgba(255, 188, 108, 0.34);
        }

        #stage-select-sub {
            margin-top: 4px;
            text-align: center;
            color: rgba(232, 241, 255, 0.88);
            font-size: 15px;
        }

        #stage-select-summary {
            margin-top: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(7, 14, 24, 0.6);
            padding: 8px 10px;
            text-align: center;
            font-size: 13px;
            color: rgba(226, 237, 255, 0.9);
        }

        #stage-select-modebar {
            margin-top: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(6, 12, 20, 0.66);
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        #stage-select-modebar .mode-label {
            font-size: 12px;
            color: rgba(225, 238, 255, 0.84);
            letter-spacing: 1px;
        }

        #stage-select-modebar .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        #stage-select-modebar .wood-btn {
            min-width: 108px;
            padding: 6px 10px;
            font-size: 13px;
            opacity: 0.85;
        }

        #stage-select-modebar .wood-btn.active {
            opacity: 1;
            border-color: rgba(139, 255, 219, 0.72);
            box-shadow:
                inset 0 0 0 1px rgba(139, 255, 219, 0.38),
                0 0 18px rgba(94, 224, 197, 0.18);
        }

        #stage-select-grid {
            margin-top: 12px;
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 10px;
        }

        .stage-select-node {
            border-radius: 12px;
            padding: 8px;
            background: rgba(9, 16, 28, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.24);
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 240px;
        }

        .stage-select-node.pass {
            border-color: rgba(117, 240, 193, 0.74);
            box-shadow: 0 10px 24px rgba(67, 180, 140, 0.2);
        }

        .stage-node-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .stage-node-id {
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: 16px;
            color: #ffe0a3;
        }

        .stage-node-grade {
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 232, 179, 0.45);
            background: rgba(255, 205, 132, 0.12);
            color: #ffe5b0;
            font-size: 12px;
        }

        .stage-node-thumb {
            width: 100%;
            height: 58px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stage-node-title {
            color: #fef6df;
            font-size: 14px;
            min-height: 40px;
            line-height: 1.4;
        }

        .stage-node-stars {
            letter-spacing: 1px;
            min-height: 20px;
            font-size: 18px;
            line-height: 1;
        }

        .stage-node-stars .on {
            color: #ffd77e;
            text-shadow: 0 0 12px rgba(255, 196, 102, 0.45);
        }

        .stage-node-stars .off {
            color: rgba(255, 255, 255, 0.24);
        }

        .stage-node-line {
            font-size: 12px;
            color: rgba(218, 232, 255, 0.86);
            line-height: 1.45;
        }

        .stage-node-status {
            font-size: 12px;
            color: rgba(224, 241, 255, 0.92);
        }

        .stage-node-status.pass {
            color: #98ffd3;
        }

        .stage-node-status.fail {
            color: #ffd1c2;
        }

        .stage-node-play {
            margin-top: auto;
            width: 100%;
            font-size: 14px;
            padding: 7px 8px;
        }

        #stage-select-actions {
            margin-top: 12px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        #result-stage-line {
            text-align: center;
            font-size: 13px;
            color: rgba(232, 244, 255, 0.92);
            margin-top: 4px;
        }

        #result-stars {
            margin-top: 4px;
            text-align: center;
            font-size: 25px;
            letter-spacing: 2px;
            min-height: 30px;
        }

        #result-stars .on {
            color: #ffd67e;
            text-shadow: 0 0 14px rgba(255, 203, 96, 0.45);
        }

        #result-stars .off {
            color: rgba(255, 255, 255, 0.25);
        }

        #result-score-line {
            margin-top: 2px;
            text-align: center;
            font-size: 13px;
            color: rgba(244, 238, 219, 0.96);
        }

        #result-card {
            width: min(840px, 92vw);
            max-height: 86vh;
            overflow-y: auto;
            background:
                linear-gradient(180deg, rgba(8, 16, 26, 0.84), rgba(9, 10, 17, 0.76)),
                url("assets/backgrounds/world_map_pixel.jpg") center / cover;
            border: 2px solid rgba(255, 219, 139, 0.8);
            text-align: left;
            color: #fff6df;
            padding: 14px;
        }

        #pause-screen .screen-card {
            width: min(540px, 94vw);
        }

        #result-title {
            font-family: "WuxiaTitle", "Noto Serif TC", serif;
            font-size: clamp(24px, 3.1vw, 38px);
            color: #ffe6a0;
            margin-bottom: 5px;
            text-align: center;
        }

        #result-sub {
            text-align: center;
            font-size: 14px;
            margin-bottom: 8px;
        }

        #result-metrics {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 7px;
            margin-top: 10px;
        }

        #result-metrics .metric-cell {
            min-height: 52px;
            font-size: 11px;
        }

        #certificate {
            margin-top: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 240, 191, 0.45);
            background: rgba(12, 20, 29, 0.66);
            padding: 10px 11px;
            line-height: 1.55;
            font-size: 13px;
        }

        #learning-report,
        #achievement-panel,
        #growth-panel {
            margin-top: 8px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.22);
            background: rgba(8, 15, 24, 0.66);
            padding: 8px 10px;
        }

        .result-section-title {
            font-size: 12px;
            color: rgba(255, 226, 162, 0.95);
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        #learning-report-text,
        #growth-panel-text {
            font-size: 12px;
            line-height: 1.45;
            color: rgba(234, 243, 255, 0.94);
        }

        #achievement-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .achievement-pill {
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            border: 1px solid rgba(255, 226, 162, 0.5);
            background: rgba(255, 191, 106, 0.12);
            color: #ffe6ad;
        }

        #result-actions {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        #cloud-upload-panel {
            margin-top: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(8, 14, 22, 0.54);
            padding: 8px 10px;
            text-align: left;
        }

        #cloud-upload-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        #cloud-upload-title {
            font-size: 13px;
            color: rgba(255, 228, 165, 0.94);
            letter-spacing: 1px;
        }

        #cloud-upload-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        #cloud-upload-actions .wood-btn {
            min-width: 110px;
            font-size: 13px;
            padding: 6px 10px;
        }

        #cloud-upload-status {
            margin-top: 6px;
            min-height: 18px;
            font-size: 12px;
            color: rgba(206, 223, 243, 0.88);
            line-height: 1.45;
        }

        #cloud-upload-rankboard {
            margin-top: 6px;
            min-height: 24px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.02);
            padding: 6px 8px;
            color: rgba(216, 231, 248, 0.86);
            font-size: 11px;
            line-height: 1.4;
        }

        #cloud-upload-rankboard .rankboard-title {
            margin-bottom: 4px;
            color: rgba(255, 226, 163, 0.92);
            font-size: 11px;
        }

        #cloud-upload-rankboard .rankboard-list {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        #cloud-upload-rankboard .rankboard-row {
            display: grid;
            grid-template-columns: 18px minmax(0, 1fr) auto;
            gap: 6px;
            align-items: center;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(255, 255, 255, 0.03);
            padding: 3px 5px;
        }

        #cloud-upload-rankboard .rankboard-row.you {
            border-color: rgba(123, 255, 203, 0.24);
            background: rgba(118, 255, 203, 0.05);
        }

        #cloud-upload-rankboard .rankboard-meta {
            margin-top: 5px;
            color: rgba(177, 245, 214, 0.88);
        }

        #fail-screen .screen-card {
            max-width: 540px;
            background:
                linear-gradient(180deg, rgba(8, 12, 22, 0.84), rgba(5, 9, 16, 0.76)),
                url("assets/backgrounds/battle_crypt_pixel.jpg") center / cover;
        }

        #fail-reason {
            margin: 10px 0 12px;
            font-size: 18px;
            color: #ffc0c0;
        }

        #toast {
            position: absolute;
            top: 132px;
            left: 50%;
            transform: translateX(-50%);
            padding: 9px 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.28);
            background: rgba(0, 0, 0, 0.62);
            color: #fff5d2;
            font-size: 14px;
            opacity: 0;
            z-index: 120;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        #toast.show {
            opacity: 1;
        }

        .pulse-good {
            animation: pulse-good 0.36s ease;
        }

        @keyframes slide-in {
            from { transform: translateY(-12px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes rise-in {
            from { transform: translate(-50%, 10px); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        @keyframes combo-rise {
            0% { opacity: 0; transform: translate(-50%, -20%) scale(0.8); }
            25% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -120%) scale(1.2); }
        }

        @keyframes float-up {
            0% { opacity: 0; transform: translateY(8px); }
            20% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-28px); }
        }

        @keyframes fx-burst {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            25% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }

        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes bg-breathe {
            0% { transform: scale(1.03); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1.03); }
        }

        @keyframes aurora-shift {
            0% { transform: translateX(-1.5%) translateY(-1%); opacity: 0.8; }
            100% { transform: translateX(1.5%) translateY(1%); opacity: 1; }
        }

        @keyframes spark-drift {
            0% {
                transform: translate3d(0, 0, 0) scale(0.7);
                opacity: 0;
            }
            15% { opacity: 0.28; }
            100% {
                transform: translate3d(var(--drift), -118vh, 0) scale(1);
                opacity: 0;
            }
        }

        @keyframes hero-leap {
            0% { transform: translateX(0) translateY(0); }
            40% { transform: translateX(44px) translateY(-182px); }
            60% { transform: translateX(32px) translateY(-116px); }
            100% { transform: translateX(0) translateY(0); }
        }

        @keyframes hero-dash {
            0% { transform: translateX(0); }
            38% { transform: translateX(82px); }
            52% { transform: translateX(96px); }
            100% { transform: translateX(0); }
        }

        @keyframes enemy-hover {
            0% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
            100% { transform: translateY(0); }
        }

        @keyframes enemy-cast {
            0% { transform: scale(1.5); }
            50% { transform: scale(1.57) translateY(-4px); }
            100% { transform: scale(1.5); }
        }

        @keyframes rune-pulse {
            0% { transform: scale(0.92); }
            50% { transform: scale(1.04); }
            100% { transform: scale(0.92); }
        }

        @keyframes slash-fly {
            0% { opacity: 0; transform: translateX(-70px) rotate(-22deg) scaleX(0.8); }
            28% { opacity: 1; }
            100% { opacity: 0; transform: translateX(128px) rotate(-6deg) scaleX(1.08); }
        }

        @keyframes ring-pop {
            0% { opacity: 0.9; transform: translate(-50%, -50%) scale(0.35); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.25); }
        }

        @keyframes streak-fade {
            0% { opacity: 0.85; transform: translate(-30%, -50%) scaleX(0.65); }
            100% { opacity: 0; transform: translate(40%, -50%) scaleX(1.08); }
        }

        @keyframes enemy-bloom {
            0% { opacity: 0.75; transform: translate(-50%, -50%) scale(0.22); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.12); }
        }

        @keyframes arena-shake-light {
            0% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-2px, 1px, 0); }
            50% { transform: translate3d(2px, -1px, 0); }
            75% { transform: translate3d(-1px, -1px, 0); }
            100% { transform: translate3d(0, 0, 0); }
        }

        @keyframes arena-shake-heavy {
            0% { transform: translate3d(0, 0, 0); }
            18% { transform: translate3d(-4px, 2px, 0); }
            36% { transform: translate3d(5px, -2px, 0); }
            54% { transform: translate3d(-3px, -2px, 0); }
            72% { transform: translate3d(4px, 2px, 0); }
            100% { transform: translate3d(0, 0, 0); }
        }

        @keyframes aura-pulse {
            0% { opacity: 0.9; transform: translate(-50%, -50%) scale(0.28); }
            35% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.22); }
        }

        @keyframes glyph-spin {
            0% { opacity: 0.95; transform: translate(-50%, -50%) rotate(0deg) scale(0.62); }
            100% { opacity: 0; transform: translate(-50%, -50%) rotate(220deg) scale(1.15); }
        }

        @keyframes teleport-blink {
            0% { opacity: 0.92; transform: translate(-50%, -50%) scale(0.16); }
            45% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.16); }
        }

        @keyframes teleport-rift {
            0% { opacity: 0.95; transform: translate(-50%, -50%) scaleY(0.18) scaleX(0.7); }
            100% { opacity: 0; transform: translate(-50%, -50%) scaleY(1.28) scaleX(1.08); }
        }

        @keyframes impact-burst {
            0% { opacity: 0.96; transform: translate(-50%, -50%) scale(0.18) rotate(-12deg); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.18) rotate(18deg); }
        }

        @keyframes impact-ring {
            0% { opacity: 0.92; transform: translate(-50%, -50%) scale(0.22); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.42); }
        }

        @keyframes hero-teleport-strike {
            0% { transform: translateX(0) scale(1); opacity: 1; }
            14% { transform: translateX(10px) scale(1.03); opacity: 0.9; }
            28% { transform: translate(calc(var(--tp-dx) * 0.35), calc(var(--tp-dy) * 0.35)) scale(1.04); opacity: 0.32; }
            46% { transform: translate(var(--tp-dx), var(--tp-dy)) scale(var(--tp-scale)); opacity: 0.08; }
            58% { transform: translate(var(--tp-dx), var(--tp-dy)) scale(calc(var(--tp-scale) * 0.98)); opacity: 1; }
            78% { transform: translate(calc(var(--tp-dx) * 0.28), calc(var(--tp-dy) * 0.2)) scale(1.03); opacity: 0.78; }
            100% { transform: translateX(0) scale(1); opacity: 1; }
        }

        @keyframes enemy-idle-hover {
            0% { transform: scale(1.5) translateY(0); }
            38% { transform: scale(1.515) translateY(-4px); }
            72% { transform: scale(1.49) translateY(-1px); }
            100% { transform: scale(1.5) translateY(0); }
        }

        @keyframes enemy-flicker {
            0% { opacity: 1; filter: brightness(1); }
            30% { opacity: 0.55; filter: brightness(1.45) drop-shadow(0 0 12px rgba(255, 228, 160, 0.55)); }
            62% { opacity: 1; filter: brightness(1.1) drop-shadow(0 0 10px rgba(112, 242, 255, 0.36)); }
            100% { opacity: 1; filter: brightness(1); }
        }

        @keyframes enemy-phase-blink {
            0% { opacity: 1; transform: scale(1.5); }
            18% { opacity: 0.26; transform: scale(1.54); }
            34% { opacity: 0.88; transform: scale(1.49); }
            56% { opacity: 0.34; transform: scale(1.56); }
            100% { opacity: 1; transform: scale(1.5); }
        }

        @keyframes hero-sheath {
            0% { transform: translateX(0) scaleX(1); }
            45% { transform: translateX(26px) scaleX(1); }
            100% { transform: translateX(0) scaleX(1); }
        }

        @keyframes hero-breathe {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-3px) scale(1.015); }
            100% { transform: translateY(0) scale(1); }
        }

        @keyframes enemy-vanish {
            0% { opacity: 1; filter: brightness(1) drop-shadow(0 0 0 rgba(255,255,255,0)); transform: scale(1.5); }
            18% { opacity: 0.26; filter: brightness(1.85) drop-shadow(0 0 18px rgba(255,200,200,0.8)); transform: scale(1.56); }
            30% { opacity: 1; filter: brightness(1.1); transform: scale(1.52); }
            52% { opacity: 0.22; filter: brightness(1.95) drop-shadow(0 0 22px rgba(255,180,180,0.9)); transform: scale(1.58); }
            68% { opacity: 0.78; transform: scale(1.5); }
            100% { opacity: 0; filter: brightness(2.2) drop-shadow(0 0 30px rgba(255,220,220,1)); transform: scale(1.66); }
        }

        @keyframes pulse-good {
            0% { box-shadow: 0 0 0 rgba(117, 237, 194, 0); }
            45% { box-shadow: 0 0 0 3px rgba(117, 237, 194, 0.36); }
            100% { box-shadow: 0 0 0 rgba(117, 237, 194, 0); }
        }

        @keyframes qte-danger-pulse {
            0% { box-shadow: 0 12px 28px rgba(0, 0, 0, 0.46), 0 0 14px rgba(255, 84, 84, 0.26); }
            50% { box-shadow: 0 12px 28px rgba(0, 0, 0, 0.46), 0 0 28px rgba(255, 84, 84, 0.62); }
            100% { box-shadow: 0 12px 28px rgba(0, 0, 0, 0.46), 0 0 14px rgba(255, 84, 84, 0.26); }
        }

        @keyframes hero-charged-breathe {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-2px) scale(1.02); }
            100% { transform: translateY(0) scale(1); }
        }

        @keyframes arena-flash-good {
            0% { box-shadow: inset 0 0 0 rgba(0, 0, 0, 0); }
            40% { box-shadow: inset 0 0 120px rgba(111, 255, 206, 0.14); }
            100% { box-shadow: inset 0 0 0 rgba(0, 0, 0, 0); }
        }

        @keyframes arena-flash-bad {
            0% { box-shadow: inset 0 0 0 rgba(0, 0, 0, 0); }
            35% { box-shadow: inset 0 0 120px rgba(255, 112, 112, 0.16); }
            100% { box-shadow: inset 0 0 0 rgba(0, 0, 0, 0); }
        }

        @keyframes hud-score-flash {
            0% { box-shadow: 0 0 0 rgba(0, 0, 0, 0.44); }
            40% { box-shadow: 0 0 28px rgba(255, 206, 118, 0.32); }
            100% { box-shadow: 0 14px 36px rgba(0, 0, 0, 0.44); }
        }

        @media (max-width: 1080px) {
            #top-hud {
                grid-template-columns: 1fr;
                height: auto;
                min-height: 114px;
                top: 8px;
                left: 8px;
                right: 8px;
                padding: 8px;
            }

            #metric-card {
                min-height: 92px;
            }

            #arena {
                top: 206px;
                bottom: clamp(206px, 30vh, 330px);
                left: 8px;
                right: 8px;
            }

            #bottom-hud {
                grid-template-columns: 1fr;
                bottom: 8px;
                left: 8px;
                right: 8px;
                padding: 8px;
                min-height: 154px;
            }

            #hero-wrap,
            #enemy-wrap {
                width: 170px;
                height: 170px;
                bottom: 68px;
            }

            #hero-sprite {
                width: 146px;
                height: 146px;
            }

            #enemy-sprite {
                width: 219px;
                height: 219px;
            }

            #btn-pause {
                min-width: 84px;
                font-size: 12px;
                padding: 6px 8px;
                justify-self: end;
                align-self: start;
            }

            #hit-line {
                bottom: 66px;
            }

            #coach-strip {
                left: 12px;
                bottom: 124px;
                min-width: min(360px, 78vw);
            }

            .guide-chip {
                font-size: 11px;
                padding: 3px 7px;
            }

            #boss-qte-panel {
                top: 132px;
                min-width: min(320px, 92vw);
            }

            #counter-window-panel {
                top: 220px;
                min-width: min(300px, 92vw);
            }

            #boss-qte-key {
                min-width: 52px;
                height: 52px;
                font-size: 33px;
            }

            #victory-skip-tip {
                bottom: 220px;
                font-size: 12px;
            }

            #stage-select-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            #stage-select-card {
                padding: 14px;
            }

            #result-metrics {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="bg-layer"></div>
        <div id="bg-vignette"></div>
        <div id="bg-aurora"></div>

        <div id="top-hud" class="glass">
            <div id="hero-card">
                <img class="portrait" src="assets/ui/portrait.png" alt="主角頭像">
                <div>
                    <div class="title">嘉北劍派入門弟子</div>
                    <div class="subtitle" id="stage-name">等待試煉啟動</div>
                    <div id="companion-row">
                        <img src="assets/pets/qinglong_icon.png" alt="青龍">
                        <img src="assets/pets/kunpeng_icon.png" alt="鯤鵬">
                        <img src="assets/pets/zhuque_icon.png" alt="朱雀">
                        <img src="assets/pets/pet_nether_whelp_icon.png" alt="幽焰幼龍">
                    </div>
                </div>
            </div>

            <div id="bar-stack">
                <div class="bar-item">
                    <img src="assets/ui/icon_hp_pixel.png" alt="HP">
                    <div class="bar-shell"><div id="hp-fill" class="bar-fill"></div></div>
                    <div id="hp-text">140/140</div>
                </div>
                <div class="bar-item">
                    <img src="assets/ui/icon_sword_pixel.png" alt="敵人">
                    <div class="bar-shell"><div id="enemy-fill" class="bar-fill"></div></div>
                    <div id="enemy-text">--</div>
                </div>
                <div class="bar-item">
                    <img src="assets/ui/icon_mp_pixel.png" alt="真氣">
                    <div class="bar-shell"><div id="qi-fill" class="bar-fill"></div></div>
                    <div id="qi-text">0/100</div>
                </div>
                <div class="bar-item">
                    <img src="assets/ui/icon_scroll_pixel.png" alt="進度">
                    <div class="bar-shell"><div id="timer-fill" class="bar-fill"></div></div>
                    <div id="timer-text">0%</div>
                </div>
            </div>

            <div id="metric-card">
                <div class="metrics-row">
                    <div class="metric-cell">正確率<br><span class="metric-val" id="metric-acc">100%</span></div>
                    <div class="metric-cell">最高連擊<br><span class="metric-val" id="metric-max-combo">0</span></div>
                </div>
                <div class="metrics-row">
                    <div class="metric-cell"><span id="metric-score-label">分數</span><br><span class="metric-val" id="metric-defeated">0</span></div>
                    <div class="metric-cell">總鍵數<br><span class="metric-val" id="metric-typed">0</span></div>
                </div>
            </div>
            <button id="btn-pause" class="wood-btn">暫停 Esc</button>
        </div>

        <div id="arena" data-stage="1">
            <div id="arena-light"></div>
            <div id="arena-ambient"></div>
            <div id="feedback-flash"></div>
            <div id="monster-rail"></div>
            <div id="boss-distance-wrap">
                <div style="font-size:12px; color:#ffe2a9;">魔王逼近距離</div>
                <div id="boss-distance-shell"><div id="boss-distance-fill"></div></div>
            </div>

            <div id="hero-wrap">
                <img id="hero-sprite" src="assets/character/stand-1.png" alt="主角">
            </div>

            <div id="enemy-wrap">
                <img id="enemy-sprite" src="assets/monsters/forest_spirit.gif" alt="敵人">
            </div>

            <div id="prompt-board" class="glass">
                <div id="prompt-stage"></div>
                <div id="prompt-main"></div>
                <div id="prompt-sub"></div>
                <div id="word-progress"></div>
            </div>
            <div id="coach-strip">準備中</div>

            <div id="ime-panel" class="glass">
                <div id="ime-title">中打模式（注音選字）</div>
                <div id="ime-hint">請用注音輸入法輸入，選字後會自動判定。</div>
                <input id="ime-input" type="text" inputmode="text" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="用注音輸入並選字">
            </div>

            <div id="stage2-qte-panel" class="glass" aria-live="polite">
                <div class="qte-title" id="stage2-qte-label">踏雲限時</div>
                <div class="qte-keyline">
                    <span>目標</span>
                    <span id="stage2-qte-key">Q</span>
                    <span id="stage2-qte-countdown">2.0s</span>
                </div>
                <div class="qte-bar-shell"><div id="stage2-qte-fill"></div></div>
            </div>

            <div id="boss-qte-panel" class="glass" aria-live="polite">
                <div class="qte-title">魔王快攻 QTE</div>
                <div class="qte-keyline">
                    <span>立即按</span>
                    <span id="boss-qte-key">F</span>
                    <span>防禦</span>
                </div>
                <div id="boss-qte-countdown">2.0s</div>
                <div class="qte-bar-shell"><div id="boss-qte-fill"></div></div>
            </div>

            <div id="counter-window-panel" class="glass" aria-live="polite">
                <div class="qte-title">反擊窗口</div>
                <div id="counter-window-time">1.20s</div>
                <div class="qte-bar-shell"><div id="counter-window-fill"></div></div>
            </div>

            <div id="projectile-layer"></div>
            <div id="effect-layer"></div>
            <div id="combo-float"></div>
            <img id="stage-clear-fx" src="assets/effects/effect_levelup_animation.gif" alt="升級特效">
            <div id="hit-line"></div>
        </div>

        <div id="bottom-hud" class="glass">
            <div id="objective-panel">
                <div class="panel-title"><img src="assets/ui/icon_scroll_pixel.png" alt="任務">當前任務</div>
                <div id="objective-main">等待試煉開始。</div>
                <div id="objective-guide"></div>
                <div id="objective-progress"></div>
                <div id="stage-track"></div>
            </div>

            <div id="help-panel">
                <div class="panel-title"><img src="assets/ui/icon_settings_pixel.png" alt="提示">戰鬥口訣</div>
                <div id="help-text">
                    <img src="assets/ui/icon_scroll_pixel.png" alt="看字" style="width:14px;height:14px;vertical-align:-2px;"> 看畫面字，先慢後快。<br>
                    <img src="assets/ui/icon_mp_pixel.png" alt="蓄能" style="width:14px;height:14px;vertical-align:-2px;"> 前三關先蓄能，再出招。<br>
                    <img src="assets/ui/icon_sword_pixel.png" alt="斬咒" style="width:14px;height:14px;vertical-align:-2px;"> 第四、五關完整打完單字／字詞才有傷害。<br>
                    <img src="assets/ui/icon_def_pixel.png" alt="防禦" style="width:14px;height:14px;vertical-align:-2px;"> 看到 <b>DEFEND</b> 先按 F/J。<br>
                    <img src="assets/ui/icon_atk_pixel.png" alt="大絕" style="width:14px;height:14px;vertical-align:-2px;"> 真氣滿 100 再按 <b>Space</b> 放大絕。
                </div>
                <div id="learning-panel">
                    <div id="learning-title">本回戰況</div>
                    <div class="learning-row" id="learning-live">戰況：--</div>
                    <div class="learning-row" id="learning-tip">下一步：先看字再按鍵。</div>
                </div>
            </div>
        </div>

        <div id="dialogue-panel" class="glass">
            <div id="dialogue-speaker"></div>
            <div id="dialogue-text"></div>
            <div id="dialogue-tip">
                <span>按 Space / Enter 可快速推進對話。</span>
                <button id="dialogue-next" class="wood-btn">下一句</button>
            </div>
        </div>
        <div id="victory-skip-tip">過場中，按 Enter 可略過</div>

        <div id="loading-screen" class="screen show">
            <div id="loading-card" class="screen-card">
                <div id="loading-title">載入中・佈陣啟動</div>
                <div id="loading-sub">
                    正在準備場景美術、怪物、角色動作與音效資源。<br>
                    請稍候，讓遊戲先把資料載入完成。
                </div>
                <div id="loading-bar-shell"><div id="loading-bar-fill"></div></div>
                <div id="loading-meta">
                    <div id="loading-count">0 / 0</div>
                    <div id="loading-percent">0%</div>
                </div>
                <div id="loading-hint">正在初始化...</div>
            </div>
        </div>

        <div id="title-screen" class="screen">
            <div class="screen-card">
                <img class="logo" src="assets/game_logo_title.png" alt="Logo">
                <div id="title-name">打字修仙傳：五鍵飛升</div>
                <div id="title-sub">
                    目標：修成「盲打神功」，擊敗只會「一指禪」的魔教教主。<br>
                    五大試煉皆為獨立挑戰，三分鐘內拚出最高分與星等。
                </div>
                <div id="title-controls">
                    <button id="btn-start" class="wood-btn">開始遊戲</button>
                    <button id="btn-stage5" class="wood-btn">魔王模式</button>
                </div>
                <div id="title-settings-toggle">
                    <button id="btn-title-settings" class="wood-btn">遊戲設定</button>
                </div>
                <div id="title-more">
                    <div id="title-options">
                        <button id="btn-assist" class="wood-btn">輔助模式：關</button>
                        <button id="btn-contrast" class="wood-btn">高對比：關</button>
                        <button id="btn-motion" class="wood-btn">低動態：關</button>
                    </div>
                    <div id="cloud-settings">
                        <div id="cloud-settings-title">排行榜同步（Google Sheet）</div>
                        <div class="cloud-setting-row">
                            <label for="cloud-player-name">暱稱</label>
                            <input id="cloud-player-name" type="text" maxlength="20" placeholder="例如：嘉北小劍客">
                        </div>
                        <div class="cloud-setting-row">
                            <label for="cloud-sheet-url">Sheet URL</label>
                            <input id="cloud-sheet-url" type="url" placeholder="Google Apps Script Web App URL">
                        </div>
                        <div id="cloud-settings-actions">
                            <button id="btn-cloud-save" class="wood-btn">儲存設定</button>
                            <button id="btn-cloud-refresh" class="wood-btn">更新排行榜</button>
                        </div>
                        <div id="cloud-settings-status">尚未連線。</div>
                    </div>
                </div>
                <div id="control-hints">
                    先選關，再挑戰。每關都是獨立 3:00 計分模式，可重複挑戰刷星等。<br>
                    選關頁可切換英打 / 國字中打 / 純注音；五關都能用同一模式挑戰。魔王模式為無盡連戰（無時間限制）。門規：眼看前方敵人，不看鍵盤。
                </div>
                <div id="title-leaderboard">
                    <div id="title-leaderboard-head">
                        <div id="title-leaderboard-title">雲端排行榜（各關最高分）</div>
                        <div id="title-leaderboard-status">尚未載入</div>
                    </div>
                    <div id="title-leaderboard-grid"></div>
                </div>
            </div>
        </div>

        <div id="stage-select-screen" class="screen">
            <div id="stage-select-card" class="screen-card">
                <div id="stage-select-title">五關地圖・自由選關</div>
                <div id="stage-select-sub">每關 3:00，時間到自動結算分數與星等。</div>
                <div id="stage-select-modebar" class="glass">
                    <div class="mode-label">輸入模式（五關共用）</div>
                    <div class="mode-buttons">
                        <button id="btn-mode-en" class="wood-btn">英打</button>
                        <button id="btn-mode-zh-hanzi" class="wood-btn">國字中打</button>
                        <button id="btn-mode-zh-bpmf" class="wood-btn">純注音</button>
                    </div>
                </div>
                <div id="stage-select-summary">讀取中...</div>
                <div id="stage-select-grid"></div>
                <div id="stage-select-actions">
                    <button id="btn-select-back" class="wood-btn">回標題</button>
                </div>
            </div>
        </div>

        <div id="result-screen" class="screen">
            <div id="result-card" class="screen-card">
                <div id="result-title">「打字武林盟主」證書</div>
                <div id="result-sub">主線任務完成，宿主已達「無敵境界」。</div>
                <div id="result-stage-line">關卡：--</div>
                <div id="result-stars"></div>
                <div id="result-score-line">分數：0</div>
                <div id="result-metrics">
                    <div class="metric-cell">正確率<br><span class="metric-val" id="result-acc">100%</span></div>
                    <div class="metric-cell">最高連擊<br><span class="metric-val" id="result-max-combo">0</span></div>
                    <div class="metric-cell">評分總分<br><span class="metric-val" id="result-score">0</span></div>
                    <div class="metric-cell">總輸入鍵數<br><span class="metric-val" id="result-typed">0</span></div>
                </div>
                <div id="certificate"></div>
                <div id="learning-report">
                    <div class="result-section-title">戰鬥回顧</div>
                    <div id="learning-report-text">等待本次修煉資料...</div>
                </div>
                <div id="achievement-panel">
                    <div class="result-section-title">本次成就</div>
                    <div id="achievement-list"></div>
                </div>
                <div id="growth-panel">
                    <div class="result-section-title">修行紀錄</div>
                    <div id="growth-panel-text">尚無歷史資料。</div>
                </div>
                <div id="cloud-upload-panel">
                    <div id="cloud-upload-head">
                        <div id="cloud-upload-title">雲端成績上傳（Google Sheet）</div>
                        <div id="cloud-upload-actions">
                            <button id="btn-upload-score" class="wood-btn">上傳本次成績</button>
                            <button id="btn-cloud-refresh-result" class="wood-btn">更新排行榜</button>
                        </div>
                    </div>
                    <div id="cloud-upload-status">僅支援上傳五關 3:00 結算成績。</div>
                    <div id="cloud-upload-rankboard">本關排行榜尚未載入。</div>
                </div>
                <div id="result-actions">
                    <button id="btn-replay" class="wood-btn">再挑戰本關</button>
                    <button id="btn-practice" class="wood-btn">補強修練</button>
                    <button id="btn-restart" class="wood-btn">回到選關</button>
                </div>
            </div>
        </div>

        <div id="pause-screen" class="screen">
            <div class="screen-card glass">
                <div style="font-family:'WuxiaTitle','Noto Serif TC',serif; font-size:40px; color:#ffe3a8;">已暫停</div>
                <div style="font-size:16px; color:rgba(236,244,255,0.9); margin:8px 0 16px;">按 Esc 或點「繼續」回到戰鬥。</div>
                <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
                    <button id="btn-resume" class="wood-btn">繼續戰鬥</button>
                    <button id="btn-pause-to-title" class="wood-btn">回到選關</button>
                </div>
            </div>
        </div>

        <div id="fail-screen" class="screen">
            <div class="screen-card glass">
                <div style="font-family:'WuxiaTitle','Noto Serif TC',serif; font-size:42px; color:#ffd5d5;">修煉中斷</div>
                <div id="fail-reason">氣血耗盡</div>
                <div style="color:rgba(244,236,218,0.86); font-size:14px; line-height:1.6;">
                    師傅：站穩呼吸，再來一次。真正的盲打神功，靠的是穩定節奏。
                </div>
                <div style="display:flex; justify-content:center; gap:10px; margin-top:14px; flex-wrap:wrap;">
                    <button id="btn-retry-stage" class="wood-btn">重試本關</button>
                    <button id="btn-fail-restart" class="wood-btn">回到選關</button>
                </div>
            </div>
        </div>

        <div id="toast"></div>
    </div>

    <script>
        const $ = (selector) => document.querySelector(selector);
        const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
        const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

        const el = {
            app: $("#app"),
            loadingScreen: $("#loading-screen"),
            loadingBarFill: $("#loading-bar-fill"),
            loadingCount: $("#loading-count"),
            loadingPercent: $("#loading-percent"),
            loadingHint: $("#loading-hint"),
            topHud: $("#top-hud"),
            bgLayer: $("#bg-layer"),
            bgAurora: $("#bg-aurora"),
            stageName: $("#stage-name"),
            hpFill: $("#hp-fill"),
            hpText: $("#hp-text"),
            enemyFill: $("#enemy-fill"),
            enemyText: $("#enemy-text"),
            qiFill: $("#qi-fill"),
            qiText: $("#qi-text"),
            timerFill: $("#timer-fill"),
            timerText: $("#timer-text"),
            metricAcc: $("#metric-acc"),
            metricMaxCombo: $("#metric-max-combo"),
            metricScoreLabel: $("#metric-score-label"),
            metricDefeated: $("#metric-defeated"),
            metricTyped: $("#metric-typed"),
            arena: $("#arena"),
            arenaLight: $("#arena-light"),
            arenaAmbient: $("#arena-ambient"),
            feedbackFlash: $("#feedback-flash"),
            heroWrap: $("#hero-wrap"),
            enemyWrap: $("#enemy-wrap"),
            heroSprite: $("#hero-sprite"),
            enemySprite: $("#enemy-sprite"),
            projectileLayer: $("#projectile-layer"),
            effectLayer: $("#effect-layer"),
            promptBoard: $("#prompt-board"),
            promptStage: $("#prompt-stage"),
            promptMain: $("#prompt-main"),
            promptSub: $("#prompt-sub"),
            wordProgress: $("#word-progress"),
            coachStrip: $("#coach-strip"),
            imePanel: $("#ime-panel"),
            imeTitle: $("#ime-title"),
            imeHint: $("#ime-hint"),
            imeInput: $("#ime-input"),
            stage2QtePanel: $("#stage2-qte-panel"),
            stage2QteLabel: $("#stage2-qte-label"),
            stage2QteKey: $("#stage2-qte-key"),
            stage2QteCountdown: $("#stage2-qte-countdown"),
            stage2QteFill: $("#stage2-qte-fill"),
            bossQtePanel: $("#boss-qte-panel"),
            bossQteKey: $("#boss-qte-key"),
            bossQteCountdown: $("#boss-qte-countdown"),
            bossQteFill: $("#boss-qte-fill"),
            counterWindowPanel: $("#counter-window-panel"),
            counterWindowTime: $("#counter-window-time"),
            counterWindowFill: $("#counter-window-fill"),
            comboFloat: $("#combo-float"),
            stageClearFx: $("#stage-clear-fx"),
            hitLine: $("#hit-line"),
            objectiveMain: $("#objective-main"),
            objectiveGuide: $("#objective-guide"),
            objectiveProgress: $("#objective-progress"),
            stageTrack: $("#stage-track"),
            monsterRail: $("#monster-rail"),
            bossDistanceWrap: $("#boss-distance-wrap"),
            bossDistanceFill: $("#boss-distance-fill"),
            dialoguePanel: $("#dialogue-panel"),
            dialogueSpeaker: $("#dialogue-speaker"),
            dialogueText: $("#dialogue-text"),
            dialogueNext: $("#dialogue-next"),
            victorySkipTip: $("#victory-skip-tip"),
            titleScreen: $("#title-screen"),
            btnStart: $("#btn-start"),
            btnStage5: $("#btn-stage5"),
            btnZhMode: $("#btn-zh-mode"),
            btnZhBpmfMode: $("#btn-zh-bpmf-mode"),
            btnTitleSettings: $("#btn-title-settings"),
            titleMore: $("#title-more"),
            cloudPlayerName: $("#cloud-player-name"),
            cloudSheetUrl: $("#cloud-sheet-url"),
            btnCloudSave: $("#btn-cloud-save"),
            btnCloudRefresh: $("#btn-cloud-refresh"),
            cloudSettingsStatus: $("#cloud-settings-status"),
            titleLeaderboardStatus: $("#title-leaderboard-status"),
            titleLeaderboardGrid: $("#title-leaderboard-grid"),
            stageSelectScreen: $("#stage-select-screen"),
            stageSelectModeBar: $("#stage-select-modebar"),
            btnModeEn: $("#btn-mode-en"),
            btnModeZhHanzi: $("#btn-mode-zh-hanzi"),
            btnModeZhBpmf: $("#btn-mode-zh-bpmf"),
            stageSelectSummary: $("#stage-select-summary"),
            stageSelectGrid: $("#stage-select-grid"),
            btnSelectBack: $("#btn-select-back"),
            btnAssist: $("#btn-assist"),
            btnContrast: $("#btn-contrast"),
            btnMotion: $("#btn-motion"),
            btnPause: $("#btn-pause"),
            pauseScreen: $("#pause-screen"),
            btnResume: $("#btn-resume"),
            btnPauseToTitle: $("#btn-pause-to-title"),
            resultScreen: $("#result-screen"),
            resultTitle: $("#result-title"),
            resultSub: $("#result-sub"),
            resultStageLine: $("#result-stage-line"),
            resultStars: $("#result-stars"),
            resultScoreLine: $("#result-score-line"),
            resultScore: $("#result-score"),
            resultAcc: $("#result-acc"),
            resultMaxCombo: $("#result-max-combo"),
            resultTyped: $("#result-typed"),
            certificate: $("#certificate"),
            btnUploadScore: $("#btn-upload-score"),
            btnCloudRefreshResult: $("#btn-cloud-refresh-result"),
            cloudUploadStatus: $("#cloud-upload-status"),
            cloudUploadRankboard: $("#cloud-upload-rankboard"),
            btnReplay: $("#btn-replay"),
            btnPractice: $("#btn-practice"),
            btnRestart: $("#btn-restart"),
            learningReportText: $("#learning-report-text"),
            achievementList: $("#achievement-list"),
            growthPanelText: $("#growth-panel-text"),
            failScreen: $("#fail-screen"),
            failReason: $("#fail-reason"),
            btnRetryStage: $("#btn-retry-stage"),
            btnFailRestart: $("#btn-fail-restart"),
            learningLive: $("#learning-live"),
            learningTip: $("#learning-tip"),
            toast: $("#toast")
        };

        const SCENES = {
            title: "assets/title_background_inkwash.jpg",
            forest: "assets/backgrounds/battle_forest_pixel.jpg",
            frozen: "assets/backgrounds/battle_frozen_peak_pixel.jpg",
            cave: "assets/backgrounds/battle_cave_pixel.jpg",
            crypt: "assets/backgrounds/battle_crypt_pixel.jpg",
            ruins: "assets/backgrounds/battle_ruins_pixel.jpg",
            volcano: "assets/backgrounds/battle_volcano_pixel.jpg"
        };

        const SCENE_TONES = {
            title: { sat: 1.05, bright: 0.9, aura: 0.82 },
            forest: { sat: 1.1, bright: 0.95, aura: 1 },
            frozen: { sat: 1.12, bright: 1, aura: 0.95 },
            cave: { sat: 0.95, bright: 0.86, aura: 0.82 },
            crypt: { sat: 0.95, bright: 0.85, aura: 0.8 },
            ruins: { sat: 1.12, bright: 0.94, aura: 0.9 },
            volcano: { sat: 1.2, bright: 0.98, aura: 1.06 }
        };

        const MONSTERS = {
            ruins_guardian_boss: { name: "遺跡守衛王", src: "assets/monsters/ruins_guardian_boss.gif" },
            boar_angry: { name: "暴怒野豬", src: "assets/monsters/boar_angry.gif" },
            ice_spirit_elite: { name: "寒靈菁英", src: "assets/monsters/ice_spirit_elite.gif" },
            mountain_bandit: { name: "山賊", src: "assets/monsters/mountain_bandit.gif" },
            corrupted_treant: { name: "腐化樹靈", src: "assets/monsters/corrupted_treant.gif" },
            mountain_bandit_elite: { name: "山賊頭目", src: "assets/monsters/mountain_bandit_elite.gif" },
            stone_golem_elite: { name: "岩傀菁英", src: "assets/monsters/stone_golem_elite.gif" },
            wolf_cub_elite: { name: "狼崽菁英", src: "assets/monsters/wolf_cub_elite.gif" },
            undead_warrior: { name: "不死武者", src: "assets/monsters/undead_warrior.gif" },
            boar_angry_elite: { name: "暴怒野豬王", src: "assets/monsters/boar_angry_elite.gif" },
            crazed_scholar_elite: { name: "狂書生菁英", src: "assets/monsters/crazed_scholar_elite.gif" },
            forest_spirit: { name: "森林精魄", src: "assets/monsters/forest_spirit.gif" },
            stone_golem: { name: "岩傀", src: "assets/monsters/stone_golem.gif" },
            snakelet_bamboo: { name: "竹葉蛇崽", src: "assets/monsters/snakelet_bamboo.gif" },
            corrupted_treant_elite: { name: "腐化古樹", src: "assets/monsters/corrupted_treant_elite.gif" },
            nether_lord_boss: { name: "一指禪魔王", src: "assets/monsters/nether_lord_boss.gif" },
            crazed_scholar: { name: "狂書生", src: "assets/monsters/crazed_scholar.gif" },
            shadow_imp: { name: "影魅", src: "assets/monsters/shadow_imp.gif" },
            forest_spirit_elite: { name: "林地守靈", src: "assets/monsters/forest_spirit_elite.gif" },
            forest_guardian_boss: { name: "森界守護王", src: "assets/monsters/forest_guardian_boss.gif" },
            flying_eye_elite: { name: "邪瞳菁英", src: "assets/monsters/flying_eye_elite.gif" },
            frost_wyrm_boss: { name: "霜龍王", src: "assets/monsters/frost_wyrm_boss.gif" },
            flying_eye: { name: "飛眼", src: "assets/monsters/flying_eye.gif" },
            lich_apprentice_elite: { name: "巫妖學徒菁英", src: "assets/monsters/lich_apprentice_elite.gif" },
            cave_troll_boss: { name: "洞窟巨魔", src: "assets/monsters/cave_troll_boss.gif" },
            wolf_cub: { name: "狼崽", src: "assets/monsters/wolf_cub.gif" },
            yeti: { name: "雪怪", src: "assets/monsters/yeti.gif" },
            placeholder_monster: { name: "試煉幻影", src: "assets/monsters/placeholder_monster.gif" },
            lava_elemental_boss: { name: "熔炎元素王", src: "assets/monsters/lava_elemental_boss.gif" },
            lich_apprentice: { name: "巫妖學徒", src: "assets/monsters/lich_apprentice.gif" },
            shadow_imp_elite: { name: "影魅菁英", src: "assets/monsters/shadow_imp_elite.gif" },
            ice_spirit: { name: "寒靈", src: "assets/monsters/ice_spirit.gif" }
        };

        const HERO_FRAMES = {
            stand: [1, 2, 3, 4].map((i) => `assets/character/stand-${i}.png`),
            run: [1, 2, 3, 4].map((i) => `assets/character/run-${i}.png`),
            jump: [1, 2, 3, 4].map((i) => `assets/character/jump-${i}.png`),
            attack: [1, 2, 3, 4].map((i) => `assets/character/attack-${i}.png`),
            defense: [1, 2, 3, 4].map((i) => `assets/character/defense-${i}.png`),
            Injuried: [1, 2, 3, 4].map((i) => `assets/character/Injuried-${i}.png`)
        };

        const HERO_FRAME_INTERVAL = {
            stand: 230,
            run: 72,
            jump: 82,
            attack: 78,
            defense: 84,
            Injuried: 95
        };

        const STAGE_TRACK = [
            { name: "紮馬步", thumb: "assets/ui/location_thumb_forest.png" },
            { name: "梯雲縱", thumb: "assets/ui/location_thumb_frozen_peak.png" },
            { name: "掃堂腿", thumb: "assets/ui/location_thumb_crypt.png" },
            { name: "劍氣縱橫", thumb: "assets/ui/location_thumb_ruins.png" },
            { name: "決戰魔教", thumb: "assets/ui/location_thumb_volcano.png" }
        ];

        const STAGE_VISUALS = {
            1: { glow: "rgba(147, 243, 195, 0.34)", spark: "rgba(172, 248, 214, 0.9)", shadow: "rgba(65, 158, 116, 0.55)", heat: "rgba(255, 210, 149, 0.14)" },
            2: { glow: "rgba(151, 216, 255, 0.34)", spark: "rgba(187, 232, 255, 0.88)", shadow: "rgba(81, 140, 185, 0.62)", heat: "rgba(192, 237, 255, 0.18)" },
            3: { glow: "rgba(127, 199, 236, 0.28)", spark: "rgba(166, 225, 255, 0.85)", shadow: "rgba(71, 108, 145, 0.58)", heat: "rgba(255, 192, 155, 0.11)" },
            4: { glow: "rgba(255, 216, 152, 0.3)", spark: "rgba(255, 229, 175, 0.89)", shadow: "rgba(166, 113, 64, 0.62)", heat: "rgba(255, 226, 145, 0.17)" },
            5: { glow: "rgba(255, 138, 105, 0.35)", spark: "rgba(255, 184, 156, 0.9)", shadow: "rgba(173, 65, 43, 0.64)", heat: "rgba(255, 126, 90, 0.24)" }
        };

        const STAGE_CHALLENGE_SECONDS = 180;

        const STAGE_SCORE_TIERS = {
            1: [7000, 11000, 15500],
            2: [7600, 12000, 16800],
            3: [8200, 12800, 18000],
            4: [9200, 14000, 19800],
            5: [10800, 16200, 23000]
        };

        const STAGES = [
            {
                id: 1,
                name: "第一關【紮馬步】覺醒！基準鍵的試煉",
                subtitle: "A S D F J K L ; 蓄氣符文斬",
                scene: "forest",
                bgm: "main",
                mechanic: "homefall",
                enemyHp: 18,
                objectiveText: "打中符文集氣，3 格滿了會自動出劍。",
                target: 6,
                enemyPool: [
                    "snakelet_bamboo",
                    "wolf_cub",
                    "boar_angry",
                    "forest_spirit",
                    "shadow_imp",
                    "flying_eye",
                    "wolf_cub_elite",
                    "boar_angry_elite"
                ],
                opening: [
                    { speaker: "【系統提示】", text: "先打符文，再放招。這關只要記住一件事：3 格集滿就會自動斬。" },
                    { speaker: "師傅", text: "看怪不看鍵盤，穩穩按就好。" }
                ],
                clear: [
                    { speaker: "【系統提示】", text: "聚氣斬運轉順利！宿主基準鍵肌肉記憶 +100，境界提升至「築基期」。" }
                ]
            },
            {
                id: 2,
                name: "第二關【梯雲縱】飛躍！上排鍵的輕功",
                subtitle: "Q~P 踏雲蓄能 / FJ 回防雲爆",
                scene: "frozen",
                bgm: "main",
                mechanic: "top_anchor",
                enemyHp: 10,
                objectiveText: "Q~P 先集滿 2 格雲氣，再用 F/J 回防觸發雲爆。",
                target: 5,
                enemyPool: [
                    "mountain_bandit",
                    "mountain_bandit_elite",
                    "flying_eye",
                    "flying_eye_elite",
                    "ice_spirit",
                    "ice_spirit_elite",
                    "yeti"
                ],
                opening: [
                    { speaker: "師傅", text: "先跳斬集雲，再回防引爆。照節奏做就會過。" }
                ],
                clear: [
                    { speaker: "【系統提示】", text: "雲氣轉化完成！解鎖成就「天際漫步」。" }
                ]
            },
            {
                id: 3,
                name: "第三關【掃堂腿】防禦！下盤的暗器伏擊",
                subtitle: "Z~M 護盾蓄能反震",
                scene: "cave",
                bgm: "battle",
                mechanic: "bottom_defense",
                enemyHp: 12,
                objectiveText: "Z~M 格擋暗器，盾氣滿 3 格就會自動反震。",
                target: 4,
                enemyPool: [
                    "stone_golem",
                    "stone_golem_elite",
                    "crazed_scholar",
                    "crazed_scholar_elite",
                    "lich_apprentice",
                    "lich_apprentice_elite",
                    "shadow_imp_elite"
                ],
                opening: [
                    { speaker: "師傅", text: "這關先擋住，再反震。別亂按，穩住就能贏。" }
                ],
                clear: [
                    { speaker: "【系統提示】", text: "反震護盾已成型！宿主已具備下山闖蕩的資格。" }
                ]
            },
            {
                id: 4,
                name: "第四關【劍氣縱橫】連段！單字的行雲流水",
                subtitle: "Easy Words 連段斬咒",
                scene: "ruins",
                bgm: "battle",
                mechanic: "word_combo",
                enemyHp: 8,
                objectiveText: "完整打出英文單字，才能斬斷怪物咒文。",
                target: 8,
                enemyPool: [
                    "corrupted_treant",
                    "corrupted_treant_elite",
                    "undead_warrior",
                    "forest_spirit_elite",
                    "shadow_imp_elite",
                    "cave_troll_boss"
                ],
                opening: [
                    { speaker: "【系統提示】", text: "單字要一次打完才有傷害。" },
                    { speaker: "師傅", text: "看整個字，不要一個字母一個字母慌著按。" }
                ],
                clear: [
                    { speaker: "師傅（欣慰）", text: "徒兒，你已經掌握了連招的精髓，接下來，就看你造化了……" }
                ]
            },
            {
                id: 5,
                name: "第五關【決戰魔教】無敵！盲打神功大成",
                subtitle: "Boss 單字戰 + DEFEND + Space",
                scene: "volcano",
                bgm: "battle",
                mechanic: "boss_raid",
                enemyHp: 360,
                objectiveText: "打完整單字輸出；看到 DEFEND 就按 F/J；真氣滿按 Space。",
                target: 360,
                enemyPool: [
                    "nether_lord_boss",
                    "forest_guardian_boss",
                    "ruins_guardian_boss",
                    "frost_wyrm_boss",
                    "lava_elemental_boss"
                ],
                opening: [
                    { speaker: "一指禪魔王（狂妄）", text: "桀桀桀！就憑你這嘉北劍派的無名小卒也敢挑戰我？看我的絕學『二指戳戳功』，我盯著鍵盤找字的速度天下無敵！" },
                    { speaker: "主角（自信）", text: "看著鍵盤打字？那已經是上個世紀的武功了。今天就讓你見識，不滯於物、心劍合一的『盲打神功』！" },
                    { speaker: "【系統提示】", text: "最終試煉開啟：Boss 會進入三段變化，越後面越快，注意攻守切換！" }
                ],
                clear: [
                    { speaker: "旁白", text: "主角收劍入鞘。" },
                    { speaker: "【系統提示】", text: "主線任務完成。宿主已達到「無敵境界」。" },
                    { speaker: "師傅", text: "今日起，你便是『打字武林盟主』。" }
                ]
            }
        ];

        const EN_BOSS_WORD_BANK = {
            easy: [
                "apple", "banana", "orange", "school", "friend", "family", "garden", "animal",
                "teacher", "student", "pencil", "window", "morning", "weather", "summer", "winter",
                "science", "nature", "planet", "memory", "energy", "travel", "bridge", "village",
                "market", "museum", "forest", "river", "castle", "button", "screen", "shadow",
                "safety", "health", "future", "signal", "rocket", "ticket", "puzzle", "lesson"
            ],
            middle: [
                "adventure", "favorite", "beautiful", "language", "computer", "exercise", "discover", "festival",
                "practice", "history", "message", "project", "subject", "library", "culture", "mountain",
                "question", "answer", "example", "problem", "carefully", "powerful", "perfectly", "remember",
                "backpack", "calendar", "classroom", "teamwork", "creative", "strategy", "sunlight", "midnight",
                "building", "shopping", "internet", "painting", "engineer", "athletic", "wildlife", "treasure"
            ],
            junior: [
                "environment", "technology", "important", "different", "experience", "community", "knowledge", "communication",
                "condition", "relationship", "opportunity", "traditional", "improvement", "education", "direction", "successful",
                "confidence", "challenge", "responsible", "available", "solution", "research", "development", "situation",
                "chemical", "historical", "geography", "equation", "analysis", "grammar", "organism", "reaction",
                "microscope", "electricity", "ecosystem", "literature", "experiment", "population", "percentage", "volunteer"
            ],
            senior: [
                "extraordinary", "interpretation", "characteristic", "concentration", "representation", "investigation",
                "appreciation", "consideration", "achievement", "independent", "collaboration", "fundamental",
                "architecture", "biodiversity", "transformation", "transportation", "civilization", "mathematical",
                "psychological", "international", "controversial", "significance", "philosophical", "underestimate",
                "electromagnetic", "photosynthesis", "constitutional", "interdisciplinary", "sustainability", "entrepreneurship",
                "experimentalist", "microorganism", "thermodynamics", "interpretative", "computational", "manufacturing",
                "biochemical", "probability", "sociological", "neurological"
            ]
        };

        const ZH_TYPING_WORD_BANK = {
            easy: [
                { text: "媽媽", phonetic: "ㄇㄚ ㄇㄚ" },
                { text: "爸爸", phonetic: "ㄅㄚ ㄅㄚ" },
                { text: "老師", phonetic: "ㄌㄠˇ ㄕ" },
                { text: "同學", phonetic: "ㄊㄨㄥˊ ㄒㄩㄝˊ" },
                { text: "學校", phonetic: "ㄒㄩㄝˊ ㄒㄧㄠˋ" },
                { text: "鉛筆", phonetic: "ㄑㄧㄢ ㄅㄧˇ" },
                { text: "橡皮擦", phonetic: "ㄒㄧㄤˋ ㄆㄧˊ ㄘㄚ" },
                { text: "圖書館", phonetic: "ㄊㄨˊ ㄕㄨ ㄍㄨㄢˇ" },
                { text: "運動場", phonetic: "ㄩㄣˋ ㄉㄨㄥˋ ㄔㄤˇ" },
                { text: "下雨天", phonetic: "ㄒㄧㄚˋ ㄩˇ ㄊㄧㄢ" },
                { text: "小火車", phonetic: "ㄒㄧㄠˇ ㄏㄨㄛˇ ㄔㄜ" },
                { text: "好朋友", phonetic: "ㄏㄠˇ ㄆㄥˊ ㄧㄡˇ" },
                { text: "大操場", phonetic: "ㄉㄚˋ ㄘㄠ ㄔㄤˇ" },
                { text: "電風扇", phonetic: "ㄉㄧㄢˋ ㄈㄥ ㄕㄢˋ" },
                { text: "黑板擦", phonetic: "ㄏㄟ ㄅㄢˇ ㄘㄚ" },
                { text: "美術課", phonetic: "ㄇㄟˇ ㄕㄨˋ ㄎㄜˋ" }
            ],
            middle: [
                { text: "認真練習", phonetic: "ㄖㄣˋ ㄓㄣ ㄌㄧㄢˋ ㄒㄧˊ" },
                { text: "保持節奏", phonetic: "ㄅㄠˇ ㄔˊ ㄐㄧㄝˊ ㄗㄡˋ" },
                { text: "專心輸入", phonetic: "ㄓㄨㄢ ㄒㄧㄣ ㄕㄨ ㄖㄨˋ" },
                { text: "穩定命中", phonetic: "ㄨㄣˇ ㄉㄧㄥˋ ㄇㄧㄥˋ ㄓㄨㄥˋ" },
                { text: "劍氣連段", phonetic: "ㄐㄧㄢˋ ㄑㄧˋ ㄌㄧㄢˊ ㄉㄨㄢˋ" },
                { text: "魔王快攻", phonetic: "ㄇㄛˊ ㄨㄤˊ ㄎㄨㄞˋ ㄍㄨㄥ" },
                { text: "防禦成功", phonetic: "ㄈㄤˊ ㄩˋ ㄔㄥˊ ㄍㄨㄥ" },
                { text: "反擊窗口", phonetic: "ㄈㄢˇ ㄐㄧˊ ㄔㄨㄤ ㄎㄡˇ" },
                { text: "獨立挑戰", phonetic: "ㄉㄨˊ ㄌㄧˋ ㄊㄧㄠˇ ㄓㄢˋ" },
                { text: "重複修練", phonetic: "ㄔㄨㄥˊ ㄈㄨˋ ㄒㄧㄡ ㄌㄧㄢˋ" },
                { text: "眼看前方", phonetic: "ㄧㄢˇ ㄎㄢˋ ㄑㄧㄢˊ ㄈㄤ" },
                { text: "不要低頭", phonetic: "ㄅㄨˊ ㄧㄠˋ ㄉㄧ ㄊㄡˊ" },
                { text: "保持專注", phonetic: "ㄅㄠˇ ㄔˊ ㄓㄨㄢ ㄓㄨˋ" },
                { text: "快速反應", phonetic: "ㄎㄨㄞˋ ㄙㄨˋ ㄈㄢˇ ㄧㄥˋ" },
                { text: "穩定輸出", phonetic: "ㄨㄣˇ ㄉㄧㄥˋ ㄕㄨ ㄔㄨ" },
                { text: "戰鬥節奏", phonetic: "ㄓㄢˋ ㄉㄡˋ ㄐㄧㄝˊ ㄗㄡˋ" }
            ],
            hard: [
                { text: "電腦輸入法", phonetic: "ㄉㄧㄢˋ ㄋㄠˇ ㄕㄨ ㄖㄨˋ ㄈㄚˇ" },
                { text: "自然科學教室", phonetic: "ㄗˋ ㄖㄢˊ ㄎㄜ ㄒㄩㄝˊ ㄐㄧㄠˋ ㄕˋ" },
                { text: "地理與歷史文化", phonetic: "ㄉㄧˋ ㄌㄧˇ ㄩˇ ㄌㄧˋ ㄕˇ ㄨㄣˊ ㄏㄨㄚˋ" },
                { text: "環境保護行動", phonetic: "ㄏㄨㄢˊ ㄐㄧㄥˋ ㄅㄠˇ ㄏㄨˋ ㄒㄧㄥˊ ㄉㄨㄥˋ" },
                { text: "資訊科技發展", phonetic: "ㄗ ㄒㄩㄣˋ ㄎㄜ ㄐㄧˋ ㄈㄚ ㄓㄢˇ" },
                { text: "國際交流合作", phonetic: "ㄍㄨㄛˊ ㄐㄧˋ ㄐㄧㄠ ㄌㄧㄡˊ ㄏㄜˊ ㄗㄨㄛˋ" },
                { text: "表達與溝通能力", phonetic: "ㄅㄧㄠˇ ㄉㄚˊ ㄩˇ ㄍㄡ ㄊㄨㄥ ㄋㄥˊ ㄌㄧˋ" },
                { text: "邏輯推理分析", phonetic: "ㄌㄨㄛˊ ㄐㄧˊ ㄊㄨㄟ ㄌㄧˇ ㄈㄣ ㄒㄧ" },
                { text: "自主學習計畫", phonetic: "ㄗˋ ㄓㄨˇ ㄒㄩㄝˊ ㄒㄧˊ ㄐㄧˋ ㄏㄨㄚˋ" },
                { text: "閱讀理解能力", phonetic: "ㄩㄝˋ ㄉㄨˊ ㄌㄧˇ ㄐㄧㄝˇ ㄋㄥˊ ㄌㄧˋ" },
                { text: "數學幾何證明", phonetic: "ㄕㄨˋ ㄒㄩㄝˊ ㄐㄧˇ ㄏㄜˊ ㄓㄥˋ ㄇㄧㄥˊ" },
                { text: "實驗觀察紀錄", phonetic: "ㄕˊ ㄧㄢˋ ㄍㄨㄢ ㄔㄚˊ ㄐㄧˋ ㄌㄨˋ" },
                { text: "自然語言表達", phonetic: "ㄗˋ ㄖㄢˊ ㄩˇ ㄧㄢˊ ㄅㄧㄠˇ ㄉㄚˊ" },
                { text: "程式設計邏輯", phonetic: "ㄔㄥˊ ㄕˋ ㄕㄜˋ ㄐㄧˋ ㄌㄨㄛˊ ㄐㄧˊ" },
                { text: "科學探究精神", phonetic: "ㄎㄜ ㄒㄩㄝˊ ㄊㄢˋ ㄐㄧㄡ ㄐㄧㄥ ㄕㄣˊ" },
                { text: "跨領域整合能力", phonetic: "ㄎㄨㄚˋ ㄌㄧㄥˇ ㄩˋ ㄓㄥˇ ㄏㄜˊ ㄋㄥˊ ㄌㄧˋ" }
            ]
        };

        const BOPOMOFO_KEYMAP = {
            "ㄅ": "1", "ㄆ": "q", "ㄇ": "a", "ㄈ": "z",
            "ㄉ": "2", "ㄊ": "w", "ㄋ": "s", "ㄌ": "x",
            "ㄍ": "e", "ㄎ": "d", "ㄏ": "c",
            "ㄐ": "r", "ㄑ": "f", "ㄒ": "v",
            "ㄓ": "5", "ㄔ": "t", "ㄕ": "g", "ㄖ": "b",
            "ㄗ": "y", "ㄘ": "h", "ㄙ": "n",
            "ㄧ": "u", "ㄨ": "j", "ㄩ": "m",
            "ㄚ": "8", "ㄛ": "i", "ㄜ": "k", "ㄝ": ",",
            "ㄞ": "9", "ㄟ": "o", "ㄠ": "l", "ㄡ": ".",
            "ㄢ": "0", "ㄣ": "p", "ㄤ": ";", "ㄥ": "/", "ㄦ": "-",
            "ˇ": "3", "ˋ": "4", "ˊ": "6", "˙": "7"
        };
        const BOPOMOFO_LABEL_BY_KEY = Object.fromEntries(Object.entries(BOPOMOFO_KEYMAP).map(([symbol, key]) => [key, symbol]));

        function buildBopomofoModeTokens() {
            const all = [
                ...ZH_TYPING_WORD_BANK.easy,
                ...ZH_TYPING_WORD_BANK.middle,
                ...ZH_TYPING_WORD_BANK.hard
            ];
            return all.map((item) => {
                const raw = String(item.phonetic || "").replace(/[\s\u3000]/g, "");
                const keys = Array.from(raw).map((symbol) => BOPOMOFO_KEYMAP[symbol] || "").join("");
                return {
                    text: raw,
                    phonetic: item.text,
                    hanzi: item.text,
                    input: keys
                };
            }).filter((token) => token.text && token.input && token.text.length === token.input.length);
        }

        const audio = {
            unlocked: false,
            bgm: {
                title: new Audio("audio/bgm_title_screen.mp3"),
                main: new Audio("audio/bgm_main_game.mp3"),
                battle: new Audio("audio/bgm_battle.mp3")
            },
            sfx: {
                heal: "audio/sfx_heal_effect.mp3",
                debuff: "audio/sfx_debuff_negative.mp3",
                shield: "audio/sfx_shield_block.mp3",
                skill: "audio/sfx_skill_cast.mp3",
                buy: "audio/sfx_buy_item.mp3",
                crit: "audio/sfx_attack_crit.mp3",
                correct: "audio/sfx_answer_correct.mp3",
                poison: "audio/sfx_poison_tick.mp3",
                fire: "audio/sfx_fire_effect.mp3",
                buff: "audio/sfx_buff_positive.mp3",
                hover: "audio/sfx_button_hover.mp3",
                ice: "audio/sfx_ice_effect.mp3",
                playerAttack: "audio/sfx_player_attack.mp3",
                monsterAttack: "audio/sfx_monster_attack.mp3",
                levelUp: "audio/sfx_level_up.mp3",
                lose: "audio/sfx_battle_lose.mp3",
                wrong: "audio/sfx_answer_wrong.mp3",
                click: "audio/sfx_button_click.mp3"
            },
            currentBgm: null
        };

        Object.values(audio.bgm).forEach((track) => {
            track.loop = true;
            track.volume = 0.42;
            track.preload = "auto";
        });

        const game = {
            mode: "title",
            stageIndex: 0,
            currentStageDef: null,
            playerHp: 140,
            maxPlayerHp: 140,
            enemyHp: 0,
            maxEnemyHp: 0,
            combo: 0,
            maxCombo: 0,
            qi: 0,
            maxQi: 100,
            defeated: 0,
            totalTyped: 0,
            correctTyped: 0,
            sessionStart: 0,
            stageStart: 0,
            stageData: null,
            stageTimerTotal: STAGE_CHALLENGE_SECONDS,
            stageTimerLeft: STAGE_CHALLENGE_SECONDS,
            stageTimerEndAt: 0,
            timedStageFinished: false,
            stageScore: 0,
            stageCycles: 0,
            errorStreak: 0,
            cycleResetLockUntil: 0,
            heroState: "stand",
            heroFrame: 0,
            heroFrameClock: 0,
            heroStateLockUntil: 0,
            lastTick: performance.now(),
            dialogueQueue: [],
            dialogueOnDone: null,
            currentMonster: null,
            toastTimer: null,
            feedbackTimer: null,
            arenaShakeTimer: null,
            hitLineTimer: null,
            coachTimer: null,
            previewTimer: null,
            ambientTimer: 0,
            fxPool: {},
            autoPausedByBlur: false,
            pauseStartedAt: 0,
            victoryCinematic: {
                active: false,
                timers: []
            },
            sessionAttempts: [],
            stageMisses: 0,
            stagePerfect: true,
            practiceMode: false,
            practicePlan: null,
            lastResultInsights: null,
            titleOptionsOpen: false,
            bossChallengeMode: false,
            endlessBossMode: false,
            chineseMode: false,
            inputLocale: "en",
            imeComposing: false,
            imeDraftText: "",
            zhModeVariant: "hanzi",
            independentStageMode: true,
            selectedStageIndex: 0,
            currentWordStart: 0,
            adaptive: {
                level: 1,
                spawnScale: 1,
                bossDrainScale: 1,
                wordDamageScale: 1
            },
            profile: {
                assistMode: true,
                highContrast: false,
                reducedMotion: false,
                playerName: "",
                sheetWebhookUrl: "",
                sessions: 0,
                totalKeys: 0,
                bestAcc: 0,
                bestCombo: 0,
                stageRecords: {},
                specialRecords: {},
                achievements: []
            },
            analytics: {
                keyStats: {},
                wordStats: {}
            },
            unlockedAchievements: new Set(),
            imeLastHandledValue: "",
            imeLastHandledAt: 0,
            enemyAmbientFxTimer: 1.4,
            cloud: {
                leaderboard: {},
                top3ByStage: {},
                playerRanksByStage: {},
                loading: false,
                lastSyncAt: 0,
                lastError: "",
                statusText: "尚未載入",
                pendingUpload: null,
                uploading: false,
                lastSubmitRank: null
            }
        };

        const PROFILE_STORAGE_KEY = "typegame_profile_v2";
        const DEFAULT_CLOUD_WEBHOOK_URL = "https://script.google.com/macros/s/AKfycbyEGf5vu0UvFEKFxfsbebSnoPOfIKbQKsgUXZuOzU2VjW61T5Sqi2knO9QvqBOC-qJnXQ/exec";

        function getStage() {
            return game.currentStageDef || STAGES[game.stageIndex];
        }

        function isTimedChallengeActive() {
            return !game.practiceMode && Number.isFinite(game.stageTimerEndAt) && game.stageTimerEndAt > 0;
        }

        function getTypingModeKey() {
            if (!game.chineseMode) return "en";
            return game.zhModeVariant === "bopomofo" ? "zh-bpmf" : "zh-hanzi";
        }

        function applyTypingMode(modeKey = "en") {
            if (modeKey === "zh-bpmf") {
                game.chineseMode = true;
                game.zhModeVariant = "bopomofo";
                game.inputLocale = "en";
                return;
            }
            if (modeKey === "zh-hanzi") {
                game.chineseMode = true;
                game.zhModeVariant = "hanzi";
                game.inputLocale = "zh";
                return;
            }
            game.chineseMode = false;
            game.zhModeVariant = "hanzi";
            game.inputLocale = "en";
        }

        function getTypingModeLabel(modeKey = getTypingModeKey()) {
            if (modeKey === "zh-hanzi") return "國字中打";
            if (modeKey === "zh-bpmf") return "純注音";
            return "英打";
        }

        function getTypingModeLongLabel(modeKey = getTypingModeKey()) {
            if (modeKey === "zh-hanzi") return "國字中打（注音選字）";
            if (modeKey === "zh-bpmf") return "純注音（鍵位對應）";
            return "英打";
        }

        function refreshTypingModeButtons() {
            const modeKey = getTypingModeKey();
            if (el.btnModeEn) el.btnModeEn.classList.toggle("active", modeKey === "en");
            if (el.btnModeZhHanzi) el.btnModeZhHanzi.classList.toggle("active", modeKey === "zh-hanzi");
            if (el.btnModeZhBpmf) el.btnModeZhBpmf.classList.toggle("active", modeKey === "zh-bpmf");
        }

        function initStaticUI() {
            el.stageTrack.innerHTML = STAGE_TRACK.map((stage, index) => `
                <div class="stage-node" data-stage-node="${index}">
                    <img src="${stage.thumb}" alt="${stage.name}">
                    <div>${stage.name}</div>
                </div>
            `).join("");
        }

        function createDefaultStageRecord() {
            return {
                bestScore: 0,
                bestStars: 0,
                bestGrade: "D",
                clearCount: 0,
                bestAcc: 0,
                bestCombo: 0,
                bestTyped: 0
            };
        }

        function gradeToValue(grade) {
            if (grade === "S") return 5;
            if (grade === "A") return 4;
            if (grade === "B") return 3;
            if (grade === "C") return 2;
            return 1;
        }

        function pickBetterGrade(current, candidate) {
            return gradeToValue(candidate) > gradeToValue(current) ? candidate : current;
        }

        function renderStars(stars, max = 3) {
            let html = "";
            for (let i = 1; i <= max; i += 1) {
                html += `<span class="${i <= stars ? "on" : "off"}">★</span>`;
            }
            return html;
        }

        function buildJudgeScore(baseScore, acc, maxCombo, typed) {
            const accScore = Math.round(acc * 26);
            const comboScore = Math.round(maxCombo * 34);
            const typedScore = Math.round(Math.min(500, typed) * 8);
            const total = Math.max(0, Math.round(baseScore + accScore + comboScore + typedScore));
            return { total, accScore, comboScore, typedScore };
        }

        function evaluateSpecialModeResult(modeKey, finalScore, acc, maxCombo, typed, rounds = 0) {
            if (modeKey === "endlessBoss") {
                let stars = 0;
                if (rounds >= 15 || finalScore >= 42000) stars = 3;
                else if (rounds >= 8 || finalScore >= 22000) stars = 2;
                else if (rounds >= 3 || finalScore >= 10000) stars = 1;
                let grade = stars === 3 ? "A" : stars === 2 ? "B" : stars === 1 ? "C" : "D";
                if (stars >= 3 && acc >= 93 && maxCombo >= 28 && typed >= 220) grade = "S";
                else if (acc >= 90 && stars >= 2) grade = "A";
                return { stars, grade, pass: rounds >= 1, tiers: [10000, 22000, 42000] };
            }

            if (modeKey === "zhMode") {
                const tiers = [6500, 11000, 17000];
                let stars = 0;
                if (finalScore >= tiers[2]) stars = 3;
                else if (finalScore >= tiers[1]) stars = 2;
                else if (finalScore >= tiers[0]) stars = 1;
                let grade = stars === 3 ? "A" : stars === 2 ? "B" : stars === 1 ? "C" : "D";
                if (stars >= 3 && acc >= 95 && maxCombo >= 18) grade = "S";
                else if (acc >= 92 && stars >= 2) grade = "A";
                else if (acc >= 86 && stars >= 1) grade = "B";
                return { stars, grade, pass: stars >= 1, tiers };
            }

            return { stars: 0, grade: "D", pass: false, tiers: [0, 0, 0] };
        }

        function evaluateStageResult(stageId, finalScore, acc, maxCombo, typed) {
            const tiers = STAGE_SCORE_TIERS[stageId] || [7000, 11000, 15500];
            let stars = 0;
            if (finalScore >= tiers[2]) stars = 3;
            else if (finalScore >= tiers[1]) stars = 2;
            else if (finalScore >= tiers[0]) stars = 1;

            let grade = "D";
            if (stars === 3) grade = "A";
            else if (stars === 2) grade = "B";
            else if (stars === 1) grade = "C";
            if (acc >= 96 && maxCombo >= 26 && typed >= 180 && stars >= 3) grade = "S";
            else if (acc >= 92 && stars >= 2) grade = "A";
            else if (acc >= 86 && stars >= 1) grade = "B";

            return {
                tiers,
                stars,
                grade,
                pass: stars >= 1
            };
        }

        function ensureStageRecordsShape() {
            if (!game.profile.stageRecords || typeof game.profile.stageRecords !== "object") {
                game.profile.stageRecords = {};
            }
            STAGES.forEach((stage, idx) => {
                const key = String(idx + 1);
                const saved = game.profile.stageRecords[key] || {};
                game.profile.stageRecords[key] = {
                    bestScore: Number(saved.bestScore) || 0,
                    bestStars: clamp(Number(saved.bestStars) || 0, 0, 3),
                    bestGrade: typeof saved.bestGrade === "string" ? saved.bestGrade : "D",
                    clearCount: Number(saved.clearCount) || 0,
                    bestAcc: Number(saved.bestAcc) || 0,
                    bestCombo: Number(saved.bestCombo) || 0,
                    bestTyped: Number(saved.bestTyped) || 0
                };
            });
        }

        function createDefaultSpecialRecord() {
            return {
                bestScore: 0,
                bestStars: 0,
                bestGrade: "D",
                bestAcc: 0,
                bestCombo: 0,
                bestTyped: 0,
                bestRounds: 0,
                playCount: 0
            };
        }

        function ensureSpecialRecordsShape() {
            if (!game.profile.specialRecords || typeof game.profile.specialRecords !== "object") {
                game.profile.specialRecords = {};
            }
            ["endlessBoss", "zhMode"].forEach((key) => {
                const saved = game.profile.specialRecords[key] || {};
                game.profile.specialRecords[key] = {
                    bestScore: Number(saved.bestScore) || 0,
                    bestStars: clamp(Number(saved.bestStars) || 0, 0, 3),
                    bestGrade: typeof saved.bestGrade === "string" ? saved.bestGrade : "D",
                    bestAcc: Number(saved.bestAcc) || 0,
                    bestCombo: Number(saved.bestCombo) || 0,
                    bestTyped: Number(saved.bestTyped) || 0,
                    bestRounds: Number(saved.bestRounds) || 0,
                    playCount: Number(saved.playCount) || 0
                };
            });
        }

        function getSpecialRecord(modeKey) {
            ensureSpecialRecordsShape();
            if (!game.profile.specialRecords[modeKey]) {
                game.profile.specialRecords[modeKey] = createDefaultSpecialRecord();
            }
            return game.profile.specialRecords[modeKey];
        }

        function getStageRecord(stageId) {
            ensureStageRecordsShape();
            const key = String(stageId);
            if (!game.profile.stageRecords[key]) {
                game.profile.stageRecords[key] = createDefaultStageRecord();
            }
            return game.profile.stageRecords[key];
        }

        function renderStageSelect() {
            ensureStageRecordsShape();
            ensureSpecialRecordsShape();
            const totalStars = STAGES.reduce((sum, stage) => sum + (getStageRecord(stage.id).bestStars || 0), 0);
            const totalClears = STAGES.reduce((sum, stage) => sum + (getStageRecord(stage.id).clearCount || 0), 0);
            const bestStageScore = STAGES.reduce((max, stage) => Math.max(max, getStageRecord(stage.id).bestScore || 0), 0);
            const endlessRecord = getSpecialRecord("endlessBoss");
            const modeLabel = getTypingModeLongLabel();

            el.stageSelectSummary.innerHTML = `
                目前輸入模式：<b>${modeLabel}</b> ｜ 全關最高分：<b>${Math.round(bestStageScore)}</b> ｜ 累積過關次數：<b>${totalClears}</b> ｜ 星等總數：<b>${totalStars}/15</b>
                <br>魔王模式最佳：<b>${Math.round(endlessRecord.bestScore || 0)}</b>（輪次 ${Math.round(endlessRecord.bestRounds || 0)}） ｜ 第 5 關也可用目前模式挑戰 3:00
            `;

            el.stageSelectGrid.innerHTML = STAGES.map((stage, index) => {
                const record = getStageRecord(stage.id);
                const pass = record.bestStars >= 1;
                const thumb = STAGE_TRACK[index]?.thumb || "assets/ui/location_thumb_forest.png";
                const statusText = pass ? "已過關" : "未過關";
                return `
                    <div class="stage-select-node ${pass ? "pass" : ""}">
                        <div class="stage-node-head">
                            <div class="stage-node-id">第 ${stage.id} 關</div>
                            <div class="stage-node-grade">最高 ${record.bestScore > 0 ? record.bestGrade : "--"}</div>
                        </div>
                        <img class="stage-node-thumb" src="${thumb}" alt="${stage.name}">
                        <div class="stage-node-title">${stage.name}</div>
                        <div class="stage-node-stars">${renderStars(record.bestStars)}</div>
                        <div class="stage-node-line">最高分：<b>${Math.round(record.bestScore)}</b></div>
                        <div class="stage-node-line">最佳：正確率 ${Math.round(record.bestAcc)}% / 連擊 ${Math.round(record.bestCombo)}</div>
                        <div class="stage-node-status ${pass ? "pass" : "fail"}">${statusText} ｜ 3:00 計分 ｜ ${getTypingModeLabel()}</div>
                        <button class="wood-btn stage-node-play" data-stage-play="${index}">以目前模式挑戰</button>
                    </div>
                `;
            }).join("");

            refreshTypingModeButtons();
        }

        function openStageSelectScreen() {
            closeOverlays();
            game.mode = "stage-select";
            game.independentStageMode = true;
            game.endlessBossMode = false;
            setTitleOptionsOpen(false);
            setScene("title");
            playBgm("title");
            applyStageVisual(1);
            buildAmbientSparks(26);
            renderStageSelect();
            updateStageTrack();
            el.stageSelectScreen.classList.add("show");
            syncImeInputVisibility();
        }

        function beginStageChallenge(index, bossChallenge = false) {
            closeOverlays();
            const typingMode = getTypingModeKey();
            resetRun(false);
            game.mode = "transition";
            game.independentStageMode = true;
            game.practiceMode = false;
            applyTypingMode(typingMode);
            game.endlessBossMode = false;
            game.selectedStageIndex = index;
            game.bossChallengeMode = !!bossChallenge;
            const clearCount = getStageRecord(index + 1).clearCount || 0;
            loadStage(index, clearCount > 0);
        }

        function beginEndlessBossMode() {
            closeOverlays();
            const typingMode = getTypingModeKey();
            resetRun(false);
            game.mode = "transition";
            game.practiceMode = false;
            applyTypingMode(typingMode);
            game.independentStageMode = false;
            game.bossChallengeMode = true;
            game.endlessBossMode = true;
            game.selectedStageIndex = 4;
            loadStage(4, true);
            showCoach(`魔王模式啟動：${getTypingModeLabel()}・無盡連戰，直到你倒下為止。`, 1200);
        }

        function beginChineseMode(variant = "hanzi") {
            const modeKey = variant === "bopomofo" ? "zh-bpmf" : "zh-hanzi";
            resetRun(true);
            applyTypingMode(modeKey);
            openStageSelectScreen();
            showCoach(
                modeKey === "zh-bpmf"
                    ? "已切換純注音：五關都可用注音鍵位挑戰。"
                    : "已切換國字中打：五關都可用注音選字挑戰。",
                1400
            );
        }

        function readProfile() {
            try {
                const raw = localStorage.getItem(PROFILE_STORAGE_KEY);
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (parsed && typeof parsed === "object") {
                        game.profile = {
                            ...game.profile,
                            ...parsed
                        };
                    }
                }
            } catch (error) {
                // Ignore invalid local profile payload and fallback to defaults.
            }
            if (!Array.isArray(game.profile.achievements)) {
                game.profile.achievements = [];
            }
            if (typeof game.profile.playerName !== "string") {
                game.profile.playerName = "";
            }
            if (typeof game.profile.sheetWebhookUrl !== "string") {
                game.profile.sheetWebhookUrl = "";
            }
            game.profile.playerName = game.profile.playerName.trim().slice(0, 20);
            game.profile.sheetWebhookUrl = game.profile.sheetWebhookUrl.trim();
            if (!game.profile.sheetWebhookUrl) {
                game.profile.sheetWebhookUrl = DEFAULT_CLOUD_WEBHOOK_URL;
            }
            ensureStageRecordsShape();
            ensureSpecialRecordsShape();
            game.unlockedAchievements = new Set(game.profile.achievements);
        }

        function writeProfile() {
            try {
                localStorage.setItem(PROFILE_STORAGE_KEY, JSON.stringify(game.profile));
            } catch (error) {
                // Ignore storage quota or privacy mode errors.
            }
        }

        function escapeHtmlText(value) {
            return String(value ?? "")
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/\"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function sanitizePlayerName(name) {
            return String(name || "").trim().slice(0, 20);
        }

        function getCloudWebhookUrl() {
            return String(game.profile.sheetWebhookUrl || "").trim();
        }

        function isCloudWebhookConfigured() {
            const url = getCloudWebhookUrl();
            return /^https?:\/\//i.test(url);
        }

        function setCloudSettingsStatus(text, tone = "neutral") {
            if (!el.cloudSettingsStatus) return;
            el.cloudSettingsStatus.textContent = text;
            el.cloudSettingsStatus.dataset.tone = tone;
        }

        function setCloudUploadStatus(text, tone = "neutral") {
            if (!el.cloudUploadStatus) return;
            el.cloudUploadStatus.textContent = text;
            el.cloudUploadStatus.dataset.tone = tone;
        }

        function setTitleLeaderboardStatus(text, tone = "neutral") {
            if (!el.titleLeaderboardStatus) return;
            el.titleLeaderboardStatus.textContent = text;
            el.titleLeaderboardStatus.dataset.tone = tone;
        }

        function syncCloudSettingsInputs() {
            if (el.cloudPlayerName) el.cloudPlayerName.value = game.profile.playerName || "";
            if (el.cloudSheetUrl) el.cloudSheetUrl.value = game.profile.sheetWebhookUrl || "";
        }

        function formatCloudTimestamp(ts) {
            if (!Number.isFinite(ts) || ts <= 0) return "";
            try {
                const d = new Date(ts);
                const hh = String(d.getHours()).padStart(2, "0");
                const mm = String(d.getMinutes()).padStart(2, "0");
                const ss = String(d.getSeconds()).padStart(2, "0");
                return `${hh}:${mm}:${ss}`;
            } catch (error) {
                return "";
            }
        }

        function getCloudLeaderboardEntry(stageId) {
            const key = String(stageId);
            const raw = game.cloud?.leaderboard?.[key];
            if (!raw || typeof raw !== "object") return null;
            return raw;
        }

        function getCloudTop3Entries(stageId) {
            const key = String(stageId);
            const rows = game.cloud?.top3ByStage?.[key];
            return Array.isArray(rows) ? rows : [];
        }

        function getCloudPlayerRankEntry(stageId) {
            const key = String(stageId);
            const raw = game.cloud?.playerRanksByStage?.[key];
            if (!raw || typeof raw !== "object") return null;
            return raw;
        }

        function renderCloudUploadRankboard() {
            if (!el.cloudUploadRankboard) return;
            const stage = getStage();
            const pending = game.cloud.pendingUpload;
            const stageId = Number(pending?.record?.stageId || stage?.id || 0);
            if (!stageId || stageId < 1 || stageId > STAGES.length) {
                el.cloudUploadRankboard.textContent = "本關排行榜僅在五關 3:00 結算時顯示。";
                return;
            }

            const top3 = getCloudTop3Entries(stageId);
            const playerRank = getCloudPlayerRankEntry(stageId) || (game.cloud.lastSubmitRank && Number(game.cloud.lastSubmitRank.stageId) === stageId ? game.cloud.lastSubmitRank : null);
            if (!top3.length && !playerRank) {
                el.cloudUploadRankboard.textContent = "本關排行榜尚未載入。可按「更新排行榜」查看雲端前三名。";
                return;
            }

            const rowsHtml = (top3.length ? top3.slice(0, 3) : [{ rank: 1, playerName: "尚無資料", score: 0 }]).map((row, index) => {
                const rank = Math.max(1, Math.round(Number(row.rank) || (index + 1)));
                const name = escapeHtmlText(row.playerName || "匿名弟子");
                const score = Math.max(0, Math.round(Number(row.score) || 0));
                const isYou = !!playerRank && playerRank.rank === rank && String(playerRank.playerName || "") === String(row.playerName || "");
                return `
                    <div class="rankboard-row ${isYou ? "you" : ""}">
                        <div>${rank}</div>
                        <div style="min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${name}</div>
                        <div>${score}</div>
                    </div>
                `;
            }).join("");

            let meta = "";
            if (playerRank && Number.isFinite(Number(playerRank.rank))) {
                const rank = Math.max(1, Math.round(Number(playerRank.rank)));
                const score = Math.max(0, Math.round(Number(playerRank.score) || 0));
                meta = `你的目前名次：第 <b>${rank}</b> 名（${score} 分）`;
            } else if (sanitizePlayerName(game.profile.playerName)) {
                meta = "尚未找到你的雲端名次，先上傳一次成績即可顯示。";
            } else {
                meta = "上傳時會詢問姓名，完成後可顯示你的名次。";
            }

            const stageLabel = STAGE_TRACK[stageId - 1]?.name || `第${stageId}關`;
            el.cloudUploadRankboard.innerHTML = `
                <div class="rankboard-title">${escapeHtmlText(stageLabel)} 雲端排行榜（前 3 名）</div>
                <div class="rankboard-list">${rowsHtml}</div>
                <div class="rankboard-meta">${meta}</div>
            `;
        }

        function renderTitleLeaderboard() {
            if (!el.titleLeaderboardGrid) return;
            const cards = STAGES.map((stage) => {
                const entry = getCloudLeaderboardEntry(stage.id);
                const top3 = getCloudTop3Entries(stage.id);
                const playerRank = getCloudPlayerRankEntry(stage.id);
                const stageShortName = STAGE_TRACK[(stage.id || 1) - 1]?.name || `第${stage.id}關`;
                if (!entry) {
                    return `
                        <div class="lb-stage-card">
                            <div class="lb-stage-name">第${stage.id}關・${escapeHtmlText(stageShortName)}</div>
                            <div class="lb-stage-score">--</div>
                            <div class="lb-stage-player">尚無雲端紀錄</div>
                            <div class="lb-you-rank">輸入姓名並上傳後，這裡會顯示你的名次。</div>
                        </div>
                    `;
                }
                const score = Math.max(0, Math.round(Number(entry.score) || 0));
                const player = escapeHtmlText(entry.playerName || "匿名弟子");
                const extra = [];
                if (entry.typingModeLabel) extra.push(escapeHtmlText(entry.typingModeLabel));
                if (entry.grade) extra.push(`評等 ${escapeHtmlText(entry.grade)}`);
                if (Number.isFinite(entry.stars)) extra.push(`${"★".repeat(clamp(Math.round(entry.stars), 0, 3))}${"☆".repeat(3 - clamp(Math.round(entry.stars), 0, 3))}`);
                const metaText = extra.length ? extra.join(" ｜ ") : "雲端最高分";
                const top3Html = (top3.length ? top3.slice(0, 3) : [entry]).map((row, index) => {
                    const rank = Math.max(1, Math.round(Number(row.rank) || (index + 1)));
                    return `
                        <div class="lb-top3-row">
                            <div class="lb-top3-rank">${rank}</div>
                            <div class="lb-top3-name">${escapeHtmlText(row.playerName || "匿名弟子")}</div>
                            <div class="lb-top3-score">${Math.max(0, Math.round(Number(row.score) || 0))}</div>
                        </div>
                    `;
                }).join("");
                const youRankText = playerRank && Number.isFinite(Number(playerRank.rank))
                    ? `你的名次：第 ${Math.max(1, Math.round(Number(playerRank.rank)))} 名（${Math.max(0, Math.round(Number(playerRank.score) || 0))} 分）`
                    : (sanitizePlayerName(game.profile.playerName) ? "尚未找到你的名次（先上傳一次）" : "上傳時輸入姓名即可追蹤個人名次");
                return `
                    <div class="lb-stage-card">
                        <div class="lb-stage-name">第${stage.id}關・${escapeHtmlText(stageShortName)}</div>
                        <div class="lb-stage-score">${score}</div>
                        <div class="lb-stage-player">${player}</div>
                        <div class="lb-stage-player">${metaText}</div>
                        <div class="lb-top3-list">${top3Html}</div>
                        <div class="lb-you-rank">${escapeHtmlText(youRankText)}</div>
                    </div>
                `;
            }).join("");
            el.titleLeaderboardGrid.innerHTML = cards;
            renderCloudUploadRankboard();
        }

        function buildCloudRequestUrl(action, extraParams = null) {
            const raw = getCloudWebhookUrl();
            if (!raw) return "";
            try {
                const url = new URL(raw);
                if (action) url.searchParams.set("action", action);
                const playerName = sanitizePlayerName(game.profile.playerName || "");
                if (playerName) {
                    url.searchParams.set("playerName", playerName);
                }
                if (extraParams && typeof extraParams === "object") {
                    Object.entries(extraParams).forEach(([key, value]) => {
                        if (value === undefined || value === null || value === "") return;
                        url.searchParams.set(String(key), String(value));
                    });
                }
                url.searchParams.set("_ts", String(Date.now()));
                return url.toString();
            } catch (error) {
                return "";
            }
        }

        async function parseCloudResponsePayload(response) {
            const text = await response.text();
            if (!text) return null;
            try {
                return JSON.parse(text);
            } catch (error) {
                return { rawText: text };
            }
        }

        function parseStageIdFromUnknown(value) {
            if (Number.isFinite(Number(value))) {
                const n = Math.round(Number(value));
                return n >= 1 && n <= STAGES.length ? n : 0;
            }
            const str = String(value || "");
            const match = str.match(/(\d+)/);
            if (!match) return 0;
            const n = Number(match[1]);
            return Number.isFinite(n) && n >= 1 && n <= STAGES.length ? n : 0;
        }

        function normalizeCloudScoreRow(row, fallbackStageId = 0) {
            if (!row || typeof row !== "object") return null;
            const stageId = parseStageIdFromUnknown(
                row.stageId ?? row.stage_id ?? row.stage ?? row.level ?? row.levelId ?? row.stageIndex ?? fallbackStageId
            );
            if (!stageId) return null;

            const score = Number(
                row.score ?? row.bestScore ?? row.best_score ?? row.points ?? row.total ?? row.finalScore ?? row.final_score ?? 0
            );
            if (!Number.isFinite(score)) return null;

            const starsRaw = Number(row.stars ?? row.bestStars ?? row.best_stars ?? row.star ?? -1);
            const accRaw = Number(row.acc ?? row.accuracy ?? row.accuracyRate ?? row.correctRate ?? row.correct_rate ?? 0);
            const comboRaw = Number(row.maxCombo ?? row.max_combo ?? row.combo ?? 0);
            const typedRaw = Number(row.totalTyped ?? row.total_typed ?? row.typed ?? row.keys ?? row.totalKeys ?? 0);
            const timestampRaw = row.timestamp ?? row.time ?? row.createdAt ?? row.created_at ?? row.updatedAt ?? row.updated_at ?? row.date;
            const ts = Number.isFinite(Number(timestampRaw))
                ? Number(timestampRaw)
                : (timestampRaw ? Date.parse(String(timestampRaw)) : 0);
            const playerName = sanitizePlayerName(
                row.playerName ?? row.player_name ?? row.nickname ?? row.name ?? row.player ?? row.user ?? ""
            ) || "匿名弟子";
            const typingMode = String(row.typingMode ?? row.typing_mode ?? row.mode ?? row.inputMode ?? "").trim();
            const typingModeLabel = String(row.typingModeLabel ?? row.typing_mode_label ?? row.modeLabel ?? row.mode_label ?? "").trim();
            const grade = String(row.grade ?? row.bestGrade ?? row.best_grade ?? "").trim().toUpperCase().slice(0, 2);

            return {
                stageId,
                score,
                stars: Number.isFinite(starsRaw) ? clamp(Math.round(starsRaw), 0, 3) : null,
                acc: Number.isFinite(accRaw) ? Math.round(accRaw) : 0,
                maxCombo: Number.isFinite(comboRaw) ? Math.round(comboRaw) : 0,
                typed: Number.isFinite(typedRaw) ? Math.round(typedRaw) : 0,
                playerName,
                typingMode,
                typingModeLabel: typingModeLabel || (typingMode ? getTypingModeLabel(typingMode) : ""),
                grade: grade || "",
                timestamp: Number.isFinite(ts) ? ts : 0
            };
        }

        function collectCloudRowsFromPayload(payload) {
            if (!payload) return [];
            if (Array.isArray(payload)) return payload;
            if (typeof payload !== "object") return [];

            const arrayKeys = ["rows", "data", "items", "records", "list"];
            for (const key of arrayKeys) {
                if (Array.isArray(payload[key])) return payload[key];
            }

            if (payload.result && typeof payload.result === "object") {
                const nested = collectCloudRowsFromPayload(payload.result);
                if (nested.length) return nested;
            }
            if (payload.payload && typeof payload.payload === "object") {
                const nested = collectCloudRowsFromPayload(payload.payload);
                if (nested.length) return nested;
            }
            if (payload.leaderboard && Array.isArray(payload.leaderboard)) return payload.leaderboard;

            const byStageObj = payload.leaderboard && typeof payload.leaderboard === "object"
                ? payload.leaderboard
                : (payload.stageBest && typeof payload.stageBest === "object"
                    ? payload.stageBest
                    : (payload.stages && typeof payload.stages === "object" ? payload.stages : null));
            if (byStageObj) {
                return Object.entries(byStageObj).map(([stageKey, value]) => {
                    if (value && typeof value === "object" && !Array.isArray(value)) {
                        return { ...value, stageId: value.stageId ?? stageKey };
                    }
                    return { stageId: stageKey, score: Number(value) || 0 };
                });
            }

            return [];
        }

        function normalizeCloudLeaderboardPayload(payload) {
            const rows = collectCloudRowsFromPayload(payload);
            const bestByStage = {};

            rows.forEach((rawRow) => {
                const normalized = normalizeCloudScoreRow(rawRow);
                if (!normalized) return;
                const key = String(normalized.stageId);
                const current = bestByStage[key];
                if (!current) {
                    bestByStage[key] = normalized;
                    return;
                }
                const normalizedScore = Number(normalized.score) || 0;
                const currentScore = Number(current.score) || 0;
                const betterScore = normalizedScore > currentScore;
                const newerTie = normalizedScore === currentScore && (normalized.timestamp || 0) > (current.timestamp || 0);
                if (betterScore || newerTie) {
                    bestByStage[key] = normalized;
                }
            });

            return bestByStage;
        }

        function normalizeCloudTop3ByStagePayload(payload) {
            const out = {};
            if (payload && typeof payload === "object") {
                const top3Obj = payload.top3ByStage && typeof payload.top3ByStage === "object"
                    ? payload.top3ByStage
                    : (payload.top3 && typeof payload.top3 === "object" && !Array.isArray(payload.top3) ? payload.top3 : null);
                if (top3Obj) {
                    Object.entries(top3Obj).forEach(([stageKey, list]) => {
                        const stageId = parseStageIdFromUnknown(stageKey);
                        if (!stageId) return;
                        const normalizedList = (Array.isArray(list) ? list : [])
                            .map((row, index) => {
                                const normalized = normalizeCloudScoreRow({ ...row, stageId: row?.stageId ?? stageId });
                                if (!normalized) return null;
                                const rank = Number(row?.rank);
                                return {
                                    ...normalized,
                                    rank: Number.isFinite(rank) ? Math.max(1, Math.round(rank)) : (index + 1)
                                };
                            })
                            .filter(Boolean)
                            .sort((a, b) => (a.rank || 999) - (b.rank || 999))
                            .slice(0, 3);
                        out[String(stageId)] = normalizedList;
                    });
                }
            }

            if (Object.keys(out).length === 0) {
                const bestByStage = normalizeCloudLeaderboardPayload(payload);
                Object.entries(bestByStage).forEach(([stageKey, row]) => {
                    out[String(stageKey)] = [{ ...row, rank: 1 }];
                });
            }

            return out;
        }

        function normalizeCloudPlayerRanksByStagePayload(payload) {
            const out = {};
            if (!payload || typeof payload !== "object") return out;
            const ranksObj = payload.playerRanksByStage && typeof payload.playerRanksByStage === "object"
                ? payload.playerRanksByStage
                : null;
            if (ranksObj) {
                Object.entries(ranksObj).forEach(([stageKey, row]) => {
                    const stageId = parseStageIdFromUnknown(stageKey);
                    if (!stageId || !row || typeof row !== "object") return;
                    const normalized = normalizeCloudScoreRow({ ...row, stageId: row.stageId ?? stageId });
                    if (!normalized) return;
                    const rank = Number(row.rank ?? row.place ?? row.position);
                    if (!Number.isFinite(rank)) return;
                    out[String(stageId)] = {
                        ...normalized,
                        rank: Math.max(1, Math.round(rank))
                    };
                });
            }

            if (payload.playerRank && typeof payload.playerRank === "object") {
                const stageId = parseStageIdFromUnknown(payload.playerRank.stageId);
                const normalized = normalizeCloudScoreRow(payload.playerRank);
                const rank = Number(payload.playerRank.rank ?? payload.playerRank.place ?? payload.playerRank.position);
                if (stageId && normalized && Number.isFinite(rank)) {
                    out[String(stageId)] = {
                        ...normalized,
                        rank: Math.max(1, Math.round(rank))
                    };
                }
            }

            return out;
        }

        function applyCloudLeaderboard(payload) {
            const normalized = normalizeCloudLeaderboardPayload(payload);
            if (!normalized || typeof normalized !== "object") return false;
            game.cloud.leaderboard = normalized;
            game.cloud.top3ByStage = normalizeCloudTop3ByStagePayload(payload);
            const playerRanks = normalizeCloudPlayerRanksByStagePayload(payload);
            if (playerRanks && typeof playerRanks === "object" && Object.keys(playerRanks).length > 0) {
                game.cloud.playerRanksByStage = {
                    ...game.cloud.playerRanksByStage,
                    ...playerRanks
                };
            }
            if (payload && typeof payload === "object" && payload.playerRank && typeof payload.playerRank === "object") {
                const rankEntry = normalizeCloudPlayerRanksByStagePayload({ playerRank: payload.playerRank });
                const values = Object.values(rankEntry);
                game.cloud.lastSubmitRank = values.length ? values[0] : null;
            }
            renderTitleLeaderboard();
            return true;
        }

        function syncCloudUploadPanelState() {
            const pending = game.cloud.pendingUpload;
            if (el.btnUploadScore) {
                const disableUpload =
                    !pending ||
                    game.cloud.uploading ||
                    !isCloudWebhookConfigured() ||
                    !!pending.uploaded;
                el.btnUploadScore.disabled = !!disableUpload;
                el.btnUploadScore.textContent = game.cloud.uploading
                    ? "上傳中..."
                    : (pending?.uploaded ? "已上傳" : "詢問後上傳");
            }
            if (el.btnCloudRefreshResult) {
                el.btnCloudRefreshResult.disabled = !!game.cloud.loading;
            }
            renderCloudUploadRankboard();
        }

        function prepareCloudUploadFromResult({ stage, finalScore, acc, stageEval }) {
            const canUpload = !!stage && game.independentStageMode && !game.practiceMode && !game.endlessBossMode;
            if (!canUpload) {
                game.cloud.pendingUpload = null;
                if (game.endlessBossMode) {
                    setCloudUploadStatus("魔王模式為無盡分數，未納入各關排行榜上傳。", "neutral");
                } else if (game.practiceMode) {
                    setCloudUploadStatus("練習模式不會上傳雲端排行榜。", "neutral");
                } else {
                    setCloudUploadStatus("僅支援五關 3:00 結算成績上傳。", "neutral");
                }
                syncCloudUploadPanelState();
                return;
            }

            const record = {
                action: "submitScore",
                stageId: stage.id,
                stageName: STAGE_TRACK[(stage.id || 1) - 1]?.name || stage.name || `第${stage.id}關`,
                score: Math.round(finalScore),
                accuracy: Math.round(acc),
                maxCombo: Math.round(game.maxCombo),
                totalTyped: Math.round(game.totalTyped),
                totalKeys: Math.round(game.totalTyped),
                defeated: Math.round(game.defeated || 0),
                stars: Math.round(stageEval?.stars || 0),
                grade: String(stageEval?.grade || "D"),
                pass: !!stageEval?.pass,
                typingMode: getTypingModeKey(),
                typingModeLabel: getTypingModeLabel(),
                playerName: sanitizePlayerName(game.profile.playerName) || "匿名弟子",
                durationSec: STAGE_CHALLENGE_SECONDS,
                submittedAt: new Date().toISOString(),
                clientVersion: "web-final"
            };

            game.cloud.pendingUpload = {
                record,
                uploaded: false,
                uploadedAt: 0
            };
            game.cloud.lastSubmitRank = null;

            if (!isCloudWebhookConfigured()) {
                setCloudUploadStatus("請先在首頁「遊戲設定」填入 Google Apps Script Web App URL，再上傳。", "warn");
            } else {
                setCloudUploadStatus("按「詢問後上傳」後，會先確認是否上傳並輸入姓名，再送到 Google Sheet。", "neutral");
            }
            syncCloudUploadPanelState();
        }

        async function fetchCloudLeaderboard(options = {}) {
            const { silent = false } = options;
            const url = buildCloudRequestUrl("leaderboard");
            if (!url) {
                if (!silent) showToast("請先設定 Google Sheet Web App URL", 900);
                game.cloud.lastError = "";
                setCloudSettingsStatus("請先輸入 Google Apps Script Web App URL。", "warn");
                setTitleLeaderboardStatus("尚未設定 URL", "warn");
                renderTitleLeaderboard();
                syncCloudUploadPanelState();
                return null;
            }

            game.cloud.loading = true;
            game.cloud.lastError = "";
            setCloudSettingsStatus("正在同步排行榜...", "loading");
            setTitleLeaderboardStatus("同步中...", "loading");
            if (game.mode === "result") setCloudUploadStatus("正在更新首頁排行榜...", "loading");
            syncCloudUploadPanelState();

            try {
                const response = await fetch(url, {
                    method: "GET",
                    cache: "no-store"
                });
                const payload = await parseCloudResponsePayload(response);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const ok = applyCloudLeaderboard(payload);
                game.cloud.lastSyncAt = Date.now();
                const syncTime = formatCloudTimestamp(game.cloud.lastSyncAt);
                if (!ok) {
                    setTitleLeaderboardStatus("格式不符（無法解析排行榜）", "warn");
                    setCloudSettingsStatus("已連線，但回傳格式無法解析。", "warn");
                    if (game.mode === "result") setCloudUploadStatus("已連線，但排行榜格式無法解析。", "warn");
                } else {
                    setTitleLeaderboardStatus(syncTime ? `已更新 ${syncTime}` : "已更新", "ok");
                    setCloudSettingsStatus("排行榜同步完成。", "ok");
                    if (game.mode === "result") setCloudUploadStatus("排行榜已更新，可回首頁查看各關最高分。", "ok");
                }
                return game.cloud.leaderboard;
            } catch (error) {
                const message = error?.message ? String(error.message) : "連線失敗";
                game.cloud.lastError = message;
                setTitleLeaderboardStatus("同步失敗", "error");
                setCloudSettingsStatus(`同步失敗：${message}`, "error");
                if (game.mode === "result") setCloudUploadStatus(`排行榜更新失敗：${message}`, "error");
                if (!silent) showToast("排行榜同步失敗", 900);
                return null;
            } finally {
                game.cloud.loading = false;
                syncCloudUploadPanelState();
            }
        }

        async function uploadPendingCloudScore() {
            const pending = game.cloud.pendingUpload;
            if (!pending || !pending.record) {
                setCloudUploadStatus("目前沒有可上傳的結算成績。", "warn");
                syncCloudUploadPanelState();
                return;
            }
            const url = getCloudWebhookUrl();
            if (!isCloudWebhookConfigured()) {
                setCloudUploadStatus("請先在首頁「遊戲設定」填入 Google Apps Script Web App URL。", "warn");
                showToast("先設定 Google Sheet URL", 900);
                syncCloudUploadPanelState();
                return;
            }

            const consent = window.confirm("是否要上傳這次成績到雲端排行榜？");
            if (!consent) {
                setCloudUploadStatus("已取消上傳。你的成績仍保留在本機紀錄。", "neutral");
                syncCloudUploadPanelState();
                return;
            }

            const currentName = sanitizePlayerName(game.profile.playerName || el.cloudPlayerName?.value || "");
            const nameInput = window.prompt("請輸入排行榜顯示姓名（20字內）", currentName || "");
            if (nameInput === null) {
                setCloudUploadStatus("已取消上傳（未輸入姓名）。", "neutral");
                syncCloudUploadPanelState();
                return;
            }
            const savedName = sanitizePlayerName(nameInput);
            if (!savedName) {
                setCloudUploadStatus("姓名不能為空白，已取消上傳。", "warn");
                syncCloudUploadPanelState();
                return;
            }
            if (savedName !== (game.profile.playerName || "")) {
                game.profile.playerName = savedName;
                writeProfile();
                syncCloudSettingsInputs();
            }

            const record = {
                ...pending.record,
                playerName: savedName,
                submittedAt: new Date().toISOString()
            };

            game.cloud.uploading = true;
            setCloudUploadStatus("正在上傳成績到 Google Sheet...", "loading");
            setCloudSettingsStatus("正在上傳成績...", "loading");
            syncCloudUploadPanelState();

            try {
                const body = new URLSearchParams();
                body.set("action", "submitScore");
                body.set("record", JSON.stringify(record));

                const response = await fetch(url, {
                    method: "POST",
                    body,
                    cache: "no-store"
                });
                const payload = await parseCloudResponsePayload(response);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                let leaderboardUpdated = false;
                let playerRankText = "";
                if (payload && typeof payload === "object") {
                    leaderboardUpdated = applyCloudLeaderboard(payload);
                    if (!leaderboardUpdated && payload.leaderboard) {
                        leaderboardUpdated = applyCloudLeaderboard(payload.leaderboard);
                    }
                    const rank = Number(payload.playerRank?.rank);
                    const score = Number(payload.playerRank?.score ?? record.score);
                    if (Number.isFinite(rank)) {
                        playerRankText = `你目前第 ${Math.max(1, Math.round(rank))} 名（${Math.max(0, Math.round(score || 0))} 分）`;
                    }
                }

                game.cloud.pendingUpload = {
                    record,
                    uploaded: true,
                    uploadedAt: Date.now()
                };
                setCloudUploadStatus(playerRankText ? `成績已上傳，${playerRankText}。` : "成績已上傳。可回首頁查看各關排行榜。", "ok");
                setCloudSettingsStatus("成績上傳完成。", "ok");
                if (leaderboardUpdated) {
                    const syncTime = formatCloudTimestamp(Date.now());
                    setTitleLeaderboardStatus(syncTime ? `已更新 ${syncTime}` : "已更新", "ok");
                } else {
                    await fetchCloudLeaderboard({ silent: true });
                }
                showToast("雲端上傳成功", 900);
            } catch (error) {
                const message = error?.message ? String(error.message) : "上傳失敗";
                setCloudUploadStatus(`上傳失敗：${message}`, "error");
                setCloudSettingsStatus(`上傳失敗：${message}`, "error");
                showToast("雲端上傳失敗", 900);
            } finally {
                game.cloud.uploading = false;
                syncCloudUploadPanelState();
            }
        }

        function saveCloudSettings() {
            const playerName = sanitizePlayerName(el.cloudPlayerName?.value || "");
            const sheetWebhookUrl = String(el.cloudSheetUrl?.value || "").trim() || DEFAULT_CLOUD_WEBHOOK_URL;
            game.profile.playerName = playerName;
            game.profile.sheetWebhookUrl = sheetWebhookUrl;
            if (!playerName) {
                game.cloud.playerRanksByStage = {};
                game.cloud.lastSubmitRank = null;
            }
            writeProfile();
            syncCloudSettingsInputs();
            if (!sheetWebhookUrl) {
                setCloudSettingsStatus("已儲存。尚未填入雲端 URL。", "neutral");
                setTitleLeaderboardStatus("尚未設定 URL", "warn");
                game.cloud.leaderboard = {};
                renderTitleLeaderboard();
            } else if (!/^https?:\/\//i.test(sheetWebhookUrl)) {
                setCloudSettingsStatus("已儲存，但 URL 格式看起來不正確。", "warn");
            } else {
                setCloudSettingsStatus("設定已儲存，可按「更新排行榜」測試連線。", "ok");
                fetchCloudLeaderboard({ silent: true });
            }
            if (game.mode === "result" && game.cloud.pendingUpload?.record) {
                prepareCloudUploadFromResult({
                    stage: getStage(),
                    finalScore: game.cloud.pendingUpload.record.score,
                    acc: game.cloud.pendingUpload.record.accuracy,
                    stageEval: {
                        stars: game.cloud.pendingUpload.record.stars,
                        grade: game.cloud.pendingUpload.record.grade,
                        pass: game.cloud.pendingUpload.record.pass
                    }
                });
            } else {
                syncCloudUploadPanelState();
            }
            renderTitleLeaderboard();
        }

        function applyAccessibilityOptions() {
            document.body.classList.toggle("access-contrast", !!game.profile.highContrast);
            document.body.classList.toggle("reduce-motion", !!game.profile.reducedMotion);
        }

        function refreshOptionButtons() {
            el.btnAssist.textContent = `輔助模式：${game.profile.assistMode ? "開" : "關"}`;
            el.btnContrast.textContent = `高對比：${game.profile.highContrast ? "開" : "關"}`;
            el.btnMotion.textContent = `低動態：${game.profile.reducedMotion ? "開" : "關"}`;
        }

        function setTitleOptionsOpen(open) {
            game.titleOptionsOpen = !!open;
            el.titleMore.classList.toggle("show", game.titleOptionsOpen);
            el.btnTitleSettings.textContent = game.titleOptionsOpen ? "收合設定" : "遊戲設定";
        }

        function renderActionGuide(stage, data) {
            if (!stage || !data) return;
            let items = [];

            if (stage.mechanic === "homefall") {
                items = [
                    { icon: "assets/ui/icon_scroll_pixel.png", text: game.chineseMode ? "打注音符號" : "打符文", active: true },
                    { icon: "assets/ui/icon_mp_pixel.png", text: `蓄氣 ${data.charge}/${data.chargeNeed}`, active: data.charge + 1 >= data.chargeNeed },
                    { icon: "assets/ui/icon_sword_pixel.png", text: "滿格自動斬", active: data.charge + 1 >= data.chargeNeed }
                ];
            } else if (stage.mechanic === "top_anchor") {
                const guarding = data.expectedType === "anchor";
                const cloudReady = data.cloudCharge >= data.cloudNeed;
                items = [
                    { icon: "assets/ui/icon_atk_pixel.png", text: game.chineseMode ? "注音踏雲" : "Q~P 踏雲", active: !guarding && !cloudReady },
                    { icon: "assets/ui/icon_def_pixel.png", text: "F/J 回防", active: guarding || cloudReady },
                    { icon: "assets/ui/icon_sword_pixel.png", text: `雲爆 ${data.burstCount}/${data.targetBurst}`, active: cloudReady }
                ];
            } else if (stage.mechanic === "bottom_defense") {
                const burstReady = data.shieldCharge + 1 >= data.shieldNeed;
                items = [
                    { icon: "assets/ui/icon_def_pixel.png", text: game.chineseMode ? "符號格擋" : "Z~M 格擋", active: true },
                    { icon: "assets/ui/icon_mp_pixel.png", text: `盾氣 ${data.shieldCharge}/${data.shieldNeed}`, active: burstReady },
                    { icon: "assets/ui/icon_sword_pixel.png", text: `反震 ${data.counterBursts}/${data.targetBurst}`, active: burstReady }
                ];
            } else if (stage.mechanic === "word_combo") {
                items = [
                    { icon: "assets/ui/icon_scroll_pixel.png", text: game.chineseMode ? (game.zhModeVariant === "bopomofo" ? "看整串注音" : "看整個詞語") : "看整個單字", active: true },
                    { icon: "assets/ui/icon_atk_pixel.png", text: game.chineseMode ? (game.zhModeVariant === "bopomofo" ? "按對鍵位" : "注音選字完成") : "連續打完", active: data.progress > 0 },
                    { icon: "assets/ui/icon_sword_pixel.png", text: `斬咒 ${data.completed}/${data.target}`, active: data.progress > 0 }
                ];
            } else if (stage.mechanic === "boss_raid") {
                if (data.guardMode) {
                    items = [
                        { icon: "assets/ui/icon_def_pixel.png", text: `按 ${data.guardKey.toUpperCase()}`, active: true },
                        { icon: "assets/ui/icon_sword_pixel.png", text: "擋住再反擊", active: true },
                        { icon: "assets/ui/icon_mp_pixel.png", text: `真氣 ${Math.round(game.qi)}/100`, active: game.qi >= game.maxQi }
                    ];
                } else {
                    const counterText = data.counterWindow > 0
                        ? `反擊 x${(data.counterBonus || 1).toFixed(2)} ${data.counterWindow.toFixed(1)}s`
                        : `第 ${data.phase || 1} 階段`;
                    items = [
                        { icon: "assets/ui/icon_scroll_pixel.png", text: game.chineseMode ? (game.zhModeVariant === "bopomofo" ? "完整注音串" : "完整字詞") : "完整單字", active: true },
                        { icon: "assets/ui/icon_sword_pixel.png", text: counterText, active: data.counterWindow > 0 || (data.phase || 1) >= 2 },
                        { icon: "assets/ui/icon_mp_pixel.png", text: `Space ${Math.round(game.qi)}/100`, active: game.qi >= game.maxQi }
                    ];
                }
            }

            const chips = items.map((item) => `
                <span class="guide-chip ${item.active ? "active" : ""}">
                    <img src="${item.icon}" alt="">
                    <span>${item.text}</span>
                </span>
            `).join("");
            if (el.objectiveGuide) el.objectiveGuide.innerHTML = chips;
        }

        function updateBossQteUI() {
            const stage = getStage();
            const data = game.stageData;
            if (!stage || stage.mechanic !== "boss_raid" || !data || game.mode !== "playing") {
                el.bossQtePanel.classList.remove("show", "danger");
                el.counterWindowPanel.classList.remove("show");
                return;
            }

            const now = performance.now();
            if (data.guardMode) {
                const remainMs = Math.max(0, data.guardDeadline - now);
                const duration = Math.max(1, data.guardDuration || 1);
                const ratio = clamp(remainMs / duration, 0, 1);
                el.bossQtePanel.classList.add("show");
                el.bossQtePanel.classList.toggle("danger", remainMs <= 900);
                el.bossQteKey.textContent = (data.guardKey || "f").toUpperCase();
                el.bossQteCountdown.textContent = `${(remainMs / 1000).toFixed(2)}s`;
                el.bossQteFill.style.width = `${Math.round(ratio * 100)}%`;
            } else {
                el.bossQtePanel.classList.remove("show", "danger");
            }

            if (data.counterWindow > 0) {
                const ratio = clamp(data.counterWindow / Math.max(0.1, data.counterWindowMax || 0.1), 0, 1);
                el.counterWindowPanel.classList.add("show");
                el.counterWindowTime.textContent = `${data.counterWindow.toFixed(2)}s x${(data.counterBonus || 1).toFixed(2)}`;
                el.counterWindowFill.style.width = `${Math.round(ratio * 100)}%`;
            } else {
                el.counterWindowPanel.classList.remove("show");
            }
        }

        function updateStage2QteUI() {
            if (!el.stage2QtePanel) return;
            const stage = getStage();
            const data = game.stageData;
            const active = !!stage && !!data && game.mode === "playing" && stage.mechanic === "top_anchor" && Number.isFinite(data.deadline) && data.deadline > 0;
            if (!active) {
                el.stage2QtePanel.classList.remove("show", "danger");
                return;
            }

            const remainMs = Math.max(0, data.deadline - performance.now());
            const duration = Math.max(1, data.deadlineDuration || 1);
            const ratio = clamp(remainMs / duration, 0, 1);
            const isGuard = data.expectedType === "anchor";
            el.stage2QtePanel.classList.add("show");
            el.stage2QtePanel.classList.toggle("danger", remainMs <= 650);
            el.stage2QteLabel.textContent = isGuard ? "回防限時" : "踏雲限時";
            el.stage2QteKey.textContent = getKeyPromptLabel(data.expectedKey || "q");
            el.stage2QteCountdown.textContent = `${(remainMs / 1000).toFixed(2)}s`;
            el.stage2QteFill.style.width = `${Math.round(ratio * 100)}%`;
        }

        function updateLearningPanel() {
            if (!el.learningLive || !el.learningTip) return;
            const stage = getStage();
            const acc = calcAccuracy();
            const recentAcc = getRecentAccuracy();
            const stability = recentAcc >= 0.95 ? "S" : recentAcc >= 0.9 ? "A" : recentAcc >= 0.82 ? "B" : "C";

            el.learningLive.textContent = `戰況：穩定 ${stability} ｜ 正確率 ${acc}% ｜ 連擊 ${game.maxCombo}`;

            let tip = "先看字再按，保持連續節奏。";
            if (stage?.mechanic === "boss_raid") {
                if (game.stageData?.guardMode) tip = `魔王快攻！立刻按 ${game.stageData.guardKey.toUpperCase()} 防禦。`;
                else if ((game.stageData?.counterWindow || 0) > 0) tip = "反擊窗口開啟，連續輸入會更痛。";
                else if (acc < 88) tip = "魔王戰先穩命中，再慢慢加速。";
                else tip = "看到 DEFEND 先擋，擋完再一口氣輸出。";
            } else if (acc < 85) {
                tip = "先慢一點，先把正確率拉上去。";
            } else if (game.chineseMode && stage?.mechanic === "word_combo") {
                tip = game.zhModeVariant === "bopomofo"
                    ? "先看整串注音，再按對應英文鍵位。"
                    : "先看整個詞語與注音，再選字確認後輸入。";
            } else if (game.maxCombo < 10) {
                tip = "試著連續命中，連擊越高招式越強。";
            } else if (game.totalTyped < 120) {
                tip = "保持穩定輸入，累積更多有效鍵數。";
            }

            el.learningTip.textContent = `下一步：${tip}`;
        }

        function showCoach(text, duration = 1200) {
            el.coachStrip.textContent = text;
            el.coachStrip.classList.add("show");
            clearTimeout(game.coachTimer);
            game.coachTimer = setTimeout(() => {
                el.coachStrip.classList.remove("show");
            }, duration);
        }

        function recordKeyStat(key, correct) {
            if (!/^[a-z;]$/.test(key || "")) return;
            if (!game.analytics.keyStats[key]) {
                game.analytics.keyStats[key] = { hit: 0, miss: 0 };
            }
            if (correct) game.analytics.keyStats[key].hit += 1;
            else game.analytics.keyStats[key].miss += 1;
        }

        function beginWordTimer() {
            game.currentWordStart = performance.now();
        }

        function recordWordStat(word, durationMs, correct) {
            if (!word) return;
            if (!game.analytics.wordStats[word]) {
                game.analytics.wordStats[word] = { clearCount: 0, failCount: 0, totalMs: 0 };
            }
            const stat = game.analytics.wordStats[word];
            if (correct) {
                stat.clearCount += 1;
                stat.totalMs += Math.max(120, durationMs || 0);
            } else {
                stat.failCount += 1;
            }
        }

        function calculateWeakKeys(limit = 3) {
            return Object.entries(game.analytics.keyStats)
                .map(([key, stat]) => {
                    const total = stat.hit + stat.miss;
                    const missRate = total ? stat.miss / total : 0;
                    return { key, missRate, total };
                })
                .filter((item) => item.total >= 6)
                .sort((a, b) => b.missRate - a.missRate || b.total - a.total)
                .slice(0, limit)
                .map((item) => item.key);
        }

        function calculateSlowWords(limit = 3) {
            return Object.entries(game.analytics.wordStats)
                .filter(([, stat]) => stat.clearCount > 0)
                .map(([word, stat]) => ({
                    word,
                    avgMs: stat.totalMs / stat.clearCount,
                    clearCount: stat.clearCount,
                    failCount: stat.failCount
                }))
                .sort((a, b) => b.avgMs - a.avgMs || b.failCount - a.failCount)
                .slice(0, limit)
                .map((item) => item.word);
        }

        function getRecentAccuracy() {
            if (!game.sessionAttempts.length) return 1;
            const sum = game.sessionAttempts.reduce((acc, value) => acc + (value ? 1 : 0), 0);
            return sum / game.sessionAttempts.length;
        }

        function updateAdaptiveDifficulty() {
            const stage = getStage();
            if (!stage || !game.stageData) return;
            const recentAcc = getRecentAccuracy();
            let targetLevel = 1;
            if (recentAcc >= 0.985 && game.combo >= 22 && game.correctTyped >= 70) targetLevel = 4;
            else if (recentAcc >= 0.95 && game.combo >= 14) targetLevel = 3;
            else if (recentAcc >= 0.88 && game.combo >= 7) targetLevel = 2;
            else if (recentAcc < 0.72) targetLevel = 0;

            if (game.errorStreak >= 3) targetLevel = Math.max(0, targetLevel - 2);
            else if (game.errorStreak >= 2) targetLevel = Math.max(0, targetLevel - 1);

            if (game.profile.assistMode) {
                targetLevel = Math.max(0, targetLevel - 1);
            }

            game.adaptive.level = targetLevel;
            if (targetLevel === 0) {
                game.adaptive.spawnScale = 1.42;
                game.adaptive.bossDrainScale = 0.68;
                game.adaptive.wordDamageScale = 1.28;
            } else if (targetLevel === 1) {
                game.adaptive.spawnScale = 1.1;
                game.adaptive.bossDrainScale = 0.9;
                game.adaptive.wordDamageScale = 1.12;
            } else if (targetLevel === 2) {
                game.adaptive.spawnScale = 0.9;
                game.adaptive.bossDrainScale = 1.05;
                game.adaptive.wordDamageScale = 1;
            } else if (targetLevel === 3) {
                game.adaptive.spawnScale = 0.74;
                game.adaptive.bossDrainScale = 1.22;
                game.adaptive.wordDamageScale = 0.9;
            } else {
                game.adaptive.spawnScale = 0.62;
                game.adaptive.bossDrainScale = 1.34;
                game.adaptive.wordDamageScale = 0.82;
            }

            syncAdaptiveMechanicTuning(stage, game.stageData);
        }

        function getAdaptiveSpawnCap(mechanic) {
            if (mechanic === "homefall") {
                const base = game.adaptive.level >= 4 ? 7 : game.adaptive.level >= 2 ? 6 : 5;
                const errorPenalty = game.errorStreak >= 5 ? 2 : game.errorStreak >= 3 ? 1 : 0;
                return clamp(base - errorPenalty, 4, 7);
            }
            if (mechanic === "bottom_defense") {
                const base = game.adaptive.level >= 4 ? 7 : game.adaptive.level >= 2 ? 6 : 5;
                const errorPenalty = game.errorStreak >= 5 ? 2 : game.errorStreak >= 3 ? 1 : 0;
                return clamp(base - errorPenalty, 4, 7);
            }
            return 1;
        }

        function syncAdaptiveMechanicTuning(stage, data) {
            if (!stage || !data) return;

            if (stage.mechanic === "homefall") {
                const all = data.allKeys || ["a", "s", "d", "f", "j", "k", "l", ";"];
                // Keep stage 1 as full home-row practice; adaptive difficulty changes quantity/speed, not key pool.
                data.allowed = all.slice();
            } else if (stage.mechanic === "bottom_defense") {
                const all = data.allKeys || ["z", "x", "c", "v", "b", "n", "m"];
                // Keep stage 3 as full bottom-row practice; adaptive difficulty changes quantity/speed, not key pool.
                data.allowed = all.slice();
            } else if (stage.mechanic === "top_anchor") {
                const all = data.allTopKeys || ["q", "w", "e", "r", "t", "y", "u", "i", "o", "p"];
                // Keep stage 2 as full top-row practice; adaptive difficulty changes deadline/window only.
                data.topKeys = all.slice();
            }
        }

        function unlockAchievement(id, label) {
            if (game.unlockedAchievements.has(id)) return false;
            game.unlockedAchievements.add(id);
            game.profile.achievements = Array.from(game.unlockedAchievements);
            showCoach(`成就解鎖：${label}`, 1400);
            return true;
        }

        function setScene(key) {
            el.bgLayer.style.backgroundImage = `url("${SCENES[key] || SCENES.title}")`;
            const tone = SCENE_TONES[key] || SCENE_TONES.title;
            el.bgLayer.style.filter = `saturate(${tone.sat}) brightness(${tone.bright})`;
            el.bgAurora.style.opacity = String(tone.aura);
        }

        function ensureAudioUnlocked() {
            if (audio.unlocked) return;
            const bootstrap = new Audio();
            bootstrap.volume = 0;
            bootstrap.play().catch(() => {});
            audio.unlocked = true;
        }

        function playBgm(name) {
            if (!audio.unlocked) return;
            if (audio.currentBgm === name) return;
            if (audio.currentBgm && audio.bgm[audio.currentBgm]) {
                audio.bgm[audio.currentBgm].pause();
                audio.bgm[audio.currentBgm].currentTime = 0;
            }
            const track = audio.bgm[name];
            if (!track) return;
            audio.currentBgm = name;
            track.currentTime = 0;
            track.play().catch(() => {});
        }

        function playSfx(name, volume = 0.6) {
            if (!audio.unlocked || !audio.sfx[name]) return;
            const clip = new Audio(audio.sfx[name]);
            clip.volume = clamp(volume, 0, 1);
            clip.play().catch(() => {});
        }

        function setLoadingProgress(done, total, hint = "") {
            if (!el.loadingBarFill || !el.loadingCount || !el.loadingPercent || !el.loadingHint) return;
            const safeTotal = Math.max(1, total || 1);
            const ratio = clamp((done || 0) / safeTotal, 0, 1);
            el.loadingBarFill.style.width = `${Math.round(ratio * 100)}%`;
            el.loadingCount.textContent = `${Math.min(done || 0, safeTotal)} / ${safeTotal}`;
            el.loadingPercent.textContent = `${Math.round(ratio * 100)}%`;
            if (hint) el.loadingHint.textContent = hint;
        }

        function collectPreloadAssetUrls() {
            const html = String(document.documentElement?.outerHTML || "");
            const pattern = /(?:["'(])((?:assets|audio)\/[^"'()\s>]+\.(?:png|jpg|jpeg|gif|webp|mp3|wav|ogg))(?=["')\s>])/gi;
            const urls = new Set();
            let match;
            while ((match = pattern.exec(html))) {
                if (!match[1]) continue;
                urls.add(match[1]);
            }
            return Array.from(urls);
        }

        function preloadImageAsset(url, timeoutMs = 9000) {
            return new Promise((resolve) => {
                const img = new Image();
                let settled = false;
                const done = () => {
                    if (settled) return;
                    settled = true;
                    clearTimeout(timer);
                    img.onload = null;
                    img.onerror = null;
                    resolve();
                };
                const timer = setTimeout(done, timeoutMs);
                img.onload = done;
                img.onerror = done;
                img.decoding = "async";
                img.src = url;
                if (img.complete) done();
            });
        }

        function preloadAudioAsset(url, timeoutMs = 12000) {
            return new Promise((resolve) => {
                const audioProbe = new Audio();
                let settled = false;
                const done = () => {
                    if (settled) return;
                    settled = true;
                    clearTimeout(timer);
                    audioProbe.removeEventListener("canplaythrough", done);
                    audioProbe.removeEventListener("loadeddata", done);
                    audioProbe.removeEventListener("error", done);
                    audioProbe.removeEventListener("stalled", done);
                    audioProbe.removeEventListener("abort", done);
                    resolve();
                };
                const timer = setTimeout(done, timeoutMs);
                audioProbe.preload = "auto";
                audioProbe.addEventListener("canplaythrough", done, { once: true });
                audioProbe.addEventListener("loadeddata", done, { once: true });
                audioProbe.addEventListener("error", done, { once: true });
                audioProbe.addEventListener("stalled", done, { once: true });
                audioProbe.addEventListener("abort", done, { once: true });
                audioProbe.src = url;
                try {
                    audioProbe.load();
                } catch (error) {
                    done();
                }
            });
        }

        function preloadAssetByUrl(url) {
            if (/\.mp3$|\.wav$|\.ogg$/i.test(url)) return preloadAudioAsset(url);
            return preloadImageAsset(url);
        }

        async function runLoadingSequence() {
            const minLoadingMs = 2200;
            const loadingStart = performance.now();
            setLoadingProgress(0, 1, "掃描資源清單...");
            let urls = collectPreloadAssetUrls();
            const total = urls.length || 1;
            let done = 0;
            setLoadingProgress(done, total, `準備下載 ${total} 項資源...`);

            if (urls.length > 0) {
                const tasks = urls.map((url) => preloadAssetByUrl(url).finally(() => {
                    done += 1;
                    const shortName = url.split("/").slice(-2).join("/");
                    const phaseText = /audio\//i.test(url) ? "載入音效" : "載入美術";
                    setLoadingProgress(done, total, `${phaseText}：${shortName}`);
                }));
                await Promise.allSettled(tasks);
            } else {
                done = 1;
                setLoadingProgress(done, total, "資源清單為空，略過預載。");
            }

            const elapsed = performance.now() - loadingStart;
            if (elapsed < minLoadingMs) {
                setLoadingProgress(done, total, "整理戰場中...");
                await new Promise((resolve) => setTimeout(resolve, minLoadingMs - elapsed));
            }
            setLoadingProgress(total, total, "載入完成，準備進入遊戲。");
            await new Promise((resolve) => setTimeout(resolve, 220));
        }

        function showToast(message, duration = 1400) {
            el.toast.textContent = message;
            el.toast.classList.add("show");
            clearTimeout(game.toastTimer);
            game.toastTimer = setTimeout(() => el.toast.classList.remove("show"), duration);
        }

        function addScore(delta) {
            if ((!(game.independentStageMode || game.endlessBossMode)) || game.practiceMode) return;
            game.stageScore = Math.max(0, Math.round(game.stageScore + delta));
            if (Math.abs(delta) >= 28 && el.arena) {
                el.arena.classList.remove("fx-good", "fx-bad");
                void el.arena.offsetWidth;
                el.arena.classList.add(delta >= 0 ? "fx-good" : "fx-bad");
            }
            if (delta >= 90 && el.topHud) {
                el.topHud.classList.remove("fx-score");
                void el.topHud.offsetWidth;
                el.topHud.classList.add("fx-score");
            }
        }

        function calcAccuracy() {
            if (game.totalTyped <= 0) return 100;
            return Math.max(0, Math.round((game.correctTyped / game.totalTyped) * 100));
        }

        function splitChars(text) {
            return Array.from(text || "");
        }

        function getTokenText(token) {
            if (token && typeof token === "object") return String(token.text || "");
            return String(token || "");
        }

        function getTokenPhonetic(token) {
            if (token && typeof token === "object") return String(token.phonetic || "");
            return "";
        }

        function getTokenInputText(token) {
            if (token && typeof token === "object") return String(token.input || "");
            return "";
        }

        function getTokenLength(token) {
            return splitChars(getTokenText(token)).length;
        }

        function normalizeChar(char) {
            if (!char) return "";
            const trimmed = char.trim();
            if (!trimmed) return "";
            if (/^[A-Z]$/.test(trimmed)) return trimmed.toLowerCase();
            if (/^[a-z;]$/.test(trimmed)) return trimmed;
            return "";
        }

        function normalizeBopomofoKey(char) {
            if (!char) return "";
            const key = String(char);
            if (key.length !== 1) return "";
            if (/^[A-Z]$/.test(key)) return key.toLowerCase();
            if (/^[a-z0-9,./;\-]$/.test(key)) return key;
            return "";
        }

        function getPhysicalKeyFromCode(code) {
            if (!code) return "";
            if (/^Key[A-Z]$/.test(code)) return code.slice(3).toLowerCase();
            if (/^Digit[0-9]$/.test(code)) return code.slice(5);
            if (code === "Semicolon") return ";";
            if (code === "Comma") return ",";
            if (code === "Period") return ".";
            if (code === "Slash") return "/";
            if (code === "Minus") return "-";
            return "";
        }

        function getGameplayRawKey(event) {
            const byCode = getPhysicalKeyFromCode(event?.code);
            if (byCode) return byCode;
            return event?.key && event.key.length === 1 ? event.key : "";
        }

        function getKeyVisualLabel(key) {
            const stage = getStage();
            if (!game.chineseMode || !stage) {
                return String(key || "").toUpperCase();
            }
            const rowMechanic = stage.mechanic === "homefall" || stage.mechanic === "top_anchor" || stage.mechanic === "bottom_defense";
            if (!rowMechanic) return String(key || "").toUpperCase();
            const mapped = BOPOMOFO_LABEL_BY_KEY[String(key || "").toLowerCase()];
            return mapped || String(key || "").toUpperCase();
        }

        function getKeyPromptLabel(key) {
            const raw = String(key || "").toUpperCase();
            const visual = getKeyVisualLabel(key);
            if (!game.chineseMode) return raw;
            if (!visual || String(visual).toUpperCase() === raw) return raw;
            return `${visual} (${raw})`;
        }

        function tokenToDisplay(token) {
            return getTokenText(token);
        }

        function setCurrentWordToken(data, rawToken) {
            data.currentToken = rawToken;
            data.currentWord = getTokenText(rawToken);
            data.currentPhonetic = getTokenPhonetic(rawToken);
            data.currentInputWord = getTokenInputText(rawToken) || getTokenText(rawToken);
            data.progress = 0;
            if (el.imeInput) el.imeInput.value = "";
            game.imeLastHandledValue = "";
            game.imeLastHandledAt = 0;
            beginWordTimer();
            renderPromptForStage();
        }

        function applyStageVisual(stageId) {
            const visual = STAGE_VISUALS[stageId] || STAGE_VISUALS[1];
            const root = document.documentElement.style;
            root.setProperty("--stage-glow", visual.glow);
            root.setProperty("--stage-spark", visual.spark);
            root.setProperty("--stage-shadow", visual.shadow);
            root.setProperty("--stage-heat", visual.heat);
        }

        function buildAmbientSparks(count = 26) {
            const pieces = [];
            for (let i = 0; i < count; i += 1) {
                const x = `${Math.random() * 100}%`;
                const size = `${4 + Math.random() * 8}px`;
                const dur = `${8 + Math.random() * 9}s`;
                const delay = `${Math.random() * 4}s`;
                const drift = `${(Math.random() - 0.5) * 180}px`;
                pieces.push(`<span class="ambient-spark" style="--x:${x};--size:${size};--dur:${dur};--delay:${delay};--drift:${drift};"></span>`);
            }
            el.arenaAmbient.innerHTML = pieces.join("");
        }

        function triggerFeedbackFlash(strength = 1) {
            clearTimeout(game.feedbackTimer);
            el.feedbackFlash.style.opacity = String(clamp(0.4 + strength * 0.35, 0, 1));
            el.feedbackFlash.classList.add("on");
            game.feedbackTimer = setTimeout(() => {
                el.feedbackFlash.classList.remove("on");
                el.feedbackFlash.style.opacity = "";
            }, 140);
        }

        function triggerArenaShake(power = 1) {
            if (!el.arena) return;
            const heavy = power >= 1.18;
            const cls = heavy ? "shake-heavy" : "shake-light";
            el.arena.classList.remove("shake-light", "shake-heavy");
            void el.arena.offsetWidth;
            el.arena.classList.add(cls);
            clearTimeout(game.arenaShakeTimer);
            game.arenaShakeTimer = setTimeout(() => {
                el.arena.classList.remove("shake-light", "shake-heavy");
            }, heavy ? 360 : 240);
        }

        function pulseHitLine(power = 1) {
            if (!el.hitLine) return;
            el.hitLine.classList.remove("impact");
            el.hitLine.style.borderTopWidth = `${Math.round(clamp(2 + power * 0.8, 2, 4))}px`;
            void el.hitLine.offsetWidth;
            el.hitLine.classList.add("impact");
            clearTimeout(game.hitLineTimer);
            game.hitLineTimer = setTimeout(() => {
                el.hitLine.classList.remove("impact");
                el.hitLine.style.borderTopWidth = "";
            }, 170);
        }

        function isChineseTypingStage() {
            if (!game.chineseMode || game.inputLocale !== "zh") return false;
            if (game.zhModeVariant !== "hanzi") return false;
            const stage = getStage();
            if (!stage || !game.stageData) return false;
            if (game.mode !== "playing") return false;
            if (stage.mechanic === "word_combo") return true;
            if (stage.mechanic === "boss_raid") return !game.stageData.guardMode;
            return false;
        }

        function updateImePanelHint() {
            if (!el.imeHint || !el.imeInput) return;
            const stage = getStage();
            const data = game.stageData;
            if (!isChineseTypingStage() || !stage || !data) {
                el.imeTitle.textContent = game.zhModeVariant === "bopomofo" ? "純注音模式（直接按英文鍵位）" : "中打模式（注音選字）";
                el.imeHint.textContent = game.zhModeVariant === "bopomofo"
                    ? "純注音模式不使用輸入框，請直接看符號按鍵。"
                    : "請用注音輸入法輸入，選字後會自動判定。";
                return;
            }
            el.imeTitle.textContent = "中打模式（注音選字）";
            const target = getTokenText(data.currentToken || data.currentWord);
            const phonetic = getTokenPhonetic(data.currentToken || data.currentWord);
            const typed = el.imeInput.value || "";
            const stageHintPrefix = stage.mechanic === "boss_raid" ? "Boss字詞" : "目標";
            if (game.imeComposing && game.imeDraftText) {
                el.imeHint.textContent = `選字中：${game.imeDraftText} ｜ ${stageHintPrefix}注音：${phonetic || "（無）"}`;
            } else if (typed) {
                el.imeHint.textContent = `已輸入：${typed} ｜ ${stageHintPrefix}：${target}${phonetic ? `（${phonetic}）` : ""}`;
            } else {
                el.imeHint.textContent = `${stageHintPrefix}注音：${phonetic || "（請直接輸入）"}`;
            }
        }

        function syncImeInputVisibility() {
            if (!el.imePanel || !el.imeInput) return;
            const active = isChineseTypingStage();
            el.imePanel.classList.toggle("show", active);
            if (!active) {
                if (document.activeElement === el.imeInput) el.imeInput.blur();
                if (el.imeInput.value && game.mode !== "playing") el.imeInput.value = "";
                game.imeDraftText = "";
                game.imeComposing = false;
                updateImePanelHint();
                return;
            }
            updateImePanelHint();
            if (game.mode === "playing" && document.activeElement !== el.imeInput) {
                try {
                    el.imeInput.focus({ preventScroll: true });
                } catch (error) {
                    el.imeInput.focus();
                }
            }
        }

        function updateHud() {
            const hpRatio = game.playerHp / game.maxPlayerHp;
            const enemyRatio = game.maxEnemyHp ? game.enemyHp / game.maxEnemyHp : 0;
            const qiRatio = game.qi / game.maxQi;

            el.hpFill.style.width = `${Math.round(hpRatio * 100)}%`;
            el.enemyFill.style.width = `${Math.round(enemyRatio * 100)}%`;
            el.qiFill.style.width = `${Math.round(qiRatio * 100)}%`;

            el.hpText.textContent = `${Math.ceil(game.playerHp)}/${game.maxPlayerHp}`;
            el.enemyText.textContent = game.mode === "playing" || game.mode === "dialogue" || game.mode === "transition"
                ? `${Math.ceil(game.enemyHp)}/${game.maxEnemyHp}`
                : "--";
            el.qiText.textContent = `${Math.round(game.qi)}/${game.maxQi}`;

            el.metricAcc.textContent = `${calcAccuracy()}%`;
            el.metricMaxCombo.textContent = game.maxCombo;
            el.metricScoreLabel.textContent = game.endlessBossMode ? "無盡分數" : "分數";
            el.metricDefeated.textContent = Math.round(game.stageScore);
            el.metricTyped.textContent = game.totalTyped;
            el.heroWrap.classList.toggle("charged", game.combo >= 10 || game.qi >= 85);
            el.btnPause.style.display = (game.mode === "playing" || game.mode === "paused") ? "inline-block" : "none";
            updateLearningPanel();
            updateStage2QteUI();
            updateBossQteUI();
        }

        function updateStageTrack() {
            Array.from(el.stageTrack.querySelectorAll("[data-stage-node]")).forEach((node) => {
                const idx = Number(node.getAttribute("data-stage-node"));
                node.classList.toggle("active", idx === game.stageIndex && !["title", "stage-select"].includes(game.mode));
                if (game.independentStageMode && !game.practiceMode) {
                    const rec = getStageRecord(idx + 1);
                    node.classList.toggle("done", (rec.bestStars || 0) > 0);
                } else {
                    node.classList.toggle("done", idx < game.stageIndex);
                }
            });
        }

        function setEnemy(monsterId) {
            const info = MONSTERS[monsterId] || MONSTERS.placeholder_monster;
            game.currentMonster = monsterId;
            el.enemyWrap.classList.remove("ending-vanish", "idle-hover", "flicker", "phase-blink");
            game.enemyAmbientFxTimer = 0.45 + Math.random() * 0.8;
            el.enemySprite.src = info.src;
            el.enemySprite.alt = info.name;
            Array.from(el.monsterRail.querySelectorAll("img")).forEach((img) => {
                img.classList.toggle("active", img.getAttribute("data-monster-id") === monsterId);
            });
            if (game.mode === "playing") {
                el.enemyWrap.classList.add("hit");
                setTimeout(() => el.enemyWrap.classList.remove("hit"), 120);
            }
        }

        function triggerEnemyAmbientFx() {
            if (!el.enemyWrap) return;
            if (game.mode !== "playing") return;
            if (el.enemyWrap.classList.contains("ending-vanish")) return;
            const stage = getStage();
            const isBoss = !!stage && stage.mechanic === "boss_raid";
            const roll = Math.random();
            let cls = "idle-hover";
            if (roll > (isBoss ? 0.58 : 0.78)) cls = "phase-blink";
            else if (roll > (isBoss ? 0.28 : 0.52)) cls = "flicker";
            el.enemyWrap.classList.remove("idle-hover", "flicker", "phase-blink");
            void el.enemyWrap.offsetWidth;
            el.enemyWrap.classList.add(cls);
            setTimeout(() => {
                el.enemyWrap.classList.remove(cls);
            }, cls === "idle-hover" ? 1200 : cls === "phase-blink" ? 340 : 240);
        }

        function updateEnemyAmbientFx(dt) {
            if (!el.enemyWrap) return;
            if (!["playing", "dialogue", "transition"].includes(game.mode)) return;
            game.enemyAmbientFxTimer -= dt;
            if (game.enemyAmbientFxTimer > 0) return;
            const stage = getStage();
            const bossBonus = stage?.mechanic === "boss_raid" ? -0.45 : 0;
            game.enemyAmbientFxTimer = 1.15 + Math.random() * 1.55 + bossBonus;
            if (game.enemyAmbientFxTimer < 0.4) game.enemyAmbientFxTimer = 0.4;
            triggerEnemyAmbientFx();
        }

        function rotateEnemyFromPool(pool) {
            if (!pool || pool.length === 0) return;
            const candidate = pick(pool);
            if (candidate !== game.currentMonster || pool.length === 1) {
                setEnemy(candidate);
            }
        }

        function renderMonsterRail(pool) {
            el.monsterRail.innerHTML = pool.map((id) => {
                const info = MONSTERS[id];
                return `<img data-monster-id="${id}" src="${info.src}" alt="${info.name}" title="${info.name}" class="${id === game.currentMonster ? "active" : ""}">`;
            }).join("");
        }

        function setHeroState(state, lockMs = 200) {
            game.heroState = state;
            game.heroStateLockUntil = performance.now() + lockMs;
            if (state === "jump") el.heroWrap.classList.add("jump");
            else el.heroWrap.classList.remove("jump");
            if (state === "Injuried") {
                el.heroWrap.classList.add("hit");
                setTimeout(() => el.heroWrap.classList.remove("hit"), 170);
            }
        }

        function updateHeroAnimation(dtMs) {
            game.heroFrameClock += dtMs;
            const interval = HERO_FRAME_INTERVAL[game.heroState] || 150;
            if (game.heroFrameClock >= interval) {
                game.heroFrameClock = 0;
                game.heroFrame = (game.heroFrame + 1) % 4;
                const frames = HERO_FRAMES[game.heroState] || HERO_FRAMES.stand;
                el.heroSprite.src = frames[game.heroFrame];
            }
            if (game.mode === "playing" && performance.now() > game.heroStateLockUntil && game.heroState !== "stand") {
                game.heroState = "stand";
                el.heroWrap.classList.remove("jump");
            }
        }

        function addFloatMessage(message, x, y, color = "#ffe5a0") {
            const node = document.createElement("div");
            node.className = "float-msg";
            node.textContent = message;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            node.style.color = color;
            el.effectLayer.appendChild(node);
            setTimeout(() => node.remove(), 920);
        }

        function getArenaAnchors() {
            const rect = el.arena.getBoundingClientRect();
            return {
                heroX: Math.max(92, rect.width * 0.17),
                heroY: Math.max(170, rect.height - 90),
                enemyX: Math.min(rect.width - 92, rect.width * 0.83),
                enemyY: Math.max(170, rect.height - 98)
            };
        }

        function spawnFx(className, x, y, ttl = 520, customStyle = {}) {
            if (!game.fxPool[className]) game.fxPool[className] = [];
            const node = game.fxPool[className].pop() || document.createElement("div");
            node.className = className;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            node.style.cssText = `left:${x}px;top:${y}px;`;
            Object.entries(customStyle).forEach(([key, value]) => node.style.setProperty(key, value));
            el.effectLayer.appendChild(node);
            setTimeout(() => {
                node.remove();
                game.fxPool[className].push(node);
            }, ttl);
        }

        function spawnSlashWave(strength = 1) {
            const pos = getArenaAnchors();
            spawnFx("slash-wave", pos.enemyX - 18, pos.enemyY - 58, 560, {
                width: `${Math.round(170 + strength * 34)}px`,
                opacity: `${clamp(0.68 + strength * 0.2, 0.5, 1)}`
            });
        }

        function spawnJumpBurst() {
            const pos = getArenaAnchors();
            spawnFx("jump-burst", pos.heroX + 34, pos.heroY - 92, 520);
        }

        function spawnDashStreak() {
            const pos = getArenaAnchors();
            spawnFx("dash-streak", pos.heroX + 58, pos.heroY - 28, 420);
        }

        function spawnGuardRing() {
            const pos = getArenaAnchors();
            spawnFx("guard-ring", pos.heroX + 28, pos.heroY - 52, 540);
        }

        function spawnEnemySpark(scale = 1, mode = "normal", target = "enemy") {
            const pos = getArenaAnchors();
            const style = {
                width: `${Math.round(170 * scale)}px`,
                height: `${Math.round(170 * scale)}px`
            };
            if (mode === "damage") {
                style.filter = "hue-rotate(-60deg) saturate(1.2)";
                style.opacity = "0.9";
            }
            const x = target === "hero" ? pos.heroX + 20 : pos.enemyX;
            const y = target === "hero" ? pos.heroY - 46 : pos.enemyY - 12;
            spawnFx("enemy-spark", x, y, 460, style);
        }

        function spawnImpactBurst(power = 1, target = "enemy") {
            const pos = getArenaAnchors();
            const p = clamp(power, 0.7, 2.1);
            const x = target === "hero" ? pos.heroX + 20 : pos.enemyX - 4;
            const y = target === "hero" ? pos.heroY - 46 : pos.enemyY - 44;
            spawnFx("impact-burst", x, y, 360, {
                width: `${Math.round(108 + p * 44)}px`,
                height: `${Math.round(108 + p * 44)}px`,
                opacity: `${clamp(0.75 + p * 0.12, 0.6, 1)}`
            });
            spawnFx("impact-ring", x, y, 440, {
                width: `${Math.round(122 + p * 48)}px`,
                height: `${Math.round(122 + p * 48)}px`,
                opacity: `${clamp(0.72 + p * 0.12, 0.55, 1)}`
            });
        }

        function spawnTeleportRift(x, y, power = 1, warm = false) {
            const p = clamp(power, 0.7, 2);
            spawnFx("teleport-rift", x, y, 340, {
                width: `${Math.round(26 + p * 12)}px`,
                height: `${Math.round(112 + p * 42)}px`,
                background: warm
                    ? "linear-gradient(180deg, rgba(255,215,150,0), rgba(255,215,150,0.96), rgba(255,129,129,0.92), rgba(255,215,150,0))"
                    : "linear-gradient(180deg, rgba(179,255,247,0), rgba(179,255,247,0.95), rgba(255,236,172,0.92), rgba(179,255,247,0))"
            });
        }

        function spawnChargeAura(type = "charge", power = 1) {
            const pos = getArenaAnchors();
            const p = clamp(power, 0.7, 1.9);
            const x = pos.heroX + 28;
            const y = pos.heroY - 58;
            const palette = type === "jump"
                ? {
                    border: "rgba(165, 234, 255, 0.92)",
                    glow: "rgba(129, 222, 255, 0.54)",
                    bg: "radial-gradient(circle, rgba(165, 234, 255, 0.24), rgba(165, 234, 255, 0))",
                    glyph: "rgba(211, 245, 255, 0.95)",
                    hue: "hue-rotate(10deg)"
                }
                : type === "defense"
                    ? {
                        border: "rgba(138, 255, 244, 0.92)",
                        glow: "rgba(91, 245, 236, 0.56)",
                        bg: "radial-gradient(circle, rgba(132, 255, 246, 0.2), rgba(132, 255, 246, 0))",
                        glyph: "rgba(168, 255, 252, 0.95)",
                        hue: "hue-rotate(58deg)"
                    }
                    : type === "attack"
                        ? {
                            border: "rgba(255, 233, 169, 0.92)",
                            glow: "rgba(255, 190, 114, 0.56)",
                            bg: "radial-gradient(circle, rgba(255, 228, 158, 0.22), rgba(255, 228, 158, 0))",
                            glyph: "rgba(255, 243, 194, 0.95)",
                            hue: "hue-rotate(-18deg)"
                        }
                        : {
                            border: "rgba(140, 255, 214, 0.86)",
                            glow: "rgba(140, 255, 214, 0.48)",
                            bg: "radial-gradient(circle, rgba(140, 255, 214, 0.22), rgba(140, 255, 214, 0))",
                            glyph: "rgba(255, 236, 174, 0.92)",
                            hue: "none"
                        };

            spawnFx("charge-aura", x, y, 520, {
                width: `${Math.round(108 + p * 34)}px`,
                height: `${Math.round(108 + p * 34)}px`,
                border: `2px solid ${palette.border}`,
                background: palette.bg,
                "box-shadow": `0 0 ${Math.round(18 + p * 10)}px ${palette.glow}`,
                opacity: `${clamp(0.68 + p * 0.12, 0.6, 1)}`
            });
            spawnFx("charge-glyph", x + (Math.random() * 12 - 6), y - 10, 620, {
                width: `${Math.round(72 + p * 16)}px`,
                height: `${Math.round(72 + p * 16)}px`,
                border: `1px dashed ${palette.glyph}`,
                filter: palette.hue,
                opacity: `${clamp(0.75 + p * 0.12, 0.6, 1)}`
            });
        }

        function triggerTeleportStrike(power = 1, label = "瞬斬") {
            const pos = getArenaAnchors();
            const p = clamp(power, 0.8, 1.9);
            const arenaRect = el.arena.getBoundingClientRect();
            const heroRect = el.heroWrap.getBoundingClientRect();
            const enemyRect = el.enemyWrap.getBoundingClientRect();
            const heroCenterX = (heroRect.left - arenaRect.left) + heroRect.width * 0.5;
            const heroCenterY = (heroRect.top - arenaRect.top) + heroRect.height * 0.58;
            const enemyStrikeX = (enemyRect.left - arenaRect.left) + enemyRect.width * 0.34;
            const enemyStrikeY = (enemyRect.top - arenaRect.top) + enemyRect.height * 0.64;
            const rawDx = enemyStrikeX - heroCenterX;
            const rawDy = enemyStrikeY - heroCenterY;
            const dx = clamp(rawDx, 92, Math.max(160, arenaRect.width - 220));
            const dy = clamp(rawDy * 0.22, -26, 20);
            el.heroWrap.style.setProperty("--tp-dx", `${Math.round(dx)}px`);
            el.heroWrap.style.setProperty("--tp-dy", `${Math.round(dy)}px`);
            el.heroWrap.style.setProperty("--tp-scale", `${(1.03 + p * 0.06).toFixed(2)}`);
            el.heroWrap.classList.remove("teleport-strike");
            void el.heroWrap.offsetWidth;
            el.heroWrap.classList.add("teleport-strike");
            setTimeout(() => el.heroWrap.classList.remove("teleport-strike"), 360);

            spawnTeleportRift(pos.heroX + 26, pos.heroY - 58, p, false);
            spawnTeleportRift(pos.enemyX - 10, pos.enemyY - 54, p * 1.06, true);
            spawnFx("teleport-blink", pos.heroX + 26, pos.heroY - 58, 320, {
                width: `${Math.round(120 + p * 42)}px`,
                height: `${Math.round(120 + p * 42)}px`,
                background: "radial-gradient(circle, rgba(207,255,246,0.56), rgba(102,232,255,0.24), rgba(102,232,255,0))"
            });
            spawnFx("teleport-blink", pos.enemyX - 10, pos.enemyY - 54, 360, {
                width: `${Math.round(128 + p * 56)}px`,
                height: `${Math.round(128 + p * 56)}px`,
                background: "radial-gradient(circle, rgba(255,245,194,0.62), rgba(132,255,226,0.26), rgba(132,255,226,0))"
            });
            spawnFx("dash-streak", (pos.heroX + pos.enemyX) * 0.5, pos.enemyY - 40, 320, {
                width: `${Math.round(160 + p * 70)}px`,
                height: `${Math.round(18 + p * 4)}px`,
                background: "linear-gradient(90deg, rgba(255,255,255,0), rgba(209,255,247,0.92), rgba(255,238,174,0.95), rgba(255,255,255,0))",
                filter: "blur(0.8px)"
            });
            spawnSlashWave(1.1 + p * 0.22);
            spawnEnemySpark(1 + p * 0.18);
            spawnImpactBurst(1 + p * 0.28, "enemy");
            pulseHitLine(1 + p * 0.4);
            triggerArenaShake(0.95 + p * 0.35);
            addFloatMessage(label, pos.enemyX - 34, pos.enemyY - 72, "#fff1bb");
        }

        function showCombo(text) {
            el.comboFloat.textContent = text;
            el.comboFloat.classList.remove("show");
            void el.comboFloat.offsetWidth;
            el.comboFloat.classList.add("show");
        }

        function showStageClearFx() {
            el.stageClearFx.classList.remove("play");
            void el.stageClearFx.offsetWidth;
            el.stageClearFx.classList.add("play");
        }

        function cleanupVictoryScene() {
            el.heroWrap.classList.remove("ending-sheath", "ending-turn", "ending-breath");
            el.enemyWrap.classList.remove("ending-vanish");
            el.victorySkipTip.classList.remove("show");
        }

        function clearVictoryCinematicTimers() {
            if (!game.victoryCinematic || !Array.isArray(game.victoryCinematic.timers)) return;
            game.victoryCinematic.timers.forEach((id) => clearTimeout(id));
            game.victoryCinematic.timers = [];
        }

        function scheduleVictoryCinematic(ms, fn) {
            const id = setTimeout(fn, ms);
            game.victoryCinematic.timers.push(id);
        }

        function recordAttempt(correct) {
            game.totalTyped += 1;
            if (correct) game.correctTyped += 1;
            game.sessionAttempts.push(!!correct);
            if (game.sessionAttempts.length > 30) game.sessionAttempts.shift();
            if (correct) {
                game.errorStreak = 0;
            } else {
                game.errorStreak = Math.min(8, (game.errorStreak || 0) + 1);
                game.stageMisses += 1;
                game.stagePerfect = false;
            }
            updateAdaptiveDifficulty();
        }

        function gainCombo(qiGain = 3) {
            game.combo += 1;
            game.maxCombo = Math.max(game.maxCombo, game.combo);
            game.qi = clamp(game.qi + qiGain, 0, game.maxQi);
            if (game.combo > 0 && game.combo % 15 === 0) {
                playSfx("crit", 0.72);
                playSfx("buff", 0.45);
                showCombo(`連擊 ${game.combo}！`);
            }
        }

        function breakCombo() {
            game.combo = 0;
        }

        function damageEnemy(amount) {
            if (amount <= 0) return;
            game.enemyHp = Math.max(0, game.enemyHp - amount);
            el.enemyWrap.classList.add("hit");
            setTimeout(() => el.enemyWrap.classList.remove("hit"), 120);
            if (game.enemyHp <= 0) {
                if (isTimedChallengeActive()) {
                    addScore(140 + Math.min(80, game.combo * 4));
                }
                clearCurrentStage();
            }
        }

        function damagePlayer(amount, reason = "") {
            game.playerHp = Math.max(0, game.playerHp - amount);
            if (reason) showToast(reason, 1000);
            if (game.playerHp <= 0) {
                if (game.endlessBossMode) {
                    game.stageMisses += 1;
                    game.stagePerfect = false;
                    game.playerHp = 0;
                    game.mode = "transition";
                    playSfx("lose", 0.78);
                    showCoach("魔王模式結束，正在結算連戰分數。", 900);
                    openResultScreen(true, "endless-defeat");
                    return;
                }
                if (isTimedChallengeActive()) {
                    game.stageMisses += 1;
                    game.stagePerfect = false;
                    addScore(-220);
                    game.playerHp = Math.round(game.maxPlayerHp * 0.72);
                    showCoach("倒地扣分，已回復氣血繼續挑戰。", 980);
                    playSfx("debuff", 0.45);
                    return;
                }
                failStage(reason || "氣血耗盡");
            }
        }

        function triggerHeroLeap() {
            el.heroWrap.classList.remove("leap");
            void el.heroWrap.offsetWidth;
            el.heroWrap.classList.add("leap");
            setTimeout(() => el.heroWrap.classList.remove("leap"), 520);
            spawnChargeAura("jump", 1.08);
            spawnJumpBurst();
            spawnDashStreak();
        }

        function triggerHeroDash() {
            el.heroWrap.classList.remove("dash");
            void el.heroWrap.offsetWidth;
            el.heroWrap.classList.add("dash");
            setTimeout(() => el.heroWrap.classList.remove("dash"), 290);
            spawnChargeAura("attack", 0.86);
            spawnDashStreak();
            pulseHitLine(0.8);
        }

        function triggerGuardBurst() {
            el.heroWrap.classList.add("guard");
            setTimeout(() => el.heroWrap.classList.remove("guard"), 220);
            triggerFeedbackFlash(0.85);
            spawnChargeAura("defense", 1.06);
            spawnGuardRing();
            spawnImpactBurst(0.86, "hero");
            pulseHitLine(0.72);
        }

        function triggerEnemyCast() {
            el.enemyWrap.classList.add("cast");
            setTimeout(() => el.enemyWrap.classList.remove("cast"), 280);
            spawnEnemySpark(0.78);
            const pos = getArenaAnchors();
            spawnTeleportRift(pos.enemyX - 8, pos.enemyY - 52, 0.82, true);
        }

        function softMistake(reason = "再試一次，你可以的！") {
            breakCombo();
            playSfx("wrong", 0.32);
            addScore(-12);
            showToast(reason, 780);
        }

        function useGraceShield(reason) {
            const data = game.stageData;
            if (!data || typeof data.graceLeft !== "number" || data.graceLeft <= 0) return false;
            data.graceLeft -= 1;
            breakCombo();
            addScore(-8);
            playSfx("shield", 0.46);
            spawnGuardRing();
            showCoach(`護體成功：${reason}（剩 ${data.graceLeft}）`, 1000);
            showToast(`護體抵消失誤，剩餘 ${data.graceLeft}`, 820);
            return true;
        }

        function punishWithProtection({ hpLoss = 2, reason = "", debuff = false, countMistake = true } = {}) {
            if (countMistake) {
                game.stageMisses += 1;
                game.stagePerfect = false;
                game.errorStreak = Math.min(8, (game.errorStreak || 0) + 1);
                updateAdaptiveDifficulty();
            }
            if (useGraceShield(reason || "穩住節奏")) return true;
            punishAction({ hpLoss, reason, debuff });
            return false;
        }

        function rewardAction({ enemyDamage = 0, qiGain = 3, hero = "attack", sfx = "correct", message = "", heal = 0.7 } = {}) {
            gainCombo(qiGain);
            addScore(18 + enemyDamage * 9 + Math.min(32, game.combo * 1.3));
            setHeroState(hero, 180);
            playSfx(sfx, 0.62);
            playSfx("playerAttack", 0.45);
            damageEnemy(enemyDamage);
            game.playerHp = Math.min(game.maxPlayerHp, game.playerHp + heal);
            triggerFeedbackFlash(0.95);
            const slashStrength = hero === "attack" ? 1.12 : hero === "run" ? 1 : hero === "defense" ? 0.86 : 0.9;
            spawnSlashWave(slashStrength);
            spawnEnemySpark(1);
            if (enemyDamage > 0) {
                spawnImpactBurst(0.86 + enemyDamage * 0.1, "enemy");
                pulseHitLine(0.88 + enemyDamage * 0.08);
                triggerArenaShake(enemyDamage >= 2 ? 1.08 : 0.92);
            }
            if (hero === "attack") spawnChargeAura("attack", 1.02);
            if (hero === "jump") spawnChargeAura("jump", 1.02);
            if (hero === "defense") spawnChargeAura("defense", 1.08);
            if (hero === "run") triggerHeroDash();
            if (hero === "defense") spawnGuardRing();
            if (enemyDamage >= 2.2 && hero !== "defense" && !/雲爆/.test(message || "")) {
                triggerTeleportStrike(0.92 + enemyDamage * 0.1, hero === "run" ? "瞬步反擊" : "瞬斬");
            }
            const tag = hero === "jump" ? "踏雲" : hero === "defense" ? "格擋" : hero === "run" ? "回防" : "命中";
            addFloatMessage(tag, 148, 298, "#a5ffd7");
            el.promptMain.classList.add("pulse-good");
            setTimeout(() => el.promptMain.classList.remove("pulse-good"), 220);
            if (message) showCombo(message);
        }

        function punishAction({ hpLoss = 3, reason = "", sfx = "wrong", debuff = false } = {}) {
            breakCombo();
            addScore(-(24 + hpLoss * 6));
            setHeroState("Injuried", 280);
            playSfx(sfx, 0.68);
            playSfx("monsterAttack", 0.48);
            if (debuff) playSfx("debuff", 0.52);
            spawnEnemySpark(0.85, "damage", "hero");
            spawnImpactBurst(0.95 + hpLoss * 0.08, "hero");
            triggerArenaShake(0.96 + hpLoss * 0.1);
            const pos = getArenaAnchors();
            spawnFx("guard-ring", pos.heroX + 22, pos.heroY - 50, 420, {
                border: "3px solid rgba(255, 132, 132, 0.9)",
                background: "radial-gradient(circle, rgba(255, 132, 132, 0.2), rgba(255, 132, 132, 0))"
            });
            damagePlayer(hpLoss, reason);
        }

        function renderPromptForStage() {
            const stage = getStage();
            const data = game.stageData;
            if (!stage || !data) {
                if (el.objectiveGuide) el.objectiveGuide.innerHTML = "";
                return;
            }

            if (el.promptBoard) {
                const compact = stage.mechanic === "homefall" || stage.mechanic === "top_anchor" || stage.mechanic === "bottom_defense";
                el.promptBoard.classList.toggle("compact", compact);
            }
            const promptStageMap = {
                homefall: game.chineseMode ? "基準鍵聚氣・注音符斬" : "基準鍵聚氣・符文斬",
                top_anchor: game.chineseMode ? "踏雲回防・注音雲爆" : "踏雲回防・雲爆反擊",
                bottom_defense: game.chineseMode ? "下盤格擋・注音反震" : "下盤格擋・反震劍波",
                word_combo: game.chineseMode ? (game.zhModeVariant === "bopomofo" ? "純注音鍵位・連段" : "注音選字・詞語連段") : "完整單字・連段劍氣",
                boss_raid: game.chineseMode ? (game.zhModeVariant === "bopomofo" ? "魔王攻守戰・注音斬陣" : "魔王攻守戰・中字斬陣") : "魔王攻守戰"
            };
            const stageLabel = promptStageMap[stage.mechanic] || stage.subtitle || "";
            el.promptStage.textContent = stage.mechanic === "boss_raid"
                ? `${game.endlessBossMode ? "魔王模式・無盡連戰" : `${stageLabel}${game.bossChallengeMode ? " ｜ 長戰挑戰" : ""}`} ｜ Phase ${data.phase || 1}`
                : stageLabel;
            el.promptSub.textContent = "";
            el.wordProgress.textContent = "";
            el.promptMain.style.fontSize = "";

            if (stage.mechanic === "homefall") {
                el.promptMain.textContent = data.allowed.map((key) => getKeyVisualLabel(key)).join(" ");
            } else if (stage.mechanic === "top_anchor") {
                if (data.expectedType === "anchor") {
                    el.promptMain.textContent = `回防 ${getKeyPromptLabel(data.expectedKey)}`;
                } else {
                    el.promptMain.textContent = getKeyPromptLabel(data.expectedKey);
                }
            } else if (stage.mechanic === "bottom_defense") {
                el.promptMain.textContent = (data.allowed || ["z", "x", "c", "v", "b", "n", "m"]).map((key) => getKeyVisualLabel(key)).join(" ");
            } else if (stage.mechanic === "word_combo") {
                el.promptMain.textContent = tokenToDisplay(data.currentWord);
                el.promptMain.style.fontSize = game.chineseMode && getTokenLength(data.currentWord) >= 8
                    ? "clamp(20px, 2.3vw, 34px)"
                    : "";
                const progressHtml = renderWordProgress(data.currentWord, data.progress);
                const phonetic = game.chineseMode ? getTokenPhonetic(data.currentToken || data.currentWord) : "";
                const hintPrefix = game.chineseMode && game.zhModeVariant === "bopomofo" ? "字詞：" : "";
                el.wordProgress.innerHTML = phonetic
                    ? `${progressHtml}<br><span class="phonetic-hint">${hintPrefix}${phonetic}</span>`
                    : progressHtml;
            } else if (stage.mechanic === "boss_raid") {
                if (data.guardMode) {
                    el.promptMain.textContent = `DEFEND ${data.guardKey.toUpperCase()}`;
                    el.wordProgress.innerHTML = `<span class="current">防禦時機</span>`;
                } else {
                    el.promptMain.textContent = tokenToDisplay(data.currentWord);
                    const progressHtml = renderWordProgress(data.currentWord, data.progress);
                    const phonetic = game.chineseMode ? getTokenPhonetic(data.currentToken || data.currentWord) : "";
                    el.wordProgress.innerHTML = phonetic
                        ? `${progressHtml}<br><span class="phonetic-hint">${phonetic}</span>`
                        : progressHtml;
                }
            }

            renderActionGuide(stage, data);
            updateBossQteUI();
        }

        function renderWordProgress(word, progress) {
            return splitChars(word).map((char, index) => {
                if (index < progress) return `<span class="done">${char}</span>`;
                if (index === progress) return `<span class="current">${char}</span>`;
                return `<span>${char}</span>`;
            }).join("");
        }

        function updateObjectiveUI() {
            const stage = getStage();
            const data = game.stageData;
            if (!stage || !data) return;

            el.objectiveMain.textContent = stage.objectiveText || "看字出招，穩定輸入。";

            let progressText = "";
            let ratio = 0;

            if (stage.mechanic === "homefall") {
                progressText = `聚氣斬 ${data.cleared}/${data.target} ｜ 集氣 ${data.charge}/${data.chargeNeed}`;
                ratio = data.cleared / data.target;
            } else if (stage.mechanic === "top_anchor") {
                progressText = `雲爆 ${data.burstCount}/${data.targetBurst} ｜ 雲氣 ${data.cloudCharge}/${data.cloudNeed}`;
                ratio = data.burstCount / data.targetBurst;
            } else if (stage.mechanic === "bottom_defense") {
                progressText = `反震 ${data.counterBursts}/${data.targetBurst} ｜ 盾氣 ${data.shieldCharge}/${data.shieldNeed}`;
                ratio = data.counterBursts / data.targetBurst;
            } else if (stage.mechanic === "word_combo") {
                progressText = game.chineseMode
                    ? `${game.zhModeVariant === "bopomofo" ? "注音連段" : "詞語斬咒"}完成 ${data.completed}/${data.target}`
                    : `斬咒完成 ${data.completed}/${data.target}`;
                ratio = data.completed / data.target;
            } else if (stage.mechanic === "boss_raid") {
                const guardText = data.guardMode ? `｜防禦鍵 ${data.guardKey.toUpperCase()}` : `｜防禦成功 ${data.guardSuccess || 0}`;
                const counterText = data.counterWindow > 0 ? `｜反擊 ${data.counterWindow.toFixed(1)}s x${(data.counterBonus || 1).toFixed(2)}` : "";
                const pressureText = `｜逼近壓力 x${(data.approachPressure || 1).toFixed(2)}`;
                progressText = game.endlessBossMode
                    ? `魔王模式｜輪次 ${game.stageCycles + 1} ｜ 魔王氣血 ${Math.ceil(game.enemyHp)} / ${game.maxEnemyHp} ｜ Phase ${data.phase || 1}${guardText}${counterText}${pressureText}`
                    : `魔王氣血：${Math.ceil(game.enemyHp)} / ${game.maxEnemyHp} ｜ Phase ${data.phase || 1}${game.bossChallengeMode ? " ｜ 挑戰" : ""}${guardText}${counterText}${pressureText}`;
                ratio = 1 - (game.enemyHp / game.maxEnemyHp);
            }

            if (typeof data.graceLeft === "number" && data.graceLeft <= 2) {
                progressText += ` ｜ 護體 ${data.graceLeft}`;
            }
            if (isTimedChallengeActive() || game.endlessBossMode) {
                progressText += ` ｜ 分數 ${Math.round(game.stageScore)}`;
            }

            el.objectiveProgress.textContent = progressText;
            if (isTimedChallengeActive()) {
                const timeRatio = game.stageTimerTotal > 0 ? clamp(game.stageTimerLeft / game.stageTimerTotal, 0, 1) : 0;
                el.timerFill.style.width = `${Math.round(timeRatio * 100)}%`;
                el.timerText.textContent = `${Math.max(0, Math.ceil(game.stageTimerLeft))}s`;
            } else {
                if (game.endlessBossMode && stage.mechanic === "boss_raid") {
                    el.timerFill.style.width = `${Math.round(clamp(game.enemyHp / Math.max(1, game.maxEnemyHp), 0, 1) * 100)}%`;
                    el.timerText.textContent = "∞";
                } else {
                    el.timerFill.style.width = `${Math.round(clamp(ratio, 0, 1) * 100)}%`;
                }
                if (stage.mechanic === "boss_raid" && !game.endlessBossMode) {
                    el.timerText.textContent = `${Math.max(0, Math.ceil(data.timeLeft))}s`;
                } else if (!game.endlessBossMode) {
                    el.timerText.textContent = `${Math.round(clamp(ratio, 0, 1) * 100)}%`;
                }
            }
        }

        function renderProjectiles() {
            const stage = getStage();
            const data = game.stageData;
            if (!stage || !data) {
                el.projectileLayer.innerHTML = "";
                return;
            }

            if (stage.mechanic === "homefall") {
                el.projectileLayer.innerHTML = data.objects.map((obj) => `
                    <div class="rune-orb" style="left:${obj.x}px; top:${obj.y}px;">${getKeyVisualLabel(obj.char)}</div>
                `).join("");
            } else if (stage.mechanic === "bottom_defense") {
                el.projectileLayer.innerHTML = data.objects.map((obj) => `
                    <div class="shadow-bolt" style="left:${obj.x}px; top:${obj.y}px;">${getKeyVisualLabel(obj.char)}</div>
                `).join("");
            } else {
                el.projectileLayer.innerHTML = "";
            }
        }

        function getInitialGrace(stage) {
            const base = stage.mechanic === "homefall"
                ? 4
                : stage.mechanic === "top_anchor"
                    ? 4
                    : stage.mechanic === "bottom_defense"
                        ? 4
                        : stage.mechanic === "word_combo"
                            ? 3
                            : 5;
            let bonus = 0;
            if (game.profile.assistMode) bonus += 2;
            if (game.practiceMode) bonus += 1;
            return base + bonus;
        }

        function createStageData(stage) {
            if (stage.mechanic === "homefall") {
                return {
                    objects: [],
                    spawnTimer: 0,
                    runeHits: 0,
                    charge: 0,
                    chargeNeed: 3,
                    cleared: 0,
                    target: stage.target,
                    allKeys: ["a", "s", "d", "f", "j", "k", "l", ";"],
                    allowed: ["a", "s", "d", "f", "j", "k", "l", ";"],
                    uid: 0,
                    graceLeft: getInitialGrace(stage),
                    coachTick: 5.5
                };
            }

            if (stage.mechanic === "top_anchor") {
                return {
                    allTopKeys: ["q", "w", "e", "r", "t", "y", "u", "i", "o", "p"],
                    topKeys: ["q", "w", "e", "r", "t", "y"],
                    expectedType: "top",
                    expectedKey: "q",
                    deadline: 0,
                    deadlineDuration: 0,
                    topSuccess: 0,
                    cloudCharge: 0,
                    cloudNeed: 2,
                    burstCount: 0,
                    targetBurst: stage.target,
                    graceLeft: getInitialGrace(stage),
                    coachTick: 6
                };
            }

            if (stage.mechanic === "bottom_defense") {
                return {
                    objects: [],
                    spawnTimer: 0,
                    blocked: 0,
                    shieldCharge: 0,
                    shieldNeed: 3,
                    counterBursts: 0,
                    targetBurst: stage.target,
                    allKeys: ["z", "x", "c", "v", "b", "n", "m"],
                    allowed: ["z", "x", "c", "v", "b", "n", "m"],
                    uid: 0,
                    graceLeft: getInitialGrace(stage),
                    coachTick: 5.8
                };
            }

            if (stage.mechanic === "word_combo") {
                return {
                    words: game.chineseMode
                        ? (game.zhModeVariant === "bopomofo"
                            ? buildBopomofoModeTokens()
                            : [
                                ...ZH_TYPING_WORD_BANK.easy,
                                ...ZH_TYPING_WORD_BANK.middle,
                                ...ZH_TYPING_WORD_BANK.hard
                            ])
                        : [
                            "cat", "dog", "sun", "moon", "book", "milk", "fish", "bird",
                            "home", "school", "friend", "class", "apple", "water", "happy",
                            "smile", "green", "blue", "plant", "chair", "table", "light",
                            "music", "dance", "jump", "run", "game", "star"
                        ],
                    currentToken: null,
                    currentWord: "",
                    currentPhonetic: "",
                    currentInputWord: "",
                    progress: 0,
                    completed: 0,
                    target: stage.target,
                    graceLeft: getInitialGrace(stage),
                    coachTick: 6.2
                };
            }

            return {
                words: game.chineseMode
                    ? (game.zhModeVariant === "bopomofo"
                        ? buildBopomofoModeTokens()
                        : [
                            ...ZH_TYPING_WORD_BANK.easy,
                            ...ZH_TYPING_WORD_BANK.middle,
                            ...ZH_TYPING_WORD_BANK.hard
                        ])
                    : (game.endlessBossMode
                        ? [
                            ...EN_BOSS_WORD_BANK.easy,
                            ...EN_BOSS_WORD_BANK.middle,
                            ...EN_BOSS_WORD_BANK.junior,
                            ...EN_BOSS_WORD_BANK.senior
                        ]
                        : [
                            "cat", "dog", "sun", "moon", "book", "milk", "fish", "bird",
                            "home", "school", "friend", "class", "apple", "water", "happy",
                            "smile", "green", "blue", "plant", "chair", "table", "light",
                            "music", "dance", "jump", "run", "game", "star", "family",
                            "garden", "planet", "rocket", "purple", "yellow", "winter",
                            "flower", "dragon", "thunder", "volcano", "rainbow"
                        ]),
                currentToken: null,
                currentWord: "",
                currentPhonetic: "",
                currentInputWord: "",
                progress: 0,
                timeLeft: game.endlessBossMode
                    ? Infinity
                    : game.bossChallengeMode
                    ? (game.profile.assistMode ? 300 : 250)
                    : (game.profile.assistMode ? 260 : 220),
                distance: game.bossChallengeMode ? 1.08 : 1.12,
                panicShown: false,
                phase: 1,
                graceLeft: getInitialGrace(stage),
                guardMode: false,
                guardKey: "f",
                guardDeadline: 0,
                guardChargeTimer: getBossGuardCooldown(1),
                guardStartedAt: 0,
                guardDuration: 0,
                qteWarned: false,
                guardSuccess: 0,
                counterWindow: 0,
                counterWindowMax: 0,
                counterBonus: 1,
                missStreak: 0,
                approachPressure: game.endlessBossMode ? 1.08 : 1,
                approachPressureMax: game.endlessBossMode ? 2.45 : (game.bossChallengeMode ? 2.2 : 1.95),
                approachSurgeTimer: 0,
                coachTick: 5
            };
        }

        function stage2NextPrompt() {
            const data = game.stageData;
            if (!data) return;
            syncAdaptiveMechanicTuning(getStage(), data);
            const tighten = game.adaptive.level >= 4 ? 0.62 : game.adaptive.level >= 3 ? 0.74 : game.adaptive.level >= 2 ? 0.86 : 1;
            const safety = game.errorStreak >= 4 ? 1.45 : game.errorStreak >= 3 ? 1.28 : game.errorStreak >= 2 ? 1.14 : 1;
            const windowScale = clamp(game.adaptive.spawnScale * tighten * safety, 0.52, 1.8);
            if (data.expectedType === "top") {
                data.expectedKey = pick(data.topKeys);
                data.deadlineDuration = 3200 * windowScale;
                data.deadline = performance.now() + data.deadlineDuration;
            } else {
                data.expectedKey = Math.random() > 0.5 ? "f" : "j";
                data.deadlineDuration = 2200 * windowScale;
                data.deadline = performance.now() + data.deadlineDuration;
                triggerEnemyCast();
            }
            renderPromptForStage();
        }

        function stage4NextWord() {
            const data = game.stageData;
            let pool = data.words;
            const lenOf = (token) => getTokenLength(token);
            if (game.errorStreak >= 2 || game.adaptive.level === 0) {
                pool = data.words.filter((word) => lenOf(word) <= (game.chineseMode ? 4 : 4));
            } else if (game.adaptive.level >= 4) {
                pool = data.words.filter((word) => lenOf(word) >= (game.chineseMode ? 6 : 5));
            } else if (game.adaptive.level >= 3) {
                pool = data.words.filter((word) => lenOf(word) >= (game.chineseMode ? 4 : 4));
            }
            setCurrentWordToken(data, pick(pool.length ? pool : data.words));
        }

        function stage5NextWord() {
            const data = game.stageData;
            let pool = data.words;
            const lenOf = (token) => getTokenLength(token);
            const phase = data.phase || 1;
            if (game.chineseMode) {
                if (game.endlessBossMode) {
                    const cycle = Math.max(0, game.stageCycles || 0);
                    if (game.errorStreak >= 3) {
                        pool = data.words.filter((word) => lenOf(word) >= 2 && lenOf(word) <= 5);
                    } else if (cycle >= 12) {
                        pool = data.words.filter((word) => lenOf(word) >= 6);
                    } else if (cycle >= 6) {
                        pool = data.words.filter((word) => lenOf(word) >= 4);
                    } else {
                        pool = data.words.filter((word) => lenOf(word) >= 2 && lenOf(word) <= 6);
                    }
                } else if (game.errorStreak >= 2) {
                    pool = data.words.filter((word) => lenOf(word) >= 2 && lenOf(word) <= 4);
                } else if (phase === 1) {
                    pool = data.words.filter((word) => lenOf(word) >= 2 && lenOf(word) <= 5);
                } else if (phase === 2) {
                    pool = data.words.filter((word) => lenOf(word) >= 3 && lenOf(word) <= 7);
                } else {
                    pool = data.words.filter((word) => lenOf(word) >= 4);
                }
            } else if (game.endlessBossMode) {
                const cycle = Math.max(0, game.stageCycles || 0);
                const endlessTier = cycle >= 14 ? 4 : cycle >= 9 ? 3 : cycle >= 4 ? 2 : 1;
                if (game.errorStreak >= 2) {
                    pool = data.words.filter((word) => lenOf(word) >= 4 && lenOf(word) <= 8);
                } else if (endlessTier === 1) {
                    pool = [...EN_BOSS_WORD_BANK.easy, ...EN_BOSS_WORD_BANK.middle.filter((w) => lenOf(w) <= 8)];
                } else if (endlessTier === 2) {
                    pool = [...EN_BOSS_WORD_BANK.middle, ...EN_BOSS_WORD_BANK.junior.filter((w) => lenOf(w) <= 10)];
                } else if (endlessTier === 3) {
                    pool = [...EN_BOSS_WORD_BANK.junior, ...EN_BOSS_WORD_BANK.senior.filter((w) => lenOf(w) <= 13)];
                } else {
                    pool = [...EN_BOSS_WORD_BANK.junior, ...EN_BOSS_WORD_BANK.senior];
                }
            } else if (game.errorStreak >= 2) {
                pool = data.words.filter((word) => lenOf(word) >= 3 && lenOf(word) <= 5);
            } else if (phase === 1) {
                pool = data.words.filter((word) => lenOf(word) >= 3 && lenOf(word) <= 5);
            } else if (phase === 2) {
                pool = data.words.filter((word) => lenOf(word) >= 4 && lenOf(word) <= 6);
            } else {
                pool = data.words.filter((word) => lenOf(word) >= 5);
            }
            if (game.adaptive.level >= 4) {
                pool = pool.filter((word) => lenOf(word) >= 5);
            }
            setCurrentWordToken(data, pick(pool.length ? pool : data.words));
        }

        function getBossGuardCooldown(phase = 1) {
            const challengeScale = game.bossChallengeMode ? 0.95 : 1;
            const endlessScale = game.endlessBossMode ? Math.max(0.72, 1 - Math.min(0.28, (game.stageCycles || 0) * 0.015)) : 1;
            const nextMin = phase === 1 ? 4.8 : phase === 2 ? 3.7 : 2.9;
            const nextMax = phase === 1 ? 7.4 : phase === 2 ? 5.7 : 4.1;
            return (nextMin + Math.random() * Math.max(0.2, nextMax - nextMin)) * challengeScale * endlessScale;
        }

        function resetBossGuardTimer(data) {
            if (!data) return;
            data.guardChargeTimer = getBossGuardCooldown(data.phase || 1);
        }

        function startBossGuardPhase(reason = "魔王蓄力") {
            const stage = getStage();
            if (!stage || stage.mechanic !== "boss_raid") return;
            const data = game.stageData;
            if (!data || data.guardMode) return;
            const phase = data.phase || 1;
            const challengeScale = game.bossChallengeMode ? 0.95 : 1;
            const endlessSpeed = game.endlessBossMode ? Math.max(0.75, 1 - Math.min(0.25, (game.stageCycles || 0) * 0.012)) : 1;
            const deadlineMs = phase === 1 ? 2400 : phase === 2 ? 2050 : 1780;
            const now = performance.now();
            const duration = deadlineMs * challengeScale * endlessSpeed * game.adaptive.spawnScale;
            data.guardMode = true;
            data.guardKey = Math.random() > 0.5 ? "f" : "j";
            data.guardStartedAt = now;
            data.guardDuration = duration;
            data.guardDeadline = now + duration;
            data.qteWarned = false;
            data.counterWindow = 0;
            data.counterWindowMax = 0;
            data.counterBonus = 1;
            data.approachPressure = clamp((data.approachPressure || 1) + 0.08, 0.9, data.approachPressureMax || 2.2);
            data.approachSurgeTimer = Math.max(data.approachSurgeTimer || 0, 0.9);
            triggerEnemyCast();
            triggerFeedbackFlash(0.98);
            spawnEnemySpark(1.15);
            triggerArenaShake(0.98);
            const pos = getArenaAnchors();
            spawnFx("teleport-blink", pos.enemyX - 12, pos.enemyY - 54, 420, {
                width: "176px",
                height: "176px",
                background: "radial-gradient(circle, rgba(255,164,164,0.48), rgba(255,91,120,0.22), rgba(255,91,120,0))"
            });
            spawnFx("charge-glyph", pos.enemyX - 8, pos.enemyY - 64, 720, {
                width: "108px",
                height: "108px",
                border: "1px dashed rgba(255, 210, 186, 0.95)",
                filter: "hue-rotate(-35deg)"
            });
            addFloatMessage(`防禦 ${data.guardKey.toUpperCase()}`, pos.enemyX - 56, pos.enemyY - 92, "#ffd9c4");
            showCoach(`${reason}！快按 ${data.guardKey.toUpperCase()} 防禦`, 1300);
            renderPromptForStage();
        }

        function playFinalVictoryCinematic(onDone) {
            game.mode = "cinematic";
            game.victoryCinematic.active = true;
            clearVictoryCinematicTimers();
            cleanupVictoryScene();
            el.victorySkipTip.classList.add("show");
            el.bossQtePanel.classList.remove("show", "danger");
            el.counterWindowPanel.classList.remove("show");

            const finish = () => {
                if (!game.victoryCinematic.active) return;
                game.victoryCinematic.active = false;
                clearVictoryCinematicTimers();
                cleanupVictoryScene();
                if (typeof onDone === "function") onDone();
            };
            game.victoryCinematic.finish = finish;

            playSfx("skill", 0.46);
            setHeroState("attack", 280);
            el.heroWrap.classList.add("ending-sheath");
            showCoach("主角收劍入鞘，背身而立。", 1200);

            scheduleVictoryCinematic(360, () => {
                setHeroState("stand", 2500);
                el.heroWrap.classList.remove("ending-sheath");
                el.heroWrap.classList.add("ending-turn");
            });

            scheduleVictoryCinematic(760, () => {
                el.heroWrap.classList.add("ending-breath");
            });

            scheduleVictoryCinematic(980, () => {
                playSfx("debuff", 0.4);
                el.enemyWrap.classList.add("ending-vanish");
                spawnEnemySpark(1.36);
                showToast("魔王形體崩散...", 1000);
            });

            scheduleVictoryCinematic(2550, finish);
        }

        function showDialogue(lines, onDone) {
            game.mode = "dialogue";
            game.dialogueQueue = [...lines];
            game.dialogueOnDone = onDone || null;
            el.dialoguePanel.classList.add("show");
            syncImeInputVisibility();
            advanceDialogue();
        }

        function advanceDialogue() {
            if (game.dialogueQueue.length === 0) {
                el.dialoguePanel.classList.remove("show");
                const fn = game.dialogueOnDone;
                game.dialogueOnDone = null;
                if (fn) fn();
                return;
            }
            const line = game.dialogueQueue.shift();
            el.dialogueSpeaker.textContent = line.speaker;
            el.dialogueText.textContent = line.text;
        }

        function buildPracticeStage() {
            if (!game.practicePlan) return STAGES[0];
            if (game.practicePlan.type === "keys") {
                const keys = game.practicePlan.keys || ["f", "j", "d"];
                return {
                    ...STAGES[0],
                    name: "弱點練習【鍵位修補】",
                    subtitle: `Focus Keys: ${keys.map((k) => k.toUpperCase()).join(" / ")}`,
                    objectiveText: `專練你的弱點鍵：${keys.map((k) => k.toUpperCase()).join("、")}。先聚氣，再放斬。`,
                    enemyHp: 12,
                    target: 4,
                    baseIndex: 0,
                    opening: [
                        { speaker: "【系統提示】", text: "已開啟弱點練習模式。這次只會出現你較常錯的鍵位。" }
                    ],
                    clear: [
                        { speaker: "【系統提示】", text: "弱點鍵練習完成，手感提升！" }
                    ]
                };
            }
            const words = game.practicePlan.words || ["school", "friend", "apple"];
            return {
                ...STAGES[3],
                name: "弱點練習【單字修補】",
                subtitle: "Focus Words Combo",
                objectiveText: `專練你的慢速單字：${words.join(" / ")}。`,
                enemyHp: 10,
                target: 10,
                baseIndex: 3,
                opening: [
                    { speaker: "【系統提示】", text: "已開啟弱點單字練習，完整打出每個字。 " }
                ],
                clear: [
                    { speaker: "【系統提示】", text: "單字節奏更順了，回主線會更穩。" }
                ]
            };
        }

        function buildChineseModeStage() {
            const isBopomofo = game.zhModeVariant === "bopomofo";
            return {
                ...STAGES[3],
                name: isBopomofo ? "中打模式【純注音】" : "中打模式【注音選字】",
                subtitle: isBopomofo ? "純注音鍵位連段" : "注音中打連段",
                objectiveText: isBopomofo
                    ? "看注音符號，直接按對應英文鍵位（如 ㄌ 按 X）；完整輸入才會造成傷害。"
                    : "用注音輸入法選字，完整輸入整個詞語才會造成傷害。",
                enemyHp: 12,
                target: 12,
                baseIndex: 3,
                opening: [
                    { speaker: "【系統提示】", text: isBopomofo ? "純注音模式啟動。看注音符號，直接按對應英文鍵位。" : "中打模式啟動。請使用注音輸入法，選字完成後系統會自動判定。" },
                    { speaker: "師傅", text: isBopomofo ? "這回先練注音鍵位映射，眼看符號，手按對位。" : "這回不比按鍵位，改比選字與詞語節奏。先穩，再快。" }
                ],
                clear: [
                    { speaker: "【系統提示】", text: isBopomofo ? "純注音修練完成！注音鍵位反應更穩了。" : "中打修練完成！注音選字與詞語輸入更穩了。" }
                ]
            };
        }

        function startStagePreview(onDone) {
            const stage = getStage();
            if (!stage || game.practiceMode) {
                onDone();
                return;
            }
            game.mode = "preview";
            const steps = stage.mechanic === "boss_raid" ? 5 : 4;
            let count = 0;
            showCoach("示範中：看上方圖示，照三步驟操作。", 1700);
            const previewTick = () => {
                count += 1;
                if (stage.mechanic === "top_anchor") {
                    if (count <= 2) {
                        triggerHeroLeap();
                        addFloatMessage(`聚雲 +1`, 210 + count * 28, 236, "#bfe9ff");
                    } else if (count === 3) {
                        triggerEnemyCast();
                        addFloatMessage("怪物反撲", 688, 236, "#ffd7d7");
                    } else {
                        triggerGuardBurst();
                        spawnSlashWave(1.2);
                        showCombo("雲爆反擊");
                    }
                } else if (stage.mechanic === "homefall") {
                    if (count < steps) {
                        triggerEnemyCast();
                        addFloatMessage("聚氣 +1", 320 + Math.random() * 120, 220 + Math.random() * 60, "#c7ffd9");
                    } else {
                        spawnSlashWave(1.22);
                        showCombo("聚氣斬");
                    }
                } else if (stage.mechanic === "bottom_defense") {
                    if (count < steps) {
                        triggerGuardBurst();
                        triggerEnemyCast();
                        addFloatMessage(`聚盾 +1`, 280 + count * 26, 242, "#aeeaff");
                    } else {
                        spawnGuardRing();
                        spawnSlashWave(1.18);
                        showCombo("反震劍波");
                    }
                } else if (stage.mechanic === "word_combo") {
                    triggerHeroDash();
                    spawnSlashWave(1);
                } else if (stage.mechanic === "boss_raid") {
                    triggerEnemyCast();
                    if (count % 2 === 0) triggerGuardBurst();
                    else spawnSlashWave(1.2);
                } else {
                    spawnSlashWave(0.9);
                }
                if (count >= steps) {
                    game.previewTimer = null;
                    onDone();
                    return;
                }
                game.previewTimer = setTimeout(previewTick, 560);
            };
            clearTimeout(game.previewTimer);
            game.previewTimer = setTimeout(previewTick, 400);
        }

        function startStageGameplay() {
            game.mode = "playing";
            if (!game.sessionStart) game.sessionStart = performance.now();
            game.stageStart = performance.now();
            game.stageMisses = 0;
            game.stagePerfect = true;
            game.cycleResetLockUntil = 0;
            if (game.independentStageMode && !game.practiceMode) {
                game.stageTimerTotal = STAGE_CHALLENGE_SECONDS;
                game.stageTimerLeft = STAGE_CHALLENGE_SECONDS;
                game.stageTimerEndAt = performance.now() + STAGE_CHALLENGE_SECONDS * 1000;
                game.timedStageFinished = false;
                game.stageScore = 0;
                game.stageCycles = 0;
            } else {
                game.stageTimerEndAt = 0;
                game.timedStageFinished = false;
            }
            const stage = getStage();
            renderPromptForStage();
            syncImeInputVisibility();
            if (game.endlessBossMode) showToast(`魔王模式開始（${getTypingModeLabel()}・無盡連戰）`, 900);
            else if (game.chineseMode) showToast(`${getTypingModeLabel()}開始（3:00 計分）`, 900);
            else showToast(game.independentStageMode && !game.practiceMode ? "3:00 挑戰開始" : "試煉開始", 900);
            if (!stage) return;
            if (stage.mechanic === "homefall") {
                showCoach(game.chineseMode ? "步驟：打注音符號 -> 集滿 3 格 -> 自動出劍。" : "步驟：打符文 -> 集滿 3 格 -> 自動出劍。", 1400);
            } else if (stage.mechanic === "top_anchor") {
                showCoach(game.chineseMode ? "步驟：看符號踏雲 -> F/J 回防 -> 雲爆。" : "步驟：Q~P 集雲 -> F/J 回防 -> 雲爆。", 1400);
            } else if (stage.mechanic === "bottom_defense") {
                showCoach(game.chineseMode ? "步驟：打中符號格擋 -> 盾氣滿 3 -> 自動反震。" : "步驟：Z~M 格擋 -> 盾氣滿 3 -> 自動反震。", 1400);
            } else if (stage.mechanic === "word_combo") {
                showCoach(
                    game.chineseMode
                        ? (game.zhModeVariant === "bopomofo"
                            ? "純注音模式：看注音符號，按對應英文鍵位才會出招。"
                            : "中打模式：用注音輸入法選字，完整詞語才會出招。")
                        : "看整個單字，完整輸入才有傷害。",
                    1500
                );
            } else if (stage.mechanic === "boss_raid") {
                showCoach(
                    game.endlessBossMode
                        ? `魔王模式：${getTypingModeLabel()}無盡連戰。魔王會持續逼近，見 DEFEND 先按 F/J。`
                        : `Boss：${game.chineseMode ? (game.zhModeVariant === "bopomofo" ? "完整注音串" : "完整字詞") : "打完整單字"}輸出，見 DEFEND 先按 F/J。`,
                    1500
                );
            }
        }

        function getBaseEnemyHpForStage(stage) {
            if (!stage) return 0;
            const bossChallengeHpScale = game.profile.assistMode ? 1.08 : 1.15;
            return (stage.id === 5 && game.bossChallengeMode && !game.practiceMode)
                ? Math.round(stage.enemyHp * bossChallengeHpScale)
                : stage.enemyHp;
        }

        function getChallengeEnemyHp(stage) {
            const base = getBaseEnemyHpForStage(stage);
            if (game.endlessBossMode && stage?.mechanic === "boss_raid") {
                const cycle = Math.max(0, game.stageCycles || 0);
                const cycleGrowth = 1 + Math.min(2.8, cycle * 0.13);
                const adaptiveGrowth = 1 + Math.max(0, game.adaptive.level - 1) * 0.08;
                return Math.max(1, Math.round(base * cycleGrowth * adaptiveGrowth));
            }
            if (!stage || !(game.independentStageMode && !game.practiceMode)) return base;
            const cycle = Math.max(0, game.stageCycles);
            const cycleGrowth = stage.mechanic === "boss_raid"
                ? 1 + Math.min(0.62, cycle * 0.08)
                : 1 + Math.min(0.7, cycle * 0.1);
            const adaptiveGrowth = 1 + Math.max(0, game.adaptive.level - 1) * (stage.mechanic === "boss_raid" ? 0.06 : 0.08);
            return Math.max(1, Math.round(base * cycleGrowth * adaptiveGrowth));
        }

        function primeStageMechanic(stage) {
            if (!stage || !game.stageData) return;
            if (stage.mechanic === "top_anchor") {
                game.stageData.expectedType = "top";
                stage2NextPrompt();
            }
            if (stage.mechanic === "word_combo") {
                stage4NextWord();
            }
            if (stage.mechanic === "boss_raid") {
                stage5NextWord();
            }
        }

        function resetTimedCycle(stage) {
            if (!stage) return;
            game.stageData = createStageData(stage);
            game.playerHp = Math.min(game.maxPlayerHp, game.playerHp + 6);
            updateAdaptiveDifficulty();
            game.enemyHp = getChallengeEnemyHp(stage);
            game.maxEnemyHp = game.enemyHp;
            if (Array.isArray(stage.enemyPool) && stage.enemyPool.length) {
                const nextMonster = stage.enemyPool[game.stageCycles % stage.enemyPool.length];
                setEnemy(nextMonster);
            }
            primeStageMechanic(stage);
            renderPromptForStage();
            updateObjectiveUI();
            renderProjectiles();
        }

        function resetEndlessBossCycle(stage) {
            if (!stage) return;
            game.stageData = createStageData(stage);
            game.playerHp = Math.min(game.maxPlayerHp, game.playerHp + 10);
            game.qi = Math.min(game.maxQi, game.qi + 14);
            updateAdaptiveDifficulty();
            game.enemyHp = getChallengeEnemyHp(stage);
            game.maxEnemyHp = game.enemyHp;
            if (Array.isArray(stage.enemyPool) && stage.enemyPool.length) {
                const nextMonster = stage.enemyPool[game.stageCycles % stage.enemyPool.length];
                setEnemy(nextMonster);
            }
            primeStageMechanic(stage);
            renderPromptForStage();
            updateObjectiveUI();
            renderProjectiles();
        }

        function loadStage(index, skipOpening = false) {
            const stage = game.practiceMode
                ? buildPracticeStage()
                : STAGES[index];
            if (!stage) return;

            game.currentStageDef = stage;
            game.stageIndex = stage.baseIndex ?? index;
            game.selectedStageIndex = stage.baseIndex ?? index;
            game.stageData = createStageData(stage);
            game.stageTimerEndAt = 0;
            game.timedStageFinished = false;
            if (game.practiceMode && stage.mechanic === "homefall" && game.practicePlan?.keys?.length) {
                game.stageData.allowed = game.practicePlan.keys;
            }
            if (game.practiceMode && stage.mechanic === "word_combo" && game.practicePlan?.words?.length) {
                game.stageData.words = game.practicePlan.words;
            }
            game.playerHp = game.maxPlayerHp;
            game.combo = 0;
            game.qi = Math.min(game.qi, game.maxQi);
            updateAdaptiveDifficulty();
            const enemyHp = getChallengeEnemyHp(stage);
            game.enemyHp = enemyHp;
            game.maxEnemyHp = enemyHp;

            el.stageName.textContent = game.endlessBossMode
                ? `魔王模式【${getTypingModeLabel()}・無盡連戰】`
                : game.chineseMode
                    ? `${stage.id === 5 && game.bossChallengeMode ? `${stage.name}（挑戰）` : stage.name}【${getTypingModeLabel()}】`
                    : stage.id === 5 && game.bossChallengeMode
                        ? `${stage.name}（挑戰）`
                        : stage.name;
            el.arena.setAttribute("data-stage", String(stage.id));
            setScene(stage.scene);
            applyStageVisual(stage.id);
            buildAmbientSparks(stage.id === 5 ? 36 : 26);
            setEnemy(stage.enemyPool[0]);
            renderMonsterRail(stage.enemyPool);
            updateStageTrack();

            if (stage.id === 5) {
                el.bossDistanceWrap.classList.add("active");
            } else {
                el.bossDistanceWrap.classList.remove("active");
            }

            playBgm(stage.bgm);
            playSfx("buy", 0.34);
            if (stage.id === 2) playSfx("ice", 0.45);
            if (stage.id === 5) playSfx("fire", 0.45);

            primeStageMechanic(stage);

            renderPromptForStage();
            updateObjectiveUI();
            renderProjectiles();
            syncImeInputVisibility();

            if (skipOpening) {
                startStageGameplay();
                return;
            }

            showDialogue(stage.opening, () => {
                startStagePreview(() => {
                    startStageGameplay();
                });
            });
        }

        function clearCurrentStage() {
            if (game.mode !== "playing") return;
            const stage = getStage();
            const data = game.stageData;

            if (game.endlessBossMode && stage?.mechanic === "boss_raid") {
                const now = performance.now();
                if (now < (game.cycleResetLockUntil || 0)) return;
                game.cycleResetLockUntil = now + 180;
                game.defeated += 1;
                game.stageCycles += 1;
                const cycleBonus = 420 + Math.min(360, Math.round(game.combo * 12)) + Math.round((game.stageCycles || 0) * 35);
                addScore(cycleBonus);
                playSfx("levelUp", 0.88);
                playSfx("crit", 0.52);
                showStageClearFx();
                triggerArenaShake(1.28);
                showToast(`第 ${game.stageCycles} 輪斬破！+${cycleBonus} 分`, 950);
                showCoach("魔王形體重組，強度提升！繼續連戰。", 900);
                resetEndlessBossCycle(stage);
                return;
            }

            if (isTimedChallengeActive()) {
                if (!stage) return;
                if (!data) {
                    game.stageData = createStageData(stage);
                }
                const left = Math.max(0, (game.stageTimerEndAt - performance.now()) / 1000);
                game.stageTimerLeft = left;
                if (left <= 0.01) {
                    finishTimedStage();
                    return;
                }
                const now = performance.now();
                if (now < (game.cycleResetLockUntil || 0)) return;
                game.cycleResetLockUntil = now + 160;
                game.defeated += 1;
                game.stageCycles += 1;
                const cycleBonus = 220 + Math.round(game.stageTimerLeft * 0.9) + Math.min(220, game.combo * 10);
                addScore(cycleBonus);
                playSfx("levelUp", 0.85);
                playSfx("heal", 0.55);
                showStageClearFx();
                showToast(`斬破一輪！+${cycleBonus} 分（剩 ${Math.max(0, Math.ceil(game.stageTimerLeft))} 秒）`, 920);
                resetTimedCycle(stage);
                return;
            }

            game.mode = "transition";
            game.defeated += 1;
            playSfx("levelUp", 0.85);
            playSfx("heal", 0.55);
            showStageClearFx();
            showToast(`${stage.name} 通關！`, 1500);

            if (game.practiceMode) {
                showDialogue(stage.clear, () => {
                    openResultScreen(true);
                });
                return;
            }

            showDialogue(stage.clear, () => {
                if (game.stageIndex >= STAGES.length - 1) {
                    playFinalVictoryCinematic(() => {
                        openResultScreen(true);
                    });
                } else {
                    loadStage(game.stageIndex + 1);
                }
            });
        }

        function finishTimedStage() {
            if (game.mode !== "playing") return;
            if (game.timedStageFinished) return;
            game.timedStageFinished = true;
            game.stageTimerLeft = 0;
            if (game.stageTimerEndAt > 0) {
                game.stageTimerEndAt = Math.min(game.stageTimerEndAt, performance.now());
            }
            game.mode = "transition";
            showToast("時間到，正在結算分數...", 900);
            playSfx("levelUp", 0.62);
            openResultScreen(true, "timer-expired");
        }

        function openResultScreen(force = false, reason = "normal") {
            const timedChallengeResult = game.independentStageMode && !game.practiceMode;
            if (isTimedChallengeActive()) {
                const left = Math.max(0, (game.stageTimerEndAt - performance.now()) / 1000);
                game.stageTimerLeft = left;
                const timerExpired = left <= 0.05 || reason === "timer-expired";
                if (!timerExpired) {
                    showToast("本關是 3:00 計分，時間到才會結算。", 900);
                    return;
                }
            } else if (timedChallengeResult && game.stageTimerLeft > 0.15 && reason !== "timer-expired") {
                showToast("本關是 3:00 計分，時間到才會結算。", 900);
                return;
            }
            game.mode = "result";
            game.stageTimerEndAt = 0;
            playBgm("title");
            syncImeInputVisibility();

            const stage = getStage();
            const acc = calcAccuracy();
            const weakKeys = calculateWeakKeys(3);
            const slowWords = calculateSlowWords(3);
            game.lastResultInsights = { weakKeys, slowWords };
            const stageScore = Math.round(game.stageScore);
            const judge = buildJudgeScore(stageScore, acc, game.maxCombo, game.totalTyped);
            const finalScore = judge.total;
            const stageEval = game.practiceMode
                ? { stars: 0, grade: "練習", pass: true, tiers: [0, 0, 0] }
                : game.endlessBossMode
                    ? evaluateSpecialModeResult("endlessBoss", finalScore, acc, game.maxCombo, game.totalTyped, game.stageCycles)
                    : evaluateStageResult(stage?.id || 1, finalScore, acc, game.maxCombo, game.totalTyped);

            const sessionAchievements = [];
            if (game.maxCombo >= 30) {
                unlockAchievement("combo30", "連擊旋風");
                sessionAchievements.push("連擊旋風");
            }
            if (acc >= 95) {
                unlockAchievement("acc95", "穩定輸出");
                sessionAchievements.push("穩定輸出");
            }
            if (game.totalTyped >= 220) {
                unlockAchievement("typed220", "耐力輸出");
                sessionAchievements.push("耐力輸出");
            }
            if (game.stagePerfect) {
                unlockAchievement("stage_perfect", "無傷節奏");
                sessionAchievements.push("無傷節奏");
            }
            if (game.practiceMode) {
                unlockAchievement("practice_done", "修補完成");
                sessionAchievements.push("修補完成");
            }
            if (game.bossChallengeMode && !game.practiceMode && !game.endlessBossMode) {
                unlockAchievement("boss_challenge_clear", "魔王征服者");
                sessionAchievements.push("魔王征服者");
            }
            if (!game.practiceMode && !game.endlessBossMode && stageEval.stars >= 3) {
                unlockAchievement(`stage_${stage?.id}_three_star`, "三星通關");
                sessionAchievements.push("三星通關");
            }

            const weakKeyText = weakKeys.length ? weakKeys.map((k) => k.toUpperCase()).join("、") : "目前鍵位很平均";
            const slowWordText = slowWords.length ? slowWords.join("、") : (game.chineseMode ? "目前詞語節奏穩定" : "目前單字節奏穩定");

            el.resultAcc.textContent = `${acc}%`;
            el.resultMaxCombo.textContent = String(game.maxCombo);
            el.resultScore.textContent = String(finalScore);
            el.resultTyped.textContent = String(game.totalTyped);
            prepareCloudUploadFromResult({ stage, finalScore, acc, stageEval });

            if (stage && timedChallengeResult) {
                const record = getStageRecord(stage.id);
                record.bestScore = Math.max(record.bestScore, finalScore);
                record.bestStars = Math.max(record.bestStars, stageEval.stars);
                record.bestGrade = pickBetterGrade(record.bestGrade, stageEval.grade);
                if (stageEval.pass) record.clearCount += 1;
                record.bestAcc = Math.max(record.bestAcc, acc);
                record.bestCombo = Math.max(record.bestCombo, game.maxCombo);
                record.bestTyped = Math.max(record.bestTyped, game.totalTyped);
                game.profile.stageRecords[String(stage.id)] = record;
            }

            if (!game.practiceMode && game.endlessBossMode) {
                const endlessRecord = getSpecialRecord("endlessBoss");
                endlessRecord.bestScore = Math.max(endlessRecord.bestScore, finalScore);
                endlessRecord.bestStars = Math.max(endlessRecord.bestStars, stageEval.stars);
                endlessRecord.bestGrade = pickBetterGrade(endlessRecord.bestGrade, stageEval.grade);
                endlessRecord.bestAcc = Math.max(endlessRecord.bestAcc, acc);
                endlessRecord.bestCombo = Math.max(endlessRecord.bestCombo, game.maxCombo);
                endlessRecord.bestTyped = Math.max(endlessRecord.bestTyped, game.totalTyped);
                endlessRecord.bestRounds = Math.max(endlessRecord.bestRounds, game.stageCycles);
                endlessRecord.playCount += 1;
                game.profile.specialRecords.endlessBoss = endlessRecord;
            } else if (!game.practiceMode && game.chineseMode && !game.independentStageMode) {
                const zhRecord = getSpecialRecord("zhMode");
                zhRecord.bestScore = Math.max(zhRecord.bestScore, finalScore);
                zhRecord.bestStars = Math.max(zhRecord.bestStars, stageEval.stars);
                zhRecord.bestGrade = pickBetterGrade(zhRecord.bestGrade, stageEval.grade);
                zhRecord.bestAcc = Math.max(zhRecord.bestAcc, acc);
                zhRecord.bestCombo = Math.max(zhRecord.bestCombo, game.maxCombo);
                zhRecord.bestTyped = Math.max(zhRecord.bestTyped, game.totalTyped);
                zhRecord.playCount += 1;
                game.profile.specialRecords.zhMode = zhRecord;
            }

            if (stage) {
                const stageLabel = STAGE_TRACK[(stage.id || 1) - 1]?.name || stage.name || "試煉關卡";
                el.resultTitle.textContent = game.endlessBossMode
                    ? "魔王模式結算"
                    : `第 ${stage.id} 關結算`;
                el.resultSub.textContent = game.practiceMode
                    ? "弱點練習完成，已同步學習回饋。"
                    : game.endlessBossMode
                        ? `連戰結束 ｜ 輪次 ${game.stageCycles} ｜ 評等 ${stageEval.grade}`
                        : `${stageEval.pass ? "過關" : "未過關"} ｜ ${getTypingModeLabel()} ｜ 評等 ${stageEval.grade}`;
                el.resultStageLine.textContent = game.endlessBossMode
                    ? "模式：魔王模式（無盡連戰）"
                    : `關卡：${stageLabel} ｜ 模式：${getTypingModeLongLabel()} ｜ 3:00 計分`;
                el.resultStars.innerHTML = renderStars(stageEval.stars);
                el.resultScoreLine.textContent = game.practiceMode
                    ? `練習輸入：${game.totalTyped} 鍵`
                    : game.endlessBossMode
                        ? `總分 ${finalScore} ｜ 輪次 ${game.stageCycles} ｜ 擊倒 ${game.defeated} 次魔王`
                        : `總分 ${finalScore} ｜ 評級 ${stageEval.grade} ｜ ${stageEval.pass ? "本關過關" : "再挑戰拚 1★"}`;
            }

            el.certificate.innerHTML = `
                兹證明：<b>嘉北劍派入門弟子</b><br>
                ${game.practiceMode
                    ? "已完成弱點修補訓練，補齊短板。"
                    : game.endlessBossMode
                        ? "已完成魔王模式連戰，本次紀錄已封存。"
                        : `已完成第 ${stage?.id || 1} 關三分鐘挑戰（${getTypingModeLabel()}）。`}<br>
                封號：<b>${game.practiceMode ? "節奏修補者" : stageEval.pass ? "通關弟子" : "再戰修士"}</b>
                （評級：${stageEval.grade}）<br>
                師傅評語：${game.practiceMode
                    ? "短板就是下一次的優勢，保持節奏。"
                    : game.endlessBossMode
                        ? "連戰看的不是一擊，而是長時間穩定輸出與攻守切換。"
                        : game.chineseMode
                            ? (game.zhModeVariant === "bopomofo"
                                ? (stageEval.pass ? "注音鍵位對應很穩，下一步拉高速度與連擊。" : "先把注音鍵位對應打穩，再追求速度。")
                                : (stageEval.pass ? "選字節奏穩定，接下來加快完整詞語輸出。" : "注音選字先求準，再求快；詞語節奏穩了，速度自然會上來。"))
                            : stageEval.pass
                                ? "節奏穩定，準許重複挑戰衝更高星等。"
                                : "先穩定正確率，再追求速度與連擊。"}
            `;

            el.learningReportText.innerHTML = `
                本回表現：正確率 <b>${acc}%</b>、最高連擊 <b>${game.maxCombo}</b>、總鍵數 <b>${game.totalTyped}</b><br>
                容易失誤的鍵：<b>${weakKeyText}</b><br>
                ${(game.chineseMode && (stage?.mechanic === "word_combo" || stage?.mechanic === "boss_raid")) ? "可再練快的詞語" : "可再練快的單字"}：<b>${slowWordText}</b><br>
                本關失誤次數：<b>${game.stageMisses}</b><br>
                ${game.practiceMode
                    ? "練習模式不計星等，重點是補強手感。"
                    : stageEval.pass
                        ? "已通過本關，可重複挑戰衝更高星等與評級。"
                        : "先把正確率穩住，再提升連擊與總鍵數。"}
            `;

            el.achievementList.innerHTML = (sessionAchievements.length ? sessionAchievements : ["穩定完訓"])
                .map((item) => `<span class="achievement-pill">${item}</span>`)
                .join("");

            game.profile.sessions += 1;
            game.profile.totalKeys += game.totalTyped;
            game.profile.bestAcc = Math.max(game.profile.bestAcc, acc);
            game.profile.bestCombo = Math.max(game.profile.bestCombo, game.maxCombo);
            game.profile.achievements = Array.from(game.unlockedAchievements);
            writeProfile();

            const stageSummary = STAGES.map((item) => {
                const rec = getStageRecord(item.id);
                return `第${item.id}關：${Math.round(rec.bestScore)} 分（${"★".repeat(rec.bestStars)}${"☆".repeat(3 - rec.bestStars)}）`;
            }).join("<br>");
            const endlessRec = getSpecialRecord("endlessBoss");

            el.growthPanelText.innerHTML = `
                累積修煉次數：<b>${game.profile.sessions}</b><br>
                累積輸入鍵數：<b>${game.profile.totalKeys}</b><br>
                歷史最佳：正確率 <b>${game.profile.bestAcc}%</b> / 連擊 <b>${game.profile.bestCombo}</b><br>
                <br>${stageSummary}<br><br>
                魔王模式：<b>${Math.round(endlessRec.bestScore)}</b> 分 / 最佳輪次 <b>${Math.round(endlessRec.bestRounds || 0)}</b> / ${renderStars(endlessRec.bestStars)}<br>
                輸入模式：英打／國字中打／純注音 都會計入各關星等紀錄（可重複挑戰）
            `;

            if (el.btnPractice) {
                el.btnPractice.textContent = "補強修練";
                el.btnPractice.style.display = (game.practiceMode || game.chineseMode || game.endlessBossMode) ? "none" : "inline-block";
            }

            renderStageSelect();
            el.resultScreen.classList.add("show");
        }

        function closeOverlays() {
            el.titleScreen.classList.remove("show");
            el.stageSelectScreen.classList.remove("show");
            el.resultScreen.classList.remove("show");
            el.failScreen.classList.remove("show");
            el.pauseScreen.classList.remove("show");
            if (el.stage2QtePanel) el.stage2QtePanel.classList.remove("show", "danger");
            el.bossQtePanel.classList.remove("show", "danger");
            el.counterWindowPanel.classList.remove("show");
            el.arena.classList.remove("shake-light", "shake-heavy");
            if (el.hitLine) {
                el.hitLine.classList.remove("impact");
                el.hitLine.style.borderTopWidth = "";
            }
            cleanupVictoryScene();
        }

        function togglePause(force) {
            const toPause = force === undefined ? game.mode === "playing" : !!force;
            if (toPause) {
                if (game.mode !== "playing") return;
                game.mode = "paused";
                game.pauseStartedAt = performance.now();
                el.pauseScreen.classList.add("show");
                showToast(game.autoPausedByBlur ? "視窗切換，已自動暫停" : "已暫停", 800);
                return;
            }
            if (game.mode !== "paused") return;
            const pausedMs = game.pauseStartedAt ? (performance.now() - game.pauseStartedAt) : 0;
            if (pausedMs > 0) {
                game.sessionStart += pausedMs;
                game.stageStart += pausedMs;
                if (isTimedChallengeActive()) {
                    game.stageTimerEndAt += pausedMs;
                }
                const stage = getStage();
                const data = game.stageData;
                if (stage && data) {
                    if (stage.mechanic === "top_anchor" && data.deadline) {
                        data.deadline += pausedMs;
                    }
                    if (stage.mechanic === "boss_raid") {
                        if (data.guardDeadline) data.guardDeadline += pausedMs;
                        if (data.guardStartedAt) data.guardStartedAt += pausedMs;
                    }
                }
            }
            game.pauseStartedAt = 0;
            el.pauseScreen.classList.remove("show");
            game.mode = "playing";
            game.autoPausedByBlur = false;
            showToast("繼續戰鬥", 700);
        }

        function failStage(reason) {
            if (game.mode === "failed" || game.mode === "result") return;
            game.mode = "failed";
            playSfx("lose", 0.84);
            playBgm("title");
            syncImeInputVisibility();
            el.failReason.textContent = reason;
            el.failScreen.classList.add("show");
        }

        function resetRun(fullReset = true) {
            game.playerHp = 140;
            game.maxPlayerHp = 140;
            game.combo = 0;
            game.maxCombo = 0;
            game.qi = 0;
            game.defeated = 0;
            game.stageTimerTotal = STAGE_CHALLENGE_SECONDS;
            game.stageTimerLeft = STAGE_CHALLENGE_SECONDS;
            game.stageTimerEndAt = 0;
            game.timedStageFinished = false;
            game.stageScore = 0;
            game.stageCycles = 0;
            game.errorStreak = 0;
            game.cycleResetLockUntil = 0;
            game.totalTyped = 0;
            game.correctTyped = 0;
            game.sessionStart = 0;
            game.sessionAttempts = [];
            game.stageMisses = 0;
            game.stagePerfect = true;
            game.currentStageDef = null;
            game.stageIndex = 0;
            game.selectedStageIndex = 0;
            game.practiceMode = false;
            game.practicePlan = null;
            game.bossChallengeMode = false;
            game.endlessBossMode = false;
            game.chineseMode = false;
            game.zhModeVariant = "hanzi";
            game.inputLocale = "en";
            game.imeComposing = false;
            game.imeDraftText = "";
            game.imeLastHandledValue = "";
            game.imeLastHandledAt = 0;
            game.enemyAmbientFxTimer = 1.1;
            game.independentStageMode = true;
            game.cloud.pendingUpload = null;
            game.cloud.uploading = false;
            game.autoPausedByBlur = false;
            game.pauseStartedAt = 0;
            game.victoryCinematic.active = false;
            game.victoryCinematic.finish = null;
            game.victoryCinematic.timers = [];
            clearVictoryCinematicTimers();
            clearTimeout(game.coachTimer);
            clearTimeout(game.previewTimer);
            clearTimeout(game.arenaShakeTimer);
            clearTimeout(game.hitLineTimer);
            el.coachStrip.classList.remove("show");
            el.pauseScreen.classList.remove("show");
            el.arena.classList.remove("shake-light", "shake-heavy");
            if (el.hitLine) {
                el.hitLine.classList.remove("impact");
                el.hitLine.style.borderTopWidth = "";
            }
            if (el.imeInput) el.imeInput.value = "";
            cleanupVictoryScene();
            if (fullReset) {
                setScene("title");
                playBgm("title");
            }
            syncImeInputVisibility();
            updateHud();
            updateStageTrack();
        }

        function startPracticeMode() {
            const weakKeys = (game.lastResultInsights?.weakKeys || []).slice(0, 3);
            const slowWords = (game.lastResultInsights?.slowWords || []).slice(0, 4);
            if (weakKeys.length > 0) {
                game.practicePlan = { type: "keys", keys: weakKeys };
            } else {
                game.practicePlan = {
                    type: "words",
                    words: slowWords.length ? slowWords : ["school", "friend", "apple", "green"]
                };
            }
            game.practiceMode = true;
            game.independentStageMode = false;
            game.bossChallengeMode = false;
            game.endlessBossMode = false;
            game.chineseMode = false;
            game.zhModeVariant = "hanzi";
            game.inputLocale = "en";
            showCoach("弱點練習啟動：先穩再快。", 1200);
            loadStage(0);
        }

        function handleHomefallInput(key) {
            const data = game.stageData;
            const acceptKeys = data.allKeys || data.allowed;
            if (!acceptKeys.includes(key)) {
                return;
            }

            const sorted = data.objects
                .map((obj, index) => ({ obj, index }))
                .filter((entry) => entry.obj.char === key)
                .sort((a, b) => b.obj.y - a.obj.y);

            if (sorted.length === 0) {
                recordAttempt(false);
                recordKeyStat(key, false);
                softMistake("怪物符文還沒到位，先瞄準！");
                return;
            }

            const idx = sorted[0].index;
            const obj = data.objects[idx];
            data.objects.splice(idx, 1);
            data.runeHits += 1;
            data.charge += 1;
            spawnChargeAura("charge", 0.88 + (data.charge / Math.max(1, data.chargeNeed)) * 0.28);
            recordAttempt(true);
            recordKeyStat(key, true);
            rewardAction({ enemyDamage: 0, qiGain: 2.2, hero: "attack", sfx: "correct", heal: 0.7 });
            addFloatMessage(`聚氣 ${data.charge}/${data.chargeNeed}`, obj.x - 22, obj.y - 8, "#ffe5a0");

            if (data.charge >= data.chargeNeed) {
                data.charge = 0;
                data.cleared += 1;
                damageEnemy(3);
                playSfx("skill", 0.56);
                triggerTeleportStrike(1.22, "聚氣斬");
                spawnSlashWave(1.35);
                spawnEnemySpark(1.28);
                showCombo(`聚氣斬 ${data.cleared}/${data.target}`);
                addFloatMessage("聚氣斬！", obj.x - 28, obj.y - 30, "#fff1b8");
            }

            if (data.cleared > 0 && data.cleared % 2 === 0) {
                rotateEnemyFromPool(getStage().enemyPool);
            }

            if (data.cleared >= data.target) {
                clearCurrentStage();
            }
        }

        function handleTopAnchorInput(key) {
            const data = game.stageData;
            if (!/^[a-z]$/.test(key)) return;

            if (key === data.expectedKey) {
                recordAttempt(true);
                recordKeyStat(key, true);
                if (data.expectedType === "top") {
                    data.topSuccess += 1;
                    data.cloudCharge = Math.min(data.cloudNeed, data.cloudCharge + 1);
                    spawnChargeAura("jump", 0.92 + (data.cloudCharge / Math.max(1, data.cloudNeed)) * 0.34);
                    rewardAction({ enemyDamage: 0, qiGain: 4.2, hero: "jump", sfx: "correct", heal: 1.1 });
                    triggerHeroLeap();
                    addFloatMessage(`雲氣 ${data.cloudCharge}/${data.cloudNeed}`, 190, 240, "#bfe9ff");
                    showCombo(`踏雲 ${data.topSuccess}`);
                    if (data.cloudCharge >= data.cloudNeed) {
                        playSfx("buff", 0.4);
                        spawnGuardRing();
                        showCoach("雲氣已滿！下一次回防會觸發雲爆。", 860);
                    }
                    data.expectedType = "anchor";
                    stage2NextPrompt();
                    if (data.topSuccess % 4 === 0) {
                        playSfx("skill", 0.48);
                        rotateEnemyFromPool(getStage().enemyPool);
                    }
                } else {
                    const burstReady = data.cloudCharge >= data.cloudNeed;
                    if (burstReady) {
                        data.cloudCharge = 0;
                        data.burstCount += 1;
                    }
                    rewardAction({
                        enemyDamage: burstReady ? 2.4 : 0,
                        qiGain: burstReady ? 7.4 : 5.8,
                        hero: burstReady ? "attack" : "run",
                        sfx: "buff",
                        message: burstReady ? `雲爆反擊 ${data.burstCount}/${data.targetBurst}` : "回防成功",
                        heal: burstReady ? 1.9 : 1.4
                    });
                    if (burstReady) {
                        triggerHeroDash();
                        triggerTeleportStrike(1.25, "雲爆");
                        spawnSlashWave(1.34);
                        spawnEnemySpark(1.2);
                        addFloatMessage("雲爆！", 220, 220, "#cceeff");
                        if (data.burstCount >= data.targetBurst) {
                            game.enemyHp = 0;
                            clearCurrentStage();
                            return;
                        }
                    }
                    playSfx("heal", 0.3);
                    data.expectedType = "top";
                    stage2NextPrompt();
                }
            } else {
                recordAttempt(false);
                recordKeyStat(key, false);
                if (data.expectedType === "anchor") {
                    punishWithProtection({
                        hpLoss: 1,
                        reason: `慢一點，回防鍵應為 ${getKeyPromptLabel(data.expectedKey)}`,
                        countMistake: false
                    });
                } else {
                    softMistake(`這次目標是 ${getKeyPromptLabel(data.expectedKey)}，再跳一次！`);
                }
                data.expectedType = "top";
                stage2NextPrompt();
            }

            renderPromptForStage();
        }

        function handleBottomDefenseInput(key) {
            const data = game.stageData;
            const acceptKeys = data.allKeys || data.allowed;
            if (!acceptKeys.includes(key)) {
                return;
            }

            const sorted = data.objects
                .map((obj, index) => ({ obj, index }))
                .filter((entry) => entry.obj.char === key)
                .sort((a, b) => a.obj.x - b.obj.x);

            if (sorted.length === 0) {
                recordAttempt(false);
                recordKeyStat(key, false);
                softMistake("先看最近的暗器，再出招！");
                return;
            }

            const idx = sorted[0].index;
            const obj = data.objects[idx];
            data.objects.splice(idx, 1);
            data.blocked += 1;
            data.shieldCharge = Math.min(data.shieldNeed, data.shieldCharge + 1);
            spawnChargeAura("defense", 0.94 + (data.shieldCharge / Math.max(1, data.shieldNeed)) * 0.28);
            recordAttempt(true);
            recordKeyStat(key, true);
            rewardAction({ enemyDamage: 0, qiGain: 4, hero: "defense", sfx: "shield", heal: 1.0 });
            triggerGuardBurst();
            addFloatMessage(`盾氣 ${data.shieldCharge}/${data.shieldNeed}`, obj.x + 4, obj.y - 8, "#9be8ff");

            if (data.shieldCharge >= data.shieldNeed) {
                data.shieldCharge = 0;
                data.counterBursts += 1;
                damageEnemy(2.5);
                playSfx("crit", 0.58);
                setHeroState("attack", 210);
                triggerHeroDash();
                triggerTeleportStrike(1.18, "反震");
                spawnGuardRing();
                spawnSlashWave(1.28);
                spawnEnemySpark(1.18);
                showCombo(`反震劍波 ${data.counterBursts}/${data.targetBurst}`);
                addFloatMessage("反震！", obj.x - 32, obj.y - 26, "#bde9ff");
                if (data.counterBursts >= data.targetBurst) {
                    game.enemyHp = 0;
                    clearCurrentStage();
                    return;
                }
            }

            if (data.blocked % 5 === 0) {
                rotateEnemyFromPool(getStage().enemyPool);
            }

        }

        function handleWordComboInput(char) {
            const data = game.stageData;
            const bopomofoMode = game.chineseMode && game.zhModeVariant === "bopomofo";
            const displayChars = splitChars(data.currentWord);
            const inputWord = bopomofoMode ? (data.currentInputWord || "") : data.currentWord;
            const expectedChars = splitChars(inputWord);
            const inputChar = bopomofoMode ? normalizeBopomofoKey(char) : normalizeChar(char);
            if (!(bopomofoMode ? /^[a-z0-9,./;\-]$/.test(inputChar) : /^[a-z]$/.test(inputChar))) return;
            const expected = bopomofoMode ? expectedChars[data.progress] : normalizeChar(expectedChars[data.progress]);

            if (inputChar === expected) {
                recordAttempt(true);
                recordKeyStat(inputChar, true);
                gainCombo(2.6);
                addScore(12 + Math.min(24, game.combo * 1.2));
                setHeroState("attack", 140);
                playSfx("playerAttack", 0.4);
                data.progress += 1;
                triggerFeedbackFlash(0.92);
                spawnChargeAura("attack", 0.84);
                spawnSlashWave(0.76);
                addFloatMessage(bopomofoMode ? (displayChars[data.progress - 1] || char) : char, 420 + Math.random() * 140, 228 + Math.random() * 90, "#8ff0c5");

                if (data.progress >= expectedChars.length) {
                    recordWordStat(data.currentWord, performance.now() - game.currentWordStart, true);
                    addScore(95 + Math.min(120, game.combo * 4));
                    data.completed += 1;
                    damageEnemy(1.1 * game.adaptive.wordDamageScale);
                    playSfx("skill", 0.52);
                    playSfx("correct", 0.44);
                    triggerHeroDash();
                    triggerTeleportStrike(1.12, "連段斬");
                    spawnSlashWave(1.2);
                    spawnEnemySpark(1.18);
                    showCombo(`劍氣連段 ${data.completed}/${data.target}`);
                    stage4NextWord();
                    if (data.completed % 3 === 0) {
                        rotateEnemyFromPool(getStage().enemyPool);
                    }
                    if (data.completed >= data.target) {
                        clearCurrentStage();
                    }
                }
            } else {
                recordAttempt(false);
                recordKeyStat(inputChar, false);
                recordWordStat(data.currentWord, 0, false);
                addScore(-18);
                const hintChar = bopomofoMode ? (displayChars[data.progress] || displayChars[0]) : (expectedChars[data.progress] || expectedChars[0]);
                if (!useGraceShield(`提示：下一個字是 ${hintChar}`)) {
                    data.progress = Math.max(0, data.progress - 1);
                    const retryHintChar = bopomofoMode ? (displayChars[data.progress] || displayChars[0]) : (expectedChars[data.progress] || expectedChars[0]);
                    softMistake(`提示：下一個字是「${retryHintChar}」`);
                }
            }

            renderPromptForStage();
        }

        function handleChineseWordComboImeInput() {
            if (!game.chineseMode || game.inputLocale !== "zh" || !el.imeInput) return;
            if (game.mode !== "playing") return;
            const stage = getStage();
            const data = game.stageData;
            if (!stage || !data || (stage.mechanic !== "word_combo" && stage.mechanic !== "boss_raid")) return;
            if (stage.mechanic === "boss_raid" && data.guardMode) {
                updateImePanelHint();
                return;
            }

            const target = getTokenText(data.currentToken || data.currentWord).replace(/[\s\u3000]/g, "");
            const typedText = String(el.imeInput.value || "").replace(/[\s\u3000]/g, "");
            const now = performance.now();
            if (typedText && game.imeLastHandledValue === typedText && (now - game.imeLastHandledAt) < 40) {
                updateImePanelHint();
                return;
            }
            game.imeLastHandledValue = typedText;
            game.imeLastHandledAt = now;
            const currentLen = splitChars(typedText).length;

            if (!typedText) {
                data.progress = 0;
                renderPromptForStage();
                updateImePanelHint();
                return;
            }

            if (target.startsWith(typedText)) {
                const prevProgress = data.progress || 0;
                data.progress = Math.min(splitChars(target).length, currentLen);
                if (data.progress > prevProgress) {
                    triggerFeedbackFlash(0.6);
                    spawnChargeAura("charge", 0.78 + data.progress * 0.05);
                    spawnFx("charge-glyph", 470 + Math.random() * 110, 216 + Math.random() * 34, 420, {
                        width: "72px",
                        height: "72px",
                        border: "1px dashed rgba(132, 245, 220, 0.9)"
                    });
                    addFloatMessage("選字完成", 430 + Math.random() * 90, 246 + Math.random() * 40, "#bff6ff");
                }

                if (typedText === target) {
                    const charCount = Math.max(1, splitChars(target).length);
                    if (stage.mechanic === "word_combo") {
                        for (let i = 0; i < charCount; i += 1) recordAttempt(true);
                        recordWordStat(data.currentWord, performance.now() - game.currentWordStart, true);
                        gainCombo(2.8 + charCount * 0.35);
                        addScore(80 + charCount * 26 + Math.min(140, game.combo * 3.6));
                        data.completed += 1;
                        setHeroState("attack", 180);
                        damageEnemy((1.2 + charCount * 0.22) * game.adaptive.wordDamageScale);
                        playSfx("correct", 0.58);
                        playSfx("skill", 0.46);
                        triggerTeleportStrike(1 + charCount * 0.08, "中打斬");
                        spawnImpactBurst(0.96 + charCount * 0.08, "enemy");
                        pulseHitLine(0.82 + charCount * 0.06);
                        showCombo(`中打連段 ${data.completed}/${data.target}`);
                        el.imeInput.value = "";
                        data.progress = 0;
                        game.imeLastHandledValue = "";
                        stage4NextWord();
                        if (data.completed % 3 === 0) rotateEnemyFromPool(getStage().enemyPool);
                        if (data.completed >= data.target) {
                            clearCurrentStage();
                            return;
                        }
                    } else {
                        const phase = data.phase || 1;
                        const hitScale = phase === 1 ? 1 : phase === 2 ? 0.92 : 0.84;
                        const counterMult = data.counterWindow > 0 ? data.counterBonus : 1;
                        for (let i = 0; i < charCount; i += 1) recordAttempt(true);
                        recordWordStat(data.currentWord, performance.now() - game.currentWordStart, true);
                        data.missStreak = 0;
                        gainCombo(3.3 + charCount * 0.28);
                        addScore(90 + charCount * 22 + counterMult * 18 + Math.min(180, game.combo * 3.8));
                        setHeroState("attack", 190);
                        damageEnemy((18 + charCount * 5 + Math.floor(game.combo * 0.18)) * hitScale * counterMult * game.adaptive.wordDamageScale);
                        if (game.stageData !== data) {
                            el.imeInput.value = "";
                            game.imeLastHandledValue = "";
                            renderPromptForStage();
                            updateObjectiveUI();
                            updateImePanelHint();
                            return;
                        }
                        data.distance = clamp(data.distance + (0.05 + charCount * 0.008), 0, 1.2);
                        data.approachPressure = clamp((data.approachPressure || 1) - (0.05 + charCount * 0.006), 0.88, data.approachPressureMax || 2.2);
                        playSfx("correct", 0.58);
                        playSfx("skill", 0.52);
                        triggerHeroDash();
                        triggerTeleportStrike(1.14 + charCount * 0.06 + (counterMult - 1) * 0.2, counterMult > 1.01 ? "中文字反擊斬" : "中文字爆斬");
                        spawnImpactBurst(1.02 + charCount * 0.08, "enemy");
                        pulseHitLine(0.96 + charCount * 0.08);
                        showCombo(counterMult > 1.01 ? "中文字反擊" : "中文字輸出");
                        el.imeInput.value = "";
                        data.progress = 0;
                        game.imeLastHandledValue = "";
                        stage5NextWord();
                        rotateEnemyFromPool(getStage().enemyPool);
                    }
                }
            } else {
                if (stage.mechanic === "word_combo") {
                    recordAttempt(false);
                    recordWordStat(data.currentWord, 0, false);
                    addScore(-20);
                    const targetChars = splitChars(target);
                    const tipChar = targetChars[data.progress] || targetChars[0] || "";
                    if (!useGraceShield(`提示：下一個字是 ${tipChar || "目標詞語"}`)) {
                        data.progress = 0;
                        softMistake(`選字錯了，重來一次。提示字：${tipChar || "請看目標"}`);
                    }
                } else {
                    recordAttempt(false);
                    recordWordStat(data.currentWord, 0, false);
                    addScore(-26);
                    data.missStreak = (data.missStreak || 0) + 1;
                    data.distance = clamp(data.distance - (0.03 + Math.min(0.04, data.missStreak * 0.01)), 0, 1.2);
                    data.approachPressure = clamp((data.approachPressure || 1) + 0.1, 0.9, data.approachPressureMax || 2.2);
                    data.approachSurgeTimer = Math.max(data.approachSurgeTimer || 0, 1.1);
                    const targetChars = splitChars(target);
                    const tipChar = targetChars[data.progress] || targetChars[0] || "";
                    if (data.missStreak <= 1) {
                        useGraceShield(`Boss字詞提示：${tipChar || "請看目標"}`);
                    } else if (data.missStreak === 2) {
                        punishWithProtection({ hpLoss: 1, reason: "選字失誤，魔王壓上來了", debuff: false, countMistake: false });
                    } else {
                        punishWithProtection({ hpLoss: 2, reason: "連續選字失誤！先擋住魔王快攻", debuff: true, countMistake: false });
                        startBossGuardPhase("魔王逼近");
                    }
                    data.progress = 0;
                }
                el.imeInput.value = "";
                game.imeLastHandledValue = "";
            }

            renderPromptForStage();
            updateObjectiveUI();
            updateImePanelHint();
        }

        function performUltimate() {
            if (game.qi < game.maxQi) {
                showToast("真氣未滿，無法施放大絕", 900);
                return;
            }
            recordAttempt(true);
            game.qi = 0;
            gainCombo(0);
            addScore(220 + Math.min(180, game.combo * 6));
            const data = game.stageData;
            const phase = data?.phase || 1;
            const phaseScale = phase === 1 ? 1 : phase === 2 ? 0.9 : 0.82;
            damageEnemy(102 * phaseScale * game.adaptive.wordDamageScale);
            if (game.stageData !== data) return;
            playSfx("skill", 0.9);
            playSfx("fire", 0.85);
            playSfx("crit", 0.85);
            setHeroState("attack", 360);
            showCombo("萬劍歸宗！");
            data.distance = clamp(data.distance + 0.35, 0, 1.2);
            if (data && typeof data.approachPressure === "number") {
                data.approachPressure = clamp(data.approachPressure - 0.16, 0.88, data.approachPressureMax || 2.2);
                data.approachSurgeTimer = Math.max(0, (data.approachSurgeTimer || 0) - 0.8);
            }
            triggerFeedbackFlash(1);
            triggerTeleportStrike(1.5, "萬劍歸宗");
            triggerArenaShake(1.45);
            addFloatMessage("全屏斬滅", 540, 280, "#ffdca5");
            for (let i = 0; i < 5; i += 1) {
                setTimeout(() => {
                    spawnSlashWave(1.2 + i * 0.1);
                    spawnEnemySpark(1 + i * 0.12);
                    spawnImpactBurst(1.05 + i * 0.1, "enemy");
                    pulseHitLine(1.1 + i * 0.08);
                }, i * 70);
            }
            rotateEnemyFromPool(getStage().enemyPool);
        }

        function handleBossInput(event, char) {
            const data = game.stageData;
            if (!data) return;

            if (event && event.code === "Space") {
                if (data.guardMode) {
                    showCoach("先防禦，再放大絕！", 700);
                    return;
                }
                performUltimate();
                renderPromptForStage();
                return;
            }

            const bopomofoBossMode = game.chineseMode && game.zhModeVariant === "bopomofo";
            const hanziBossMode = game.chineseMode && game.zhModeVariant === "hanzi";
            if (hanziBossMode && !data.guardMode) {
                // Hanzi boss typing is handled by the IME input box; keyboard stays reserved for guard/space.
                return;
            }

            const inputChar = bopomofoBossMode ? normalizeBopomofoKey(char) : normalizeChar(char);
            const phase = data.phase || 1;
            const hitScale = phase === 1 ? 1 : phase === 2 ? 0.92 : 0.84;
            const counterMult = data.counterWindow > 0 ? data.counterBonus : 1;

            if (data.guardMode) {
                const guardInput = (() => {
                    if (event?.code === "KeyF") return "f";
                    if (event?.code === "KeyJ") return "j";
                    return normalizeChar(char);
                })();
                if (!/^[a-z]$/.test(guardInput)) return;
                const correctGuard = guardInput === data.guardKey;
                recordAttempt(correctGuard);
                recordKeyStat(guardInput, correctGuard);
                if (correctGuard) {
                    const now = performance.now();
                    const remainMs = Math.max(0, data.guardDeadline - now);
                    const remainRatio = data.guardDuration > 0 ? remainMs / data.guardDuration : 0;
                    let guardLabel = "防禦成功";
                    let counterSeconds = 1.1;
                    let counterBonus = 1.08;
                    if (remainRatio >= 0.55) {
                        guardLabel = "完美防禦";
                        counterSeconds = 1.8;
                        counterBonus = 1.34;
                    } else if (remainRatio >= 0.3) {
                        guardLabel = "精準防禦";
                        counterSeconds = 1.45;
                        counterBonus = 1.2;
                    }

                    data.guardMode = false;
                    data.guardSuccess += 1;
                    data.missStreak = 0;
                    data.counterWindowMax = counterSeconds;
                    data.counterWindow = counterSeconds;
                    data.counterBonus = counterBonus;
                    resetBossGuardTimer(data);
                    data.approachPressure = clamp((data.approachPressure || 1) - 0.14, 0.88, data.approachPressureMax || 2.2);
                    data.approachSurgeTimer = Math.max(0, (data.approachSurgeTimer || 0) - 0.5);
                    rewardAction({
                        enemyDamage: 8.5 * hitScale * counterBonus * game.adaptive.wordDamageScale,
                        qiGain: 7.2,
                        hero: "defense",
                        sfx: "shield",
                        message: guardLabel,
                        heal: 1.6
                    });
                    if (game.stageData !== data) {
                        renderPromptForStage();
                        return;
                    }
                    triggerGuardBurst();
                    if (counterBonus >= 1.2) {
                        triggerTeleportStrike(1.08 + counterBonus * 0.12, "破招");
                    }
                    data.distance = clamp(data.distance + 0.08, 0, 1.2);
                    showCoach(`${guardLabel}！反擊窗口 ${counterSeconds.toFixed(1)} 秒`, 900);
                    addFloatMessage(`反擊 x${counterBonus.toFixed(2)}`, 520, 232, "#baf8ed");
                } else {
                    data.missStreak += 1;
                    data.distance = clamp(data.distance - 0.04, 0, 1.2);
                    data.approachPressure = clamp((data.approachPressure || 1) + 0.18, 0.9, data.approachPressureMax || 2.2);
                    data.approachSurgeTimer = Math.max(data.approachSurgeTimer || 0, 1.15);
                    punishWithProtection({
                        hpLoss: 2,
                        reason: `防禦鍵是 ${data.guardKey.toUpperCase()}，再專心一次！`,
                        debuff: true,
                        countMistake: false
                    });
                }
                renderPromptForStage();
                return;
            }

            if (!(bopomofoBossMode ? /^[a-z0-9,./;\-]$/.test(inputChar) : /^[a-z]$/.test(inputChar))) return;
            const displayChars = splitChars(data.currentWord);
            const inputWord = bopomofoBossMode ? (data.currentInputWord || "") : data.currentWord;
            const expectedChars = splitChars(inputWord);
            const expected = bopomofoBossMode ? expectedChars[data.progress] : normalizeChar(expectedChars[data.progress]);

            if (inputChar === expected) {
                recordAttempt(true);
                recordKeyStat(inputChar, true);
                data.missStreak = 0;
                gainCombo(3.1);
                addScore(16 + counterMult * 10 + Math.min(28, game.combo * 1.1));
                setHeroState("attack", 130);
                playSfx("correct", 0.54);
                playSfx("playerAttack", 0.48);
                data.progress += 1;
                damageEnemy(3.6 * hitScale * counterMult * game.adaptive.wordDamageScale);
                if (game.stageData !== data) {
                    renderPromptForStage();
                    return;
                }
                data.distance = clamp(data.distance + 0.02, 0, 1.2);
                data.approachPressure = clamp((data.approachPressure || 1) - 0.015, 0.88, data.approachPressureMax || 2.2);
                triggerFeedbackFlash(0.94);
                spawnChargeAura(counterMult > 1.01 ? "attack" : "charge", counterMult > 1.01 ? 1.02 : 0.82);
                spawnSlashWave(0.9);
                if (data.progress % 2 === 0) {
                    spawnEnemySpark(0.86);
                }
                if (counterMult > 1.01) {
                    spawnSlashWave(1.12);
                    addFloatMessage("反擊！", 590, 260, "#cffff4");
                }
                if (bopomofoBossMode && displayChars[data.progress - 1]) {
                    addFloatMessage(displayChars[data.progress - 1], 438 + Math.random() * 128, 226 + Math.random() * 84, "#c6fff1");
                }

                if (data.progress >= expectedChars.length) {
                    recordWordStat(data.currentWord, performance.now() - game.currentWordStart, true);
                    addScore(120 * counterMult + Math.min(160, game.combo * 4.5));
                    damageEnemy((27 + Math.floor(game.combo * 0.24)) * hitScale * counterMult * game.adaptive.wordDamageScale);
                    if (game.stageData !== data) {
                        renderPromptForStage();
                        return;
                    }
                    playSfx("crit", 0.7);
                    triggerHeroDash();
                    triggerTeleportStrike(
                        1.24 + (counterMult - 1) * 0.22,
                        counterMult > 1.01
                            ? (bopomofoBossMode ? "注音反擊爆斬" : game.chineseMode ? "中文字反擊爆斬" : "反擊爆斬")
                            : (bopomofoBossMode ? "注音劍氣爆發" : game.chineseMode ? "中文字爆發" : "劍氣爆發")
                    );
                    spawnSlashWave(1.35);
                    spawnEnemySpark(1.28);
                    showCombo(bopomofoBossMode ? "注音劍氣爆發" : game.chineseMode ? "中文字爆發" : "劍氣爆發");
                    data.approachPressure = clamp((data.approachPressure || 1) - (0.08 + Math.min(0.08, counterMult * 0.03)), 0.88, data.approachPressureMax || 2.2);
                    data.progress = 0;
                    stage5NextWord();
                    rotateEnemyFromPool(getStage().enemyPool);
                }
            } else {
                recordAttempt(false);
                recordKeyStat(inputChar, false);
                recordWordStat(data.currentWord, 0, false);
                addScore(-24);
                data.missStreak += 1;
                data.progress = Math.max(0, data.progress - 1);
                data.distance = clamp(data.distance - (0.02 + Math.min(0.03, data.missStreak * 0.008)), 0, 1.2);
                data.approachPressure = clamp((data.approachPressure || 1) + 0.12, 0.9, data.approachPressureMax || 2.2);
                data.approachSurgeTimer = Math.max(data.approachSurgeTimer || 0, 1.05);
                const nextHint = bopomofoBossMode ? (displayChars[data.progress] || displayChars[0]) : (expectedChars[data.progress] || expectedChars[0]);
                if (data.missStreak === 1) {
                    useGraceShield(bopomofoBossMode ? `先穩住符號節奏，下一個是 ${nextHint}` : "慢一點，先穩住字母節奏");
                } else if (data.missStreak === 2) {
                    punishWithProtection({
                        hpLoss: 1,
                        reason: bopomofoBossMode ? "魔王反擊，先看注音符號再按" : "魔王反擊，先看字再按",
                        debuff: false,
                        countMistake: false
                    });
                } else {
                    punishWithProtection({
                        hpLoss: 2,
                        reason: bopomofoBossMode ? "連續失誤！先防禦，再看符號輸出" : "連續失誤！先防禦再輸出",
                        debuff: true,
                        countMistake: false
                    });
                    startBossGuardPhase("魔王逼近");
                }
            }

            renderPromptForStage();
        }

        function handleInput(event) {
            if (game.mode !== "playing") return;
            const stage = getStage();
            if (!stage) return;
            const imeTypingStage =
                game.chineseMode &&
                game.inputLocale === "zh" &&
                (stage.mechanic === "word_combo" || (stage.mechanic === "boss_raid" && !game.stageData?.guardMode));
            if (imeTypingStage && !(stage.mechanic === "boss_raid" && event.code === "Space")) {
                updateImePanelHint();
                return;
            }
            const rawKey = getGameplayRawKey(event);
            const key = rawKey ? normalizeChar(rawKey) : "";

            if (stage.mechanic === "homefall") {
                handleHomefallInput(key);
            } else if (stage.mechanic === "top_anchor") {
                handleTopAnchorInput(key);
            } else if (stage.mechanic === "bottom_defense") {
                handleBottomDefenseInput(key);
            } else if (stage.mechanic === "word_combo") {
                handleWordComboInput(game.chineseMode && game.zhModeVariant === "bopomofo" ? rawKey : key);
            } else if (stage.mechanic === "boss_raid") {
                handleBossInput(event, game.chineseMode && game.zhModeVariant === "bopomofo" ? rawKey : key);
            }

            updateObjectiveUI();
        }

        function updateHomefall(dt) {
            const data = game.stageData;
            const rect = el.arena.getBoundingClientRect();
            const levelBoost = game.adaptive.level >= 4 ? 0.22 : game.adaptive.level >= 3 ? 0.12 : 0;
            const recoverySlow = game.errorStreak >= 4 ? 0.18 : game.errorStreak >= 3 ? 0.1 : 0;
            const speedFactor = clamp((2.18 - game.adaptive.spawnScale) + levelBoost - recoverySlow, 0.76, 1.55);
            const maxObjects = getAdaptiveSpawnCap("homefall");

            data.spawnTimer -= dt;
            if (data.spawnTimer <= 0) {
                if (data.objects.length < maxObjects) {
                    data.uid += 1;
                    data.objects.push({
                        id: data.uid,
                        char: pick(data.allowed),
                        x: rect.width - (120 + Math.random() * Math.max(100, rect.width * 0.34)),
                        y: -64,
                        drift: -(38 + Math.random() * 42),
                        speed: (96 + Math.random() * 56) * speedFactor
                    });
                }
                const elapsed = (performance.now() - game.stageStart) / 1000;
                const capPressure = data.objects.length >= maxObjects ? 1.15 : 1;
                const paceBoost = game.adaptive.level >= 4 ? 0.78 : game.adaptive.level >= 3 ? 0.88 : game.adaptive.level >= 2 ? 0.95 : 1;
                const recoveryEase = game.errorStreak >= 4 ? 1.26 : game.errorStreak >= 3 ? 1.14 : 1;
                data.spawnTimer = Math.max(0.34, (1.38 - elapsed * 0.013) * game.adaptive.spawnScale * capPressure * paceBoost * recoveryEase);
            }

            for (let i = data.objects.length - 1; i >= 0; i -= 1) {
                const obj = data.objects[i];
                obj.y += obj.speed * dt;
                obj.x += obj.drift * dt;
                if (obj.y > rect.height - 38) {
                    data.objects.splice(i, 1);
                    punishWithProtection({ hpLoss: 1, reason: "怪物符文爆開了，下一顆快打！" });
                }
            }
        }

        function updateTopAnchor() {
            const data = game.stageData;
            if (performance.now() > data.deadline) {
                if (data.expectedType === "anchor") {
                    recordAttempt(false);
                    punishWithProtection({
                        hpLoss: 1,
                        reason: "回防慢了一拍，別急再來",
                        countMistake: false
                    });
                    triggerEnemyCast();
                } else {
                    recordAttempt(false);
                    softMistake("跳慢了，重新起跳！");
                }
                data.expectedType = "top";
                stage2NextPrompt();
                renderPromptForStage();
            }
        }

        function updateBottomDefense(dt) {
            const data = game.stageData;
            const rect = el.arena.getBoundingClientRect();
            const levelBoost = game.adaptive.level >= 4 ? 0.28 : game.adaptive.level >= 3 ? 0.16 : game.adaptive.level >= 2 ? 0.08 : 0;
            const recoverySlow = game.errorStreak >= 4 ? 0.22 : game.errorStreak >= 3 ? 0.12 : 0;
            const speedFactor = clamp((2.14 - game.adaptive.spawnScale) + levelBoost - recoverySlow, 0.78, 1.58);
            const maxObjects = getAdaptiveSpawnCap("bottom_defense");

            data.spawnTimer -= dt;
            if (data.spawnTimer <= 0) {
                if (data.objects.length < maxObjects) {
                    data.uid += 1;
                    data.objects.push({
                        id: data.uid,
                        char: pick(data.allowed),
                        x: rect.width + 12,
                        y: 168 + Math.random() * Math.max(60, rect.height - 242),
                        speed: (138 + Math.random() * 68) * speedFactor
                    });
                }
                const elapsed = (performance.now() - game.stageStart) / 1000;
                const capPressure = data.objects.length >= maxObjects ? 1.14 : 1;
                const paceBoost = game.adaptive.level >= 4 ? 0.74 : game.adaptive.level >= 3 ? 0.86 : game.adaptive.level >= 2 ? 0.94 : 1;
                const recoveryEase = game.errorStreak >= 4 ? 1.28 : game.errorStreak >= 3 ? 1.16 : 1;
                data.spawnTimer = Math.max(0.3, (1.28 - elapsed * 0.013) * game.adaptive.spawnScale * capPressure * paceBoost * recoveryEase);
            }

            for (let i = data.objects.length - 1; i >= 0; i -= 1) {
                const obj = data.objects[i];
                obj.x -= obj.speed * dt;
                if (obj.x < 126) {
                    data.objects.splice(i, 1);
                    punishWithProtection({ hpLoss: 1, reason: "暗器穿過了，下一發擋住它！" });
                }
            }
        }

        function updateBossRaid(dt) {
            const data = game.stageData;
            const timedChallenge = isTimedChallengeActive();
            const endlessBoss = !!game.endlessBossMode;
            let nextPhase = 1;
            if (timedChallenge) {
                const elapsed = game.stageTimerTotal - game.stageTimerLeft;
                if (elapsed >= 120) nextPhase = 3;
                else if (elapsed >= 60) nextPhase = 2;
            } else if (endlessBoss) {
                const cycle = Math.max(0, game.stageCycles || 0);
                if (cycle >= 10) nextPhase = 3;
                else if (cycle >= 4) nextPhase = 2;
                const hpRatio = game.maxEnemyHp > 0 ? game.enemyHp / game.maxEnemyHp : 1;
                if (hpRatio <= 0.33) nextPhase = Math.max(nextPhase, 3);
                else if (hpRatio <= 0.66) nextPhase = Math.max(nextPhase, 2);
            } else {
                const hpRatio = game.maxEnemyHp > 0 ? game.enemyHp / game.maxEnemyHp : 1;
                if (hpRatio <= 0.66) nextPhase = 2;
                if (hpRatio <= 0.33) nextPhase = 3;
            }
            if (nextPhase !== data.phase) {
                data.phase = nextPhase;
                playSfx("buff", 0.48);
                showCoach(`魔王進入 Phase ${data.phase}，速度提升！`, 980);
                data.approachPressure = clamp((data.approachPressure || 1) + 0.08, 0.9, data.approachPressureMax || 2.2);
                data.approachSurgeTimer = Math.max(data.approachSurgeTimer || 0, 0.75);
                stage5NextWord();
            }

            const phaseDrainBoost = data.phase === 1 ? 1 : data.phase === 2 ? 1.18 : 1.36;
            if (timedChallenge) {
                data.timeLeft = game.stageTimerLeft;
            } else if (endlessBoss) {
                data.timeLeft = Infinity;
            } else {
                data.timeLeft -= dt;
            }
            data.approachSurgeTimer = Math.max(0, (data.approachSurgeTimer || 0) - dt);
            const surgeMult = data.approachSurgeTimer > 0 ? (1 + Math.min(0.65, data.approachSurgeTimer * 0.42)) : 1;
            const guardMult = data.guardMode ? 1.22 : 1;
            const missMult = 1 + Math.min(0.28, (data.missStreak || 0) * 0.05);
            const cycleMult = endlessBoss ? (1 + Math.min(0.24, (game.stageCycles || 0) * 0.012)) : 1;
            const basePressure = clamp(data.approachPressure || 1, 0.88, data.approachPressureMax || 2.2);
            data.distance = clamp(
                data.distance - dt * 0.0072 * game.adaptive.bossDrainScale * phaseDrainBoost * basePressure * surgeMult * guardMult * missMult * cycleMult,
                0,
                1.2
            );
            if (!data.guardMode) {
                data.guardChargeTimer -= dt;
            }
            data.coachTick -= dt;

            if (data.counterWindow > 0) {
                data.counterWindow = Math.max(0, data.counterWindow - dt);
                if (data.counterWindow <= 0) {
                    data.counterBonus = 1;
                }
            }

            if (data.coachTick <= 0) {
                data.coachTick = 6.8;
                if (data.guardMode) {
                    showCoach(`防禦鍵：${data.guardKey.toUpperCase()}，先擋再打！`, 820);
                } else {
                    showCoach(`Phase ${data.phase}：先穩定命中，再加速輸出。`, 760);
                }
            }

            if (!data.guardMode && data.guardChargeTimer <= 0) {
                startBossGuardPhase("魔王反擊");
            }

            if (data.guardMode) {
                if (!Number.isFinite(data.guardDeadline) || data.guardDeadline <= 0) {
                    data.guardMode = false;
                    resetBossGuardTimer(data);
                } else {
                    const remainMs = data.guardDeadline - performance.now();
                    if (remainMs <= 900 && !data.qteWarned) {
                        data.qteWarned = true;
                        playSfx("debuff", 0.38);
                        showCoach(`QTE 倒數！立刻按 ${data.guardKey.toUpperCase()}`, 760);
                    }
                }
            }

            if (data.guardMode && performance.now() > data.guardDeadline) {
                data.guardMode = false;
                data.missStreak += 1;
                data.distance = clamp(data.distance - 0.05, 0, 1.2);
                data.approachPressure = clamp((data.approachPressure || 1) + 0.16, 0.9, data.approachPressureMax || 2.2);
                data.approachSurgeTimer = Math.max(data.approachSurgeTimer || 0, 1.25);
                resetBossGuardTimer(data);
                punishWithProtection({ hpLoss: 2, reason: "防禦超時，魔王重擊！", debuff: true });
            }

            if (!data.panicShown && game.enemyHp <= game.maxEnemyHp * 0.2) {
                data.panicShown = true;
                if (timedChallenge) {
                    showCoach("魔王慌亂！保持節奏，一口氣收尾。", 1200);
                    addFloatMessage("魔王慌亂！", 608, 210, "#ffd5b3");
                } else {
                    showDialogue([
                        { speaker: "一指禪魔王（驚恐）", text: "不可能！你的眼睛明明直視前方，為什麼手指能精準命中所有穴位？這到底是什麼境界？！" }
                    ], () => {
                        game.mode = "playing";
                        syncImeInputVisibility();
                    });
                }
            }

            el.bossDistanceFill.style.width = `${Math.round(clamp(data.distance, 0, 1) * 100)}%`;

            if (!timedChallenge && !endlessBoss && data.timeLeft <= 0) {
                failStage("時間條歸零，魔王反噬成功");
            }

            if (data.distance <= 0) {
                if (timedChallenge) {
                    const crushPenalty = Math.min(120, 70 + ((data.phase || 1) * 12));
                    addScore(-crushPenalty);
                    game.stageMisses += 1;
                    game.stagePerfect = false;
                    data.guardMode = false;
                    data.counterWindow = 0;
                    data.counterWindowMax = 0;
                    data.counterBonus = 1;
                    data.distance = 0.78;
                    data.approachPressure = clamp((data.approachPressure || 1) + 0.2, 0.9, data.approachPressureMax || 2.2);
                    data.approachSurgeTimer = Math.max(data.approachSurgeTimer || 0, 1.35);
                    resetBossGuardTimer(data);
                    showCoach("魔王近身壓制！已拉開距離，先擋再打。", 980);
                } else {
                    failStage("魔王逼近至身前，劍陣破碎");
                }
            }
        }

        function updateGameplay(dt) {
            const stage = getStage();
            if (!stage || !game.stageData) return;

            if (isTimedChallengeActive()) {
                game.stageTimerLeft = Math.max(0, (game.stageTimerEndAt - performance.now()) / 1000);
                if (game.stageTimerLeft <= 0) {
                    finishTimedStage();
                    return;
                }
            }

            if (stage.mechanic !== "boss_raid" && typeof game.stageData.coachTick === "number") {
                game.stageData.coachTick -= dt;
                if (game.stageData.coachTick <= 0) {
                    game.stageData.coachTick = 7.2;
                    if (stage.mechanic === "homefall") {
                        showCoach("打符文集氣，滿 3 格自動斬。", 800);
                    } else if (stage.mechanic === "top_anchor") {
                        showCoach(`先集滿 ${game.stageData.cloudNeed} 格雲氣，再 F/J 回防。`, 780);
                    } else if (stage.mechanic === "bottom_defense") {
                        showCoach(`每擋 1 發充盾，滿 ${game.stageData.shieldNeed} 格自動反震。`, 780);
                    } else if (stage.mechanic === "word_combo") {
                        showCoach(
                            game.chineseMode
                                ? (game.zhModeVariant === "bopomofo"
                                    ? "看整串注音，按對應英文鍵位；完整打完才有傷害。"
                                    : "用注音輸入法選字，完整詞語才有傷害。")
                                : "完整打一個單字才有傷害。",
                            860
                        );
                    }
                }
            }

            if (stage.mechanic === "homefall") {
                updateHomefall(dt);
            } else if (stage.mechanic === "top_anchor") {
                updateTopAnchor();
            } else if (stage.mechanic === "bottom_defense") {
                updateBottomDefense(dt);
            } else if (stage.mechanic === "boss_raid") {
                updateBossRaid(dt);
            }

            updateObjectiveUI();
            renderProjectiles();
        }

        function loop(now) {
            const dtMs = Math.min(64, now - game.lastTick);
            const dt = dtMs / 1000;
            game.lastTick = now;

            if (game.mode === "playing") {
                updateGameplay(dt);
            }

            updateHeroAnimation(dtMs);
            updateEnemyAmbientFx(dt);
            updateHud();
            syncImeInputVisibility();
            requestAnimationFrame(loop);
        }

        function bindButtons() {
            const buttons = Array.from(document.querySelectorAll("button"));
            buttons.forEach((button) => {
                button.addEventListener("mouseenter", () => {
                    ensureAudioUnlocked();
                    playSfx("hover", 0.24);
                });
                button.addEventListener("click", () => {
                    ensureAudioUnlocked();
                    playSfx("click", 0.55);
                });
            });

            el.dialogueNext.addEventListener("click", () => advanceDialogue());

            el.btnStart.addEventListener("click", () => {
                ensureAudioUnlocked();
                resetRun(true);
                applyTypingMode("en");
                openStageSelectScreen();
            });

            el.btnStage5.addEventListener("click", () => {
                ensureAudioUnlocked();
                beginEndlessBossMode();
            });

            if (el.btnZhMode) {
                el.btnZhMode.addEventListener("click", () => {
                    ensureAudioUnlocked();
                    beginChineseMode("hanzi");
                });
            }

            if (el.btnZhBpmfMode) {
                el.btnZhBpmfMode.addEventListener("click", () => {
                    ensureAudioUnlocked();
                    beginChineseMode("bopomofo");
                });
            }

            if (el.btnCloudSave) {
                el.btnCloudSave.addEventListener("click", () => {
                    saveCloudSettings();
                });
            }

            if (el.btnCloudRefresh) {
                el.btnCloudRefresh.addEventListener("click", async () => {
                    await fetchCloudLeaderboard();
                });
            }

            if (el.btnCloudRefreshResult) {
                el.btnCloudRefreshResult.addEventListener("click", async () => {
                    await fetchCloudLeaderboard();
                });
            }

            if (el.btnUploadScore) {
                el.btnUploadScore.addEventListener("click", async () => {
                    await uploadPendingCloudScore();
                });
            }

            [el.cloudPlayerName, el.cloudSheetUrl].forEach((input) => {
                if (!input) return;
                input.addEventListener("keydown", (event) => {
                    if (event.key !== "Enter") return;
                    event.preventDefault();
                    saveCloudSettings();
                });
            });

            if (el.btnModeEn) {
                el.btnModeEn.addEventListener("click", () => {
                    applyTypingMode("en");
                    renderStageSelect();
                    showCoach("已切換英打模式。", 700);
                });
            }
            if (el.btnModeZhHanzi) {
                el.btnModeZhHanzi.addEventListener("click", () => {
                    applyTypingMode("zh-hanzi");
                    renderStageSelect();
                    showCoach("已切換國字中打（注音選字）。", 900);
                });
            }
            if (el.btnModeZhBpmf) {
                el.btnModeZhBpmf.addEventListener("click", () => {
                    applyTypingMode("zh-bpmf");
                    renderStageSelect();
                    showCoach("已切換純注音（鍵位對應）。", 900);
                });
            }

            el.btnSelectBack.addEventListener("click", () => {
                closeOverlays();
                game.mode = "title";
                setTitleOptionsOpen(false);
                el.titleScreen.classList.add("show");
                renderTitleLeaderboard();
                if (isCloudWebhookConfigured() && (!game.cloud.lastSyncAt || (Date.now() - game.cloud.lastSyncAt) > 45000)) {
                    fetchCloudLeaderboard({ silent: true });
                }
            });

            el.stageSelectGrid.addEventListener("click", (event) => {
                const btn = event.target.closest("[data-stage-play]");
                if (!btn) return;
                const stageIndex = Number(btn.getAttribute("data-stage-play"));
                if (!Number.isFinite(stageIndex) || stageIndex < 0 || stageIndex >= STAGES.length) return;
                ensureAudioUnlocked();
                playSfx("click", 0.55);
                beginStageChallenge(stageIndex, false);
            });

            el.btnTitleSettings.addEventListener("click", () => {
                setTitleOptionsOpen(!game.titleOptionsOpen);
            });

            el.btnAssist.addEventListener("click", () => {
                game.profile.assistMode = !game.profile.assistMode;
                refreshOptionButtons();
                writeProfile();
                showCoach(game.profile.assistMode ? "輔助模式已開啟" : "輔助模式已關閉", 900);
            });

            el.btnContrast.addEventListener("click", () => {
                game.profile.highContrast = !game.profile.highContrast;
                applyAccessibilityOptions();
                refreshOptionButtons();
                writeProfile();
            });

            el.btnMotion.addEventListener("click", () => {
                game.profile.reducedMotion = !game.profile.reducedMotion;
                applyAccessibilityOptions();
                refreshOptionButtons();
                writeProfile();
            });

            el.btnPause.addEventListener("click", () => {
                togglePause();
            });

            el.btnResume.addEventListener("click", () => {
                togglePause(false);
            });

            el.btnPauseToTitle.addEventListener("click", () => {
                const typingMode = getTypingModeKey();
                resetRun(true);
                applyTypingMode(typingMode);
                openStageSelectScreen();
            });

            el.btnReplay.addEventListener("click", () => {
                ensureAudioUnlocked();
                if (game.endlessBossMode) {
                    beginEndlessBossMode();
                } else {
                    beginStageChallenge(game.selectedStageIndex || 0, !!game.bossChallengeMode);
                }
            });

            el.btnPractice.addEventListener("click", () => {
                ensureAudioUnlocked();
                closeOverlays();
                resetRun(false);
                startPracticeMode();
            });

            el.btnRestart.addEventListener("click", () => {
                ensureAudioUnlocked();
                const typingMode = getTypingModeKey();
                resetRun(true);
                applyTypingMode(typingMode);
                openStageSelectScreen();
            });

            el.btnRetryStage.addEventListener("click", () => {
                ensureAudioUnlocked();
                closeOverlays();
                if (game.endlessBossMode) {
                    beginEndlessBossMode();
                    return;
                }
                const retryIndex = game.selectedStageIndex || game.stageIndex || 0;
                const keepBossMode = !!game.bossChallengeMode;
                const typingMode = getTypingModeKey();
                resetRun(false);
                applyTypingMode(typingMode);
                game.bossChallengeMode = retryIndex === 4 && keepBossMode;
                game.selectedStageIndex = retryIndex;
                loadStage(retryIndex, true);
            });

            el.btnFailRestart.addEventListener("click", () => {
                ensureAudioUnlocked();
                const typingMode = getTypingModeKey();
                resetRun(true);
                applyTypingMode(typingMode);
                openStageSelectScreen();
            });
        }

        function bindKeyboard() {
            if (el.imeInput) {
                el.imeInput.addEventListener("compositionstart", () => {
                    game.imeComposing = true;
                    game.imeDraftText = "";
                    updateImePanelHint();
                });
                el.imeInput.addEventListener("compositionupdate", (event) => {
                    game.imeDraftText = event.data || "";
                    updateImePanelHint();
                });
                el.imeInput.addEventListener("compositionend", () => {
                    game.imeComposing = false;
                    game.imeDraftText = "";
                    setTimeout(() => {
                        handleChineseWordComboImeInput();
                        updateImePanelHint();
                    }, 0);
                });
                el.imeInput.addEventListener("input", () => {
                    if (!game.imeComposing) handleChineseWordComboImeInput();
                    updateImePanelHint();
                });
            }

            window.addEventListener("keydown", (event) => {
                const imeFieldFocused = !!el.imeInput && document.activeElement === el.imeInput;
                const imeActive = imeFieldFocused && isChineseTypingStage();
                const stage = getStage();
                const allowBossSpaceThroughIme = imeActive && game.mode === "playing" && stage?.mechanic === "boss_raid" && event.code === "Space";
                const allowBossGuardThroughIme =
                    imeFieldFocused &&
                    game.mode === "playing" &&
                    stage?.mechanic === "boss_raid" &&
                    !!game.stageData?.guardMode &&
                    (event.code === "KeyF" || event.code === "KeyJ" || event.code === "Space");
                if (!imeActive && ["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Tab"].includes(event.code)) {
                    event.preventDefault();
                } else if (allowBossSpaceThroughIme) {
                    event.preventDefault();
                } else if (allowBossGuardThroughIme) {
                    event.preventDefault();
                }

                ensureAudioUnlocked();
                if (event.isComposing && !allowBossGuardThroughIme) return;

                if (game.mode === "cinematic" && (event.code === "Enter" || event.code === "Space")) {
                    if (game.victoryCinematic.active && typeof game.victoryCinematic.finish === "function") {
                        game.victoryCinematic.finish();
                    }
                    return;
                }

                if (event.code === "Escape" && (game.mode === "playing" || game.mode === "paused")) {
                    togglePause();
                    return;
                }

                if (game.mode === "dialogue" && (event.code === "Space" || event.code === "Enter")) {
                    advanceDialogue();
                    return;
                }

                if (imeActive && game.mode === "playing" && !allowBossSpaceThroughIme && !allowBossGuardThroughIme) {
                    return;
                }

                handleInput(event);
            });

            document.addEventListener("visibilitychange", () => {
                if (document.hidden && game.mode === "playing") {
                    game.autoPausedByBlur = true;
                    togglePause(true);
                }
            });

            window.addEventListener("blur", () => {
                if (game.mode === "playing") {
                    game.autoPausedByBlur = true;
                    togglePause(true);
                }
            });
        }

        async function bootstrap() {
            game.mode = "loading";
            readProfile();
            applyAccessibilityOptions();
            initStaticUI();
            syncCloudSettingsInputs();
            renderTitleLeaderboard();
            if (isCloudWebhookConfigured()) {
                setCloudSettingsStatus("已讀取雲端設定，等待同步。", "neutral");
                setTitleLeaderboardStatus("等待同步", "neutral");
            } else {
                setCloudSettingsStatus("可填入 Google Apps Script Web App URL 來啟用排行榜。", "neutral");
                setTitleLeaderboardStatus("尚未設定 URL", "warn");
            }
            syncCloudUploadPanelState();
            bindButtons();
            bindKeyboard();
            setScene("title");
            applyStageVisual(1);
            buildAmbientSparks();
            playBgm("title");
            refreshOptionButtons();
            setTitleOptionsOpen(false);
            renderStageSelect();
            updateHud();
            updateStageTrack();
            syncImeInputVisibility();
            requestAnimationFrame(loop);
            try {
                await runLoadingSequence();
            } catch (error) {
                setLoadingProgress(1, 1, "載入過程發生問題，將直接進入遊戲。");
                await new Promise((resolve) => setTimeout(resolve, 400));
            }
            if (el.loadingScreen) el.loadingScreen.classList.remove("show");
            if (el.titleScreen) el.titleScreen.classList.add("show");
            game.mode = "title";
            if (isCloudWebhookConfigured()) {
                fetchCloudLeaderboard({ silent: true });
            }
        }

        bootstrap();
    </script>
</body>
</html>
